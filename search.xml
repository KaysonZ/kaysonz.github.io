<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从C到CPP的迁移</title>
      <link href="/posts/995182.html"/>
      <url>/posts/995182.html</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="为什么会有这篇笔记"><a href="#为什么会有这篇笔记" class="headerlink" title="为什么会有这篇笔记"></a>为什么会有这篇笔记</h2><h2 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h2><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><hr><h1 id="基本语法内的新特性"><a href="#基本语法内的新特性" class="headerlink" title="基本语法内的新特性"></a>基本语法内的新特性</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在C语言中仅有值传递和地址传递，而C++除此之外还可以进行引用传递。</p><hr><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>C语言中若要使用默认参数，仅能通过宏实现。</p><hr><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="函数重载基本用法"><a href="#函数重载基本用法" class="headerlink" title="函数重载基本用法"></a>函数重载基本用法</h3><p>函数重载是为了提高函数名复用性或是使得函数兼容更多数据类型诞生的。它允许两个函数使用同样的名称，通过<strong>传入的参数不同</strong>来进行区分。C++编程中支持函数重载，而C不支持。</p><p>所谓传入的参数不同，可以是参数的类型不同，例如<code>func(int a)</code>和<code>func(double a)</code>；也可以是参数的个数不同，例如<code>func(int a)</code>和<code>func(int a, int b)</code>；还可以是顺序不同，例如<code>func(int a, double b)</code>和<code>func(double b, int a)</code>。</p><p>例如如下示例。下面两个函数，虽说它们的名字相同，但是由于一个参数类型是int，一个参数类型是double。在调用<code>func</code>函数时，若传入<code>func(1)</code>，则调用第一个；若传入<code>func(3.14)</code>，则调用第二个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载-默认参数"><a href="#函数重载-默认参数" class="headerlink" title="函数重载+默认参数"></a>函数重载+默认参数</h3><p>当函数中使用了默认参数时，需要注意在忽略默认参数后函数参数有差异。例如如下示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><p>此时，在传入诸如<code>func(233)</code>的时候，编译器无法区分是调用默认b=0的<code>func</code>还是仅传入a的<code>func</code>，因此会报错。</p><h3 id="const修饰参数的重载"><a href="#const修饰参数的重载" class="headerlink" title="const修饰参数的重载"></a>const修饰参数的重载</h3><p>有时会通过在传入函数时用<code>const</code>修饰来避免值在函数内被修改。例如<code>string.h</code>库内的<code>strcmp(const char* str1, const char* str2)</code>。普通<code>char</code>类型也可以传入<code>const char*</code>（部分编译器会给个警告，有些编译器连警告都没有），但是如果用<code>const</code>区分了函数重载,优先使用最匹配的类型。例如如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a)</span></span></span><br></pre></td></tr></table></figure><p>那么，在<code>char a = &#39;H&#39;;</code>后，调用<code>func(a)</code>，会优先调用<code>func(char* a)</code>。因为他们参数类型匹配。如果要调用<code>func(const char* a)</code>，则需要进行强制类型转换<code>func((const char*) a)</code>。</p><p>当然，在传入<code>func(&#39;H&#39;)</code>时，也是调用第二个，因为<code>&#39;H&#39;</code>在编译器中时默认申领了一个<code>const</code>类型的变量再进行传递。</p><hr><h2 id="用new在堆区开辟内存"><a href="#用new在堆区开辟内存" class="headerlink" title="用new在堆区开辟内存"></a>用new在堆区开辟内存</h2><hr><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><h3 id="类和对象是什么"><a href="#类和对象是什么" class="headerlink" title="类和对象是什么"></a>类和对象是什么</h3><ul><li>类由成员变量和成员函数构成</li><li>成员变量被称为该类的 属性</li><li>成员函数被称为该类的 方法</li><li>类中所囊括的东西（包含属性和行为）被称为类的成员。</li></ul><h3 id="类的权限"><a href="#类的权限" class="headerlink" title="类的权限"></a>类的权限</h3><p>类的访问权限有三种：</p><ul><li>public：成员在 类内、类外均可访问。</li><li>protected：成员在 类内可访问，类外不可访问。在继承时，子类可以访问父类该权限下的成员。</li><li>private：成员在 类内可访问，类外不可访问。在继承时，子类无权访问父类该权限下的成员。</li></ul><h4 id="通过属性私有、方法公开的方式，实现C中的断言机制"><a href="#通过属性私有、方法公开的方式，实现C中的断言机制" class="headerlink" title="通过属性私有、方法公开的方式，实现C中的断言机制"></a>通过属性私有、方法公开的方式，实现C中的断言机制</h4><p>熟悉STM32 HAL库的同学可能经常见到<code>assert</code>断言宏，几乎在HAL库的每一个库函数内都会调用断言宏来判断输入的参数是否合理。在C++中，可以通过将属性放在private，操作该属性的函数放在public来实现这一点。</p><p>举个例子，现在有一个重庆邮电大学的类。该类内有一个属性是重庆邮电大学的title，将其定义为private，并在public内设<code>getTitle()</code>和<code>setTitle()</code>函数去操作它。在<code>setTitle()</code>内写当发现这个title = 985或者title = 211的时候，都认为它是非法的，不予赋值。因为title处于私有，因此不可外部直接赋值，必须通过<code>setTitle()</code>进行赋值，而<code>setTitle()</code>又避免了211或者985这样的非法参数。此时就对输入参数的合法性做出了断言。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQUPT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTitle</span><span class="params">(<span class="type">int</span> i_title)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i_title == <span class="number">985</span> &amp;&amp; i_title== <span class="number">211</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            title = i_title;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> title;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的6大基本函数"><a href="#类的6大基本函数" class="headerlink" title="类的6大基本函数"></a>类的6大基本函数</h3><p>在C++中，就算创造一个空类，也会默认包含这六个成员函数——构造函数、拷贝构造函数、析构函数、赋值操作重载、取地址操作符重载、const修饰的取地址操作符重载。</p><p><strong>引入：对象的初始化和清理——（拷贝）构造函数和析构函数</strong></p><p>C++的对象同变量是一样的。如果在某个函数内创建则创建在栈区；如果在函数外创建则创建在全局区（在部分单片机上认为全局区就是堆区）；如果使用new创建则创建在堆区。</p><p>以创建在栈区的对象为例，当调用某个函数时，这个对象会在栈区被创建，当函数return在回收这一帧栈帧时，对象也会被回收。</p><p>在创建对象时，会自动调用构造函数将其成员初始化。在这个对象被释放时，会自动调用析构函数对其进行清理。构造函数和析构函数可以人为定义，如果人为定义留空，则编译器自动补充一个空函数（对于拷贝构造函数而言是全属性赋值函数，下面会详细介绍）。</p><h4 id="1-初始化类属性——构造函数"><a href="#1-初始化类属性——构造函数" class="headerlink" title="1. 初始化类属性——构造函数"></a>1. 初始化类属性——构造函数</h4><p><strong>直接使用构造函数内进行赋值，来初始化属性：</strong></p><p>构造函数是与类同名的函数，函数无返回值，定义也无需加返回类型。例如下例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">example</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">example</span>()&#123;</span><br><span class="line">            <span class="comment">/*构造函数内容...*/</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    example obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用<code>example obj;</code>创建对象时，就会自动调用<code>example()</code>函数。构造</p><p>构造函数是支持传入参数的，可以在创建对象时利用括号传入，例如下面代码就传入了10：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">example</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">example</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">            <span class="comment">/*构造函数内容...*/</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">example <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//加个括号传入参数，这种方法用的最多。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>有部分教程会给出其他的赋值方法，利用显式、隐式转换等等，那些方法在部分编译器上是可用的（例如VC++）。但是部分编译器不！支！持！</p><p>例如DevCpp IDE就会对 <code>example test = example(10)</code>和 <code>example test = 10</code>这种写法报错，仅允许<code>example test = test0</code>（test0是另一个同类对象）。更何况，在嵌入式系统下编译器都是经过魔改的（例如Arduino）<strong>因此强烈建议不要使用</strong>。</p></div><p>举一个实际应用的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//学生的年龄</span></span><br><span class="line">    <span class="type">char</span>* shcool;<span class="comment">//学生的学校</span></span><br><span class="line">    <span class="built_in">student</span>(<span class="type">int</span> i_age,<span class="type">char</span>* i_shcool)&#123;<span class="comment">//构造函数</span></span><br><span class="line">        age = i_age; shcool = i_shcool;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">GaoXinBo</span><span class="params">(<span class="number">18</span>,<span class="string">&quot;CQUPT&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用初始化列表来初始化属性：</strong></p><h4 id="2-特殊的构造函数——拷贝构造函数"><a href="#2-特殊的构造函数——拷贝构造函数" class="headerlink" title="2. 特殊的构造函数——拷贝构造函数"></a>2. 特殊的构造函数——拷贝构造函数</h4><p>同时，构造函数也支持函数重载，即可以定义多个构造函数，根据创建对象时传入的参数来判定调用哪个进行初始化。那么定义多个构造函数有啥用呢？<strong>一方面它可以允许不同的初始化方式；另一方面构造函数可以被看成普通构造函数和拷贝构造函数两个大类，拷贝构造函数将在该对象值被传递时调用。下面将详细演示</strong></p><p>普通构造函数就是直接传入属性初始化参数或甚至不传入参数，来对属性进行赋值和初始化的。<strong>而拷贝构造函数的参数是这个对象本身</strong>，其是传入一个同类型的对象，然后将这个对象内的属性“拷贝”到这个新创建的对象上去。下面的代码就展示了一个普通构造函数和一个拷贝构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//学生的年龄</span></span><br><span class="line">    <span class="type">char</span> shcool[<span class="number">10</span>];<span class="comment">//学生的学校</span></span><br><span class="line">    <span class="built_in">student</span>(<span class="type">int</span> i_age,<span class="type">char</span> i_shcool[<span class="number">10</span>])&#123;<span class="comment">//普通的构造函数</span></span><br><span class="line">        age = i_age; shcool = i_shcool;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">student</span>(<span class="type">const</span> student &amp;stu)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        age = stu.age; shcool = stu.shcool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，其实所谓拷贝构造函数和普通构造函数并无差异，无非就一个特殊一点的，以传入一个同类对象为参数的函数罢了。那拷贝构造函数有什么意义呢？在下面这些场景中，就可以用拷贝构造函数进行初始化：</p><ul><li>已经构建出一个对象，需要创建这个对象当前状态的一个副本</li><li>对象在函数间被传递的时候</li></ul><p>第一个很好理解，有些时候需要创建xxx对象的副本xxx_old，此时如果用普通构造函数传参进去来初始化，则需要<code>xxx.属性1</code>，<code>xxx.属性2</code>这样一个一个地访问。而拷贝构造函数可以直接传入xxx对象，在函数内逐个访问进行赋值。例如下面这段代码，就创建了一个<code>stu_old</code>做为<code>stu1</code>的副本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//学生的年龄</span></span><br><span class="line">    <span class="type">char</span>* shcool;<span class="comment">//学生的学校</span></span><br><span class="line">    <span class="built_in">student</span>(<span class="type">int</span> i_age,<span class="type">char</span>* i_shcool)&#123;<span class="comment">//普通的构造函数</span></span><br><span class="line">        age = i_age; shcool = i_shcool;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">student</span>(<span class="type">const</span> student &amp;stu)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        age = stu.age; shcool = stu.shcool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">stu1</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;CQUPT&quot;</span>)</span></span>;<span class="comment">//调用普通构造函数初始化对象stu1</span></span><br><span class="line">    <span class="function">student <span class="title">stu_old</span><span class="params">(stu1)</span></span>;<span class="comment">//调用拷贝构造函数将stu1拷贝至stu_old</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象在函数间被传递调用拷贝构造函数是指的如下这种情况，在下面的代码中，函数<code>func</code>接受的参数是stu对象，在调用时传入了<code>stu1</code>；此时这个函数内的stu对象就会调用拷贝构造函数拷贝<code>stu1</code>对它进行初始化。在return时，使用<code>stu2</code>对象接住了函数return的<code>stu</code>，此时<code>stu2</code>也是调用拷贝构造函数将<code>stu</code>内的状态拷贝至<code>stu2</code>内。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//学生的年龄</span></span><br><span class="line">    <span class="type">char</span>* shcool;<span class="comment">//学生的学校</span></span><br><span class="line">    <span class="built_in">student</span>(<span class="type">int</span> i_age,<span class="type">char</span>* i_shcool)&#123;<span class="comment">//普通的构造函数</span></span><br><span class="line">        age = i_age; shcool = i_shcool;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">student</span>(<span class="type">const</span> student &amp;stu)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        age = stu.age; shcool = stu.shcool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">student <span class="title">func</span><span class="params">(student stu)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*函数内容...*/</span></span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">stu1</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;CQUPT&quot;</span>)</span></span>;<span class="comment">//调用普通构造函数初始化对象stu1</span></span><br><span class="line">    <span class="function">student <span class="title">stu2</span><span class="params">(func(stu1))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当用户未定义普通构造函数或拷贝构造函数时，编译器默认提供一个空函数；</li><li>当用户未定义拷贝构造函数时，编译器默认提供一个全属性拷贝的拷贝构造函数；</li><li>一旦用户提供了拷贝构造函数，编译器也不会提供普通构造函数</li></ul><h4 id="3-清理类属性——析构函数"><a href="#3-清理类属性——析构函数" class="headerlink" title="3. 清理类属性——析构函数"></a>3. 清理类属性——析构函数</h4><p>前面提到，析构函数是在编译器在</p><hr><h2 id="类的内存布局"><a href="#类的内存布局" class="headerlink" title="类的内存布局"></a>类的内存布局</h2><hr><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><hr><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h1 id="STL库"><a href="#STL库" class="headerlink" title="STL库"></a>STL库</h1><p>（Standard Template Library，STL，C++标准模板库）</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2>]]></content>
      
      
      <categories>
          
          <category> 各种折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代通信网络-罐装知识</title>
      <link href="/posts/53f688fc.html"/>
      <url>/posts/53f688fc.html</url>
      
        <content type="html"><![CDATA[<h1 id="电路交换和分组交换"><a href="#电路交换和分组交换" class="headerlink" title="电路交换和分组交换"></a>电路交换和分组交换</h1><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/Screenshot_2024-04-19-15-14-43-656_com.miui.notes.jpg" alt="Screenshot_2024-04-19-15-14-43-656_com.miui.notes" style="zoom:50%;" /></p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><strong>描述：</strong>连接建立开始时，通信系统分配给它的资源（通道、带宽、时隙、码字等等），通信活动的整个过程中，这个连接将始终占用着。电路交换总体可以分为这三步：1. 建立（establish）连接；2. 通话；3.释放连接</p><p><strong>电路交换的优点：</strong></p><ul><li>无需额外资源开销：业务数据不含有Header，透明传输（Transparent transmission）</li><li>通信延迟小</li><li>有序传输</li><li>控制简单</li></ul><p><strong>电路交换的缺点：</strong></p><ul><li>资源利用率较低：尽管没有数据传输资源也被占用</li><li>鲁棒性差：只要所建立的物理通路中有一点出现故障，就必须拨号重新建立连接</li><li>一旦无法建立连接，通信就无法进行。</li></ul><p>在要求数据按先后顺序且以恒定速率快速传输的情况下或实时性要求较高时，使用电路交换是较为理想的选择。最典型的应用是传统电信网络。</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><strong>描述：</strong>分组交换（packet switching）是将数据打包成分组（Packets）进行传输、交换。数据包包含标头(Header)，和负载(Payload)。标头包含分组的基本信息，例如地址信息，管理信息等。分组通过最优路径（取决于 路由算法）路由到目标。分组交换可细分为虚电路和数据报。分组交换的颗粒度（granularity）越小，花在header上的开销就越多。</p><p><strong>分组交换的优点：</strong></p><ul><li>线路利用率高：不同用户共享线路容量</li></ul><p><strong>分组交换的缺点：</strong></p><ul><li>更高的转发时延</li><li>可能出现拥塞问题</li></ul><p><strong>虚电路：</strong>一旦路由建立，路径便不会再做更改。它中间路由的节点只需要查看数据包从哪来，然后换上新的要到哪去的标签。转发时延小：不需要每次建立路由。帧时序确定：路径不可变换，因此链路保证时序。鲁棒性不如数据报：一旦路径中节点断开，则需重新建立连接</p><p><strong>数据报：</strong>datagram不一定会让各个数据走同样的路由。每一个packet都独自路由。因此可能出现帧乱序。但是原先路径在通信过程中不可达，也可以走其他路径，鲁棒性更高，更灵活。</p><p>典型的应用是计算机网络（internet），因为其要求来去自由的灵活性。</p><h1 id="MAC帧结构"><a href="#MAC帧结构" class="headerlink" title="MAC帧结构"></a>MAC帧结构</h1><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240522165158941.png" alt="image-20240522165158941"></p><h1 id="传输时延和传播时延"><a href="#传输时延和传播时延" class="headerlink" title="传输时延和传播时延"></a>传输时延和传播时延</h1><h2 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h2><p>如果收发机传输速率为R(bps)，传输大小为B（bits），则完成发送所需的传输时延为</p><script type="math/tex; mode=display">T=\frac{B}{R}</script><p>在CSMA/CD下需要传输时延大于2倍传播时延，才可以在发送时发现碰撞</p><h2 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h2><script type="math/tex; mode=display">B=R\times \frac{d}{V}</script><p>其中：</p><ul><li>B：链路长度（单位：bit），这个链路的物理长度能容纳多长的比特流</li><li>R：数据传输速率 (单位：bps)</li><li>d：收发机间物理距离 （单位：m）</li><li>V：介质中信号传播速度（单位：m/s）</li></ul><h1 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h1><h2 id="Stop-Wait-ARQ"><a href="#Stop-Wait-ARQ" class="headerlink" title="Stop-Wait ARQ"></a>Stop-Wait ARQ</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240410163738106.png" alt="image-20240410163738106"></p><ol><li>数据正常传输：接收机接收数据后，ACK下一帧的label</li><li>发送数据丢失：接收机不ACK，发送机在等待超时后重发数据</li><li>ACK信号丢失：发送机重传同一label的帧，接收机发现其和上一个为同一label，再次发送下一帧的ACK</li></ol><h2 id="Go-back-N-ARQ"><a href="#Go-back-N-ARQ" class="headerlink" title="Go back N ARQ"></a>Go back N ARQ</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240417170821082.png" alt="image-20240417170821082"></p><ol><li>A-&gt;B帧损坏：<ul><li>在损坏帧出现后A持续发送，B发现帧label不连续，B会丢弃损坏帧之后的所有帧。并返回REJ(帧i)，来告知A从帧i开始重发后续所有。</li><li>在损耗帧出现后A无数据发送，B此时会认为A没有数据发送。待A的timer超时后，A向B发送 P bit = 1的RR frame，B收到后立马应答一个期望的帧。</li></ul></li><li>B-&gt;A RR损坏<ul><li>B后续还有RR发送：A可以通过后续B发送RR更新自己的窗</li><li>后续无RR发送：A的timer超时后，A向B发送 P bit = 1的RR frame，B收到后立马应答一个RR.</li></ul></li><li>REJ损坏<ul><li>A的timer超时后，A向B发送 P bit = 1的RR frame，B收到后立马应答一个想要的帧。</li></ul></li></ol><h2 id="Select-Rejective-ARQ"><a href="#Select-Rejective-ARQ" class="headerlink" title="Select Rejective ARQ"></a>Select Rejective ARQ</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240417174743653.png" alt="image-20240417174743653"></p><ol><li>A-&gt;B帧损坏：<ul><li>在损坏帧出现后A持续发送，B发现帧label不连续，B会丢弃损坏帧,但接收之后的帧。并返回SREJ(帧i)，来告知A从帧i开始重发后续所有。</li><li>在损耗帧出现后A无数据发送，B此时会认为A没有数据发送。待A的timer超时后，A向B发送 P bit = 1的RR frame，B收到后立马应答一个期望的帧。</li></ul></li><li>B-&gt;A RR损坏<ul><li>B后续还有RR发送：A可以通过后续B发送RR更新自己的窗</li><li>后续无RR发送：A的timer超时后，A向B发送 P bit = 1的RR frame，B收到后立马应答一个RR.</li></ul></li><li>SREJ损坏<ul><li>A的timer超时后，A向B发送 P bit = 1的RR frame，B收到后立马应答一个想要的帧。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 现代通信网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Control-Systems-Part2-Lectrue4-根轨迹</title>
      <link href="/posts/b7f662c5.html"/>
      <url>/posts/b7f662c5.html</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>我们在研究系统极点的路径时，都是对闭环传递函数而言的。因为闭环传递函数的零极点可以直接反应系统的一些特性，例如稳定性，收敛速度，是否存在过冲等等。</p><p>考虑下图这样的一个系统，其系统闭环传递函数为$\frac{KG(s)}{1+KG(s)H(s)}$。我们研究的就是$1+KG(s)H(s)=0$时产生的极点。但是，我们的分析对象其实是$G(s)H(s)$这个开环传递函数，我们是通过分析OLTF，来研究CLTF的根。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621195148094.png" alt="image-20240621195148094"></p><p>而所谓根轨迹，就是随着增益K的变换，CLTF极点的移动路径。而这个轨迹可以通过CLTF，即$G(s)H(s)$的极点和零点绘制出来。</p><h1 id="根轨迹的基本特性"><a href="#根轨迹的基本特性" class="headerlink" title="根轨迹的基本特性"></a>根轨迹的基本特性</h1><div class="note info flat"><p>Dr.Huda PPT上的规则比较基础，但下一章会用到超出这个范围外的知识。这个视频讲了更普适的规则<a href="https://www.bilibili.com/video/BV19E411a7jk/?spm_id_from=333.788&amp;vd_source=69d49a5680f58d9a0f04ae8cf1207d1d">【自动控制原理】8_根轨迹_Part2_根轨迹手绘技巧_哔哩哔哩_bilibili</a>。下面的笔记是结合二者写的</p></div><h2 id="根轨迹的数种规则"><a href="#根轨迹的数种规则" class="headerlink" title="根轨迹的数种规则"></a>根轨迹的数种规则</h2><h3 id="规则1：系统的根轨迹条数等于系统极点个数或零点个数（取最大的那个）"><a href="#规则1：系统的根轨迹条数等于系统极点个数或零点个数（取最大的那个）" class="headerlink" title="规则1：系统的根轨迹条数等于系统极点个数或零点个数（取最大的那个）"></a>规则1：系统的根轨迹条数等于系统极点个数或零点个数（取最大的那个）</h3><p>例如$G(s)=\frac{(s+4)(s+1)}{(s+3)(s+0.5)}$，系统有2个零点2个极点，Max(2,2)=2，因此系统有两条根轨迹</p><h3 id="规则2：根轨迹总是从OLTF的极点移动到OLTF的零点"><a href="#规则2：根轨迹总是从OLTF的极点移动到OLTF的零点" class="headerlink" title="规则2：根轨迹总是从OLTF的极点移动到OLTF的零点"></a>规则2：根轨迹总是从OLTF的极点移动到OLTF的零点</h3><p>我们先来研究一下系统的特征方程。为了简化举例，这里考虑单位反馈系统，其传递函数是：</p><script type="math/tex; mode=display">\frac{1}{1+KG(s)}</script><p>其特征方程是：</p><script type="math/tex; mode=display">1+KG(s)=0</script><p>其中，$G(s)$称为Loop gain（$KG(s)$才是OLTF），其可以拆分为分子和分母部分：$G(s)=\frac{M(s)}{D(s)}$，特征方程为</p><script type="math/tex; mode=display">1+K\frac{M(s)}{D(s)}=0</script><p>改写一下就是：</p><script type="math/tex; mode=display">D(s)+KN(s)=0</script><p>前面提到，根轨迹是$K=0\to\infty$。当$K=0$时，特征方程的是$D(s)=0$，因此是OLTF的极点；当$K=\infty$时，特征方程是$N(s)=0$，因此是OLTF的零点。</p><h3 id="规则3：实轴上的根轨迹存在于从右向左数，OLTF的奇数个极点或零点的左侧。"><a href="#规则3：实轴上的根轨迹存在于从右向左数，OLTF的奇数个极点或零点的左侧。" class="headerlink" title="规则3：实轴上的根轨迹存在于从右向左数，OLTF的奇数个极点或零点的左侧。"></a>规则3：实轴上的根轨迹存在于从右向左数，OLTF的奇数个极点或零点的左侧。</h3><p>如下图所示。<strong>需要注意的是，只在实轴上有这个规则</strong>。</p><p><img src="C:\Users\17997\AppData\Roaming\Typora\typora-user-images\image-20240621203817692.png" alt="image-20240621203817692"></p><h3 id="规则4：如果复数根存在，则其一定是共轭的，即沿着实轴对称"><a href="#规则4：如果复数根存在，则其一定是共轭的，即沿着实轴对称" class="headerlink" title="规则4：如果复数根存在，则其一定是共轭的，即沿着实轴对称"></a>规则4：如果复数根存在，则其一定是共轭的，即沿着实轴对称</h3><h3 id="规则5：若极点和零点的个数不足以让它们成对，则会孤立的根轨迹会指向无穷或从无穷来"><a href="#规则5：若极点和零点的个数不足以让它们成对，则会孤立的根轨迹会指向无穷或从无穷来" class="headerlink" title="规则5：若极点和零点的个数不足以让它们成对，则会孤立的根轨迹会指向无穷或从无穷来"></a>规则5：若极点和零点的个数不足以让它们成对，则会孤立的根轨迹会指向无穷或从无穷来</h3><ul><li>对极点而言，它将指向无穷。如下图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621204526101.png" alt="image-20240621204526101"></p><ul><li>对零点而言，将从无穷指向它。如下图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621204542325.png" alt="image-20240621204542325"></p><h3 id="规则6：根轨迹沿渐近线移动。渐近线求法如下"><a href="#规则6：根轨迹沿渐近线移动。渐近线求法如下" class="headerlink" title="规则6：根轨迹沿渐近线移动。渐近线求法如下"></a>规则6：根轨迹沿渐近线移动。渐近线求法如下</h3><p>记极点个数为n，零点个数为m。渐近线与实轴的交点是：</p><script type="math/tex; mode=display">\sigma=\frac{极点的和-零点的和}{n-m}</script><p>渐近线与实轴的夹角是：</p><script type="math/tex; mode=display">\theta=\frac{2q+1}{n-m}\pi,q=0,1,...,n-m-1</script><p><em>举个例子：对于$\frac{1}{(s+1)(s+2)}$</em></p><script type="math/tex; mode=display">\sigma=\frac{-1-2+0}{2}=-1.5</script><script type="math/tex; mode=display">\theta_1=\frac{1}{2}\pi,\theta_2=\frac{3}{2}\pi</script><p>如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621205304651.png" alt="image-20240621205304651"></p><h3 id="规则7：两条根轨迹永不相交"><a href="#规则7：两条根轨迹永不相交" class="headerlink" title="规则7：两条根轨迹永不相交"></a>规则7：两条根轨迹永不相交</h3><h3 id="规则8：如果至少有两条根轨迹指向无穷，则所有根的合是一个常数"><a href="#规则8：如果至少有两条根轨迹指向无穷，则所有根的合是一个常数" class="headerlink" title="规则8：如果至少有两条根轨迹指向无穷，则所有根的合是一个常数"></a>规则8：如果至少有两条根轨迹指向无穷，则所有根的合是一个常数</h3><h3 id="汇总："><a href="#汇总：" class="headerlink" title="汇总："></a>汇总：</h3><ul><li><p>规则1：系统的根轨迹条数等于系统极点个数或零点个数（取最大的那个）</p></li><li><p>规则2：根轨迹总是从OLTF的极点移动到OLTF的零点</p></li><li><p>规则3：实轴上的根轨迹存在于从右向左数，OLTF的奇数个极点或零点的左侧。</p></li><li><p>规则4：如果复数根存在，则其一定是共轭的，即沿着实轴对称</p></li><li><p>规则5：若极点和零点的个数不足以让它们成对，则会孤立的根轨迹会指向无穷或从无穷来（极点无穷去，零点无穷来）</p></li><li><p>规则6：根轨迹沿渐近线移动，渐近线与实轴交点：$\sigma=\frac{极点的和-零点的和}{n-m}$，与实轴角度：$\theta=\frac{2q+1}{n-m}\pi,q=0,1,…,n-m-1$。（其中n为极点个数，m为零点个数）</p></li><li><p>规则7：两条根轨迹永不相交</p></li><li><p>规则8：如果至少有两条根轨迹指向无穷，则所有根的合是一个常数</p></li></ul><h2 id="从特征函数的角度理解根"><a href="#从特征函数的角度理解根" class="headerlink" title="从特征函数的角度理解根"></a>从特征函数的角度理解根</h2><div class="note info flat"><p>这里的东西会在下一章设计补偿器用到</p></div><h3 id="特征方程对OLTF提出的要求"><a href="#特征方程对OLTF提出的要求" class="headerlink" title="特征方程对OLTF提出的要求"></a>特征方程对OLTF提出的要求</h3><p>回看特征方程：</p><script type="math/tex; mode=display">1+KG(z)=0</script><p>$KG(z)$为系统OLTF，如果将其记为$F(Z)$，则有：</p><script type="math/tex; mode=display">1+F(z)=0,F(z)=-1</script><p>这就要求复数$F(z)$满足：</p><script type="math/tex; mode=display">|F(z)|=1</script><script type="math/tex; mode=display">\angle F(z)=\pm180^\circ(2k+1),k=0,1,2,...</script><h3 id="F-z-的模长和角度"><a href="#F-z-的模长和角度" class="headerlink" title="$F(z)$的模长和角度"></a>$F(z)$的模长和角度</h3><p>对于任意的$F(z)$，其可以被拆分为多个复数相乘，例如如下例子</p><script type="math/tex; mode=display">F(z)=\frac{a_3+ib_3}{(a_1+ib_1)(a_2+ib_2)}=\frac{r_3\angle\theta_3}{r_1\angle\theta_1r_2\angle\theta_2}</script><p>此时$|F(z)|$和$\angle F(z)$可以表示为：</p><script type="math/tex; mode=display">|F(z)|=\frac{r_3}{r_2r_1}</script><script type="math/tex; mode=display">\angle F(z)=\angle(\theta_3-\theta_1-\theta_2)</script><h2 id="Breakaway-和-Breakin-ponit-的计算"><a href="#Breakaway-和-Breakin-ponit-的计算" class="headerlink" title="Breakaway 和 Breakin ponit 的计算"></a>Breakaway 和 Breakin ponit 的计算</h2><p>根轨迹相离的地方叫做Breakaway Point, 重新相交的地方叫做Breakin Point。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621221733986.png" alt="image-20240621221733986" style="zoom:50%;" /></p><p>如果将OLTF$F(z)$拆分为分子分母的形式，特征方程可以写为：</p><script type="math/tex; mode=display">1+\frac{KN(z)}{D(z)}=0</script><script type="math/tex; mode=display">K=-\frac{D(z)}{N(z)}</script><p>对k求导：($上导下不导-下导上不不导/分母^2$)</p><script type="math/tex; mode=display">\frac{dK}{dz}=-\frac{D'(z)N-N'(z)D(z)}{N^2(z)}</script><p>让$-\frac{D’(z)N-N’(z)D(z)}{N^2(z)}=0$，解出来的z就是breakout 和 breakin point</p><p><em>举个例子，对于系统函数$G(z)=\frac{(z+0.5)}{(z-1)(z-0.1)}$</em></p><script type="math/tex; mode=display">K=-\frac{(z-1)(z-0.1)}{(z+0.5)}</script><script type="math/tex; mode=display">\frac{dK}{dz}=-\frac{[(z-1)+(z-0.1)](z+0.5)-(z-1)(z-0.1)}{(z+0.5)^2}=-\frac{z^2+z-0.65}{(z+0.5)^2}</script><p>令$-\frac{z^2+z-0.65}{(z+0.5)^2}=0$，即$z^2+z-0.65=0$，解出来$z_1=0.4487,z_2=-1.4487$。由于原loop gain的极点分别在1和0.1，而零点在-0.5，因此靠左的$z_2$是Break in point，$z_1$是Break out。它对应的图像就是这一小节开头的那张图。</p><h1 id="从根的角度研究采样周期T对系统的影响"><a href="#从根的角度研究采样周期T对系统的影响" class="headerlink" title="从根的角度研究采样周期T对系统的影响"></a>从根的角度研究采样周期T对系统的影响</h1><h2 id="T对系统稳定性的影响"><a href="#T对系统稳定性的影响" class="headerlink" title="T对系统稳定性的影响"></a>T对系统稳定性的影响</h2><p>考虑下图含ZOH的系统</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622111617739.png" alt="image-20240622111617739"></p><script type="math/tex; mode=display">G_{ZA}(z)=(\frac{z-1}{z})Z[\frac{G(s)}{s}]=(\frac{z-1}{z})Z[\frac{K}{s^2(s+1)}]</script><script type="math/tex; mode=display">=K(\frac{z-1}{z})Z[\frac{1}{s^2}-\frac{1}{s(s+1)}]=K\bigg(\frac{z-1}{z}\bigg)\bigg(T\frac{z}{(z-1)^2}-\frac{z(1-e^{-T})}{(z-1)(z-e^{-T})}\bigg)</script><script type="math/tex; mode=display">=K\frac{z(T-1+e^{-T})-Te^{-T}+1-e^{-T}}{(z-1)(z-e^{-T})}</script><ul><li>T=1s时，解出poles:1，0.3678；zeros：-0.7181</li><li>T=2s时，解出poles:1，0.1353；zeros：0</li><li>T=2s时，解出poles:1，0.0183；zeros：0.301</li></ul><p>分别代入三个T，使用$\frac{dK}{dz}=-\frac{D’(z)N-N’(z)D(z)}{N^2(z)}=0$解出三个T下的break in 和 Break out point。画出根轨迹，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622112551170.png" alt="image-20240622112551170"></p><p>可以看到，T=1时根轨迹出单位圆的K=2.3925；T=2时出单位圆的K=1.4557；T=4时出单位圆的K=0.9653。<strong>因此，采样周期大，系统稳定性越差。</strong></p><p>经验法则是：</p><ul><li><strong>如果闭环系统欠阻尼，则单位震荡周期内进行 8 到 10 次采样</strong>。</li><li><strong>如果闭环系统过阻尼，在阶跃响应的上升时间内采样 8 到 10 次</strong></li></ul><h2 id="T对系统瞬态响应的影响"><a href="#T对系统瞬态响应的影响" class="headerlink" title="T对系统瞬态响应的影响"></a>T对系统瞬态响应的影响</h2><p>我们在前面介绍过，在z域下，根越靠近$\pm 180^\circ$，单位阶跃响应的震荡频率越；根越靠近单位圆，瞬态响应收敛越慢。</p><p><strong>观察下图的根轨迹，对于更大的T，break in point会来得更快，走出单位圆的K也会更小，即根会越快到180度，同时收敛也更慢。体现在瞬态响应上就如下图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622114032346.png" alt="image-20240622114032346"></p><h2 id="T对系统稳态误差的影响"><a href="#T对系统稳态误差的影响" class="headerlink" title="T对系统稳态误差的影响"></a>T对系统稳态误差的影响</h2><p>考虑下图系统</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622114320047.png" alt="image-20240622114320047"></p><p>$G_{ZA}$的求法前面已经演示很多，这里不再赘述。系统特征方程为：</p><script type="math/tex; mode=display">1+K\frac{z}{z-1}\frac{(1-e^{-T})}{(z-e^{-T})}=0</script><p>考虑unit ramp input下的稳态误差$k_v$。代入前面介绍的公式：</p><script type="math/tex; mode=display">K_v=\lim_{t\to1}\frac{(1-z^{-1})GH(z)}{T}</script><ul><li>T=0.5s时，$GH(z)=\frac{0.3935Kz}{(z-1(z-0.6065))}$</li></ul><p>代入算出$K_v=4$，$e_{ss}=\frac{1}{K_v}=0.25$</p><ul><li>T=1s时，$GH(z)=\frac{0.6321Kz}{(z-1(z-0.3679))}$</li></ul><p>代入算出$K_v=2$，$e_{ss}=\frac{1}{K_v}=0.5$</p><ul><li>T=2s时，$GH(z)=\frac{0.8647Kz}{(z-1(z-0.1353))}$</li></ul><p>代入算出$K_v=1$，$e_{ss}=\frac{1}{K_v}=1$</p><p><strong>由此可见，T越大，系统的稳态误差越大</strong></p>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Control-Systems-Part2-Lectrue5-PID调谐和数字补偿器设计</title>
      <link href="/posts/8220cd2.html"/>
      <url>/posts/8220cd2.html</url>
      
        <content type="html"><![CDATA[<h1 id="PID控制器调谐"><a href="#PID控制器调谐" class="headerlink" title="PID控制器调谐"></a>PID控制器调谐</h1><h2 id="PID三个部分对系统响应的贡献"><a href="#PID三个部分对系统响应的贡献" class="headerlink" title="PID三个部分对系统响应的贡献"></a>PID三个部分对系统响应的贡献</h2><p>在Part1中详细介绍和分析过PID控制器，这里主要介绍一个调谐原则。回顾一下，PID的通式是：</p><script type="math/tex; mode=display">u(t)=K_pe(t)+K_i\int e(t)dt+K_d\frac{de(t)}{dt}</script><p>写成并联形式是：</p><script type="math/tex; mode=display">C(s)=K_p+\frac{K_i}{s}+K_ds</script><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622151311788.png" alt="image-20240622151311788"></p><p>写成标准形式是：</p><script type="math/tex; mode=display">K_p(1+\frac{1}{sT_i}+sTd)</script><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622151351644.png" alt="image-20240622151351644"></p><script type="math/tex; mode=display">C(s)=\frac{U(s)}{E(s)}=K_p+\frac{K_i}{s}+K_ds=\frac{K_ps+K_i+K_ds^2}{s}</script><p>PID控制器会给系统引入一个位于原点的极点，和2个零点。由前面介绍的零极点分析系统响应的法则，可以导出其各个部分对系统瞬态响应的贡献：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240617202208031.png" alt="image-20240617202208031"></p><p>$K_p$的贡献是：</p><ul><li>减少rise time $t_r$</li><li>但是无法消除稳态误差</li></ul><p><strong>决定响应速度和力度，过小响应慢，过大会产生振荡，是I和D的基础。</strong></p><p>$K_i$的贡献是：</p><ul><li>消除稳态误差</li><li>但是会削减瞬态响应</li><li>会削减系统稳定性</li></ul><p><strong>在有系统误差和外力作用时消除偏差、提高精度，同时也会增加响应速度，产生过冲，过大会产生振荡。</strong></p><p>$K_d$的贡献是：</p><ul><li>增加稳定性（包含减少过冲 overshoot $M_p$ 和 改善瞬态响应）</li><li>但是会导致系统对高频噪声更敏感</li></ul><p><strong>抑制过冲和振荡，过小系统会过冲，过大会减慢响应速度。另外一个作用是抵抗外界的突发干扰，阻止系统的突变</strong></p><p>总结为下表：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622151052112.png" alt="image-20240622151052112"></p><h2 id="PID调谐"><a href="#PID调谐" class="headerlink" title="PID调谐"></a>PID调谐</h2><h3 id="广泛流传的经验法整定"><a href="#广泛流传的经验法整定" class="headerlink" title="广泛流传的经验法整定"></a>广泛流传的经验法整定</h3><p>所谓PID调谐，就是在系统的过冲、上升时间、下降时间、稳态误差之间取一个可以接受的平衡。</p><p>有一些广泛流传的PID调谐的口诀，例如《化工自动化》一书中的参数整定口诀：</p><p>参数整定寻最佳，从大到小顺次查。先是比例后积分，最后再把微分加。曲线振荡很频繁，比例度盘要放大。曲线漂浮绕大弯，比例度盘往小扳。曲线偏离回复慢，积分时间往下降。曲线波动周期长，积分时间再加长。 理想曲线两个波，调节过程高质量。</p><h3 id="齐格勒－尼科尔斯方法（Ziegler-Nichols-method）"><a href="#齐格勒－尼科尔斯方法（Ziegler-Nichols-method）" class="headerlink" title="齐格勒－尼科尔斯方法（Ziegler-Nichols method）"></a>齐格勒－尼科尔斯方法（Ziegler-Nichols method）</h3><p>齐格勒－尼科尔斯方法的调试方式为：</p><ol><li>首先将积分和微分增益设置为0，然后比例增益从零开始逐渐增加，直到到系统临界稳定条件（marginal stability）,此时控制器输出值以恒定值振荡。拿到临界震荡的下critical gain $K_c$和critical frequency $\omega_c$，$T_c=\frac{2\pi}{\omega_c}$</li><li>根据不同系统的要求，遵照下表找一个合适的经验值</li></ol><div class="table-container"><table><thead><tr><th>控制类型</th><th>$K_p$</th><th>$K_i$</th><th>$K_d$</th></tr></thead><tbody><tr><td>P</td><td>$0.5K_c$</td><td>-</td><td>-</td></tr><tr><td>PI</td><td>$0.45K_c$</td><td>$0.54K_c/T_c$</td><td></td></tr><tr><td>PD</td><td>$0.8K_c$</td><td>-</td><td>$0.1K_cT_c$</td></tr><tr><td>经典PID</td><td>$0.6K_c$</td><td>$1.2K_c/T_c$</td><td>$0.075K_cT_c$</td></tr><tr><td>Pessen Integral Rule</td><td>$0.7K_c$</td><td>$1.75K_c/T_c$</td><td>$0.105K_cT_c$</td></tr><tr><td>部分过冲</td><td>$0.2K_c$</td><td>$0.4K_c/T_c$</td><td>$0.066K_cT_c$</td></tr></tbody></table></div><p>这个表上面的值都是经验值，不同地方可能不一样。上表是简中互联网广泛流传的表。</p><p><strong>Dr.Huda PPT上的法则是这样</strong>：（注：$T_i=\frac{K_p}{K_i}$，$T_d=\frac{K_d}{K_p}$）</p><div class="table-container"><table><thead><tr><th>控制类型</th><th>$K_p$</th><th>$T_i$</th><th>$T_d$</th></tr></thead><tbody><tr><td>P</td><td>$0.5K_c$</td><td>-</td><td>-</td></tr><tr><td>PI</td><td>$0.4K_c$</td><td>$0.8T_c$</td><td>-</td></tr><tr><td>PID</td><td>$0.6K_c$</td><td>$0.5T_c$</td><td>$0.125T_c$</td></tr></tbody></table></div><div class="note info flat"><p><del>实操PID只需要套公式就行了，但是考试要考虑的事情就很多了</del></p><p>实际操作时调PID依照积分、微分、比例三个部分对系统瞬态响应的影响来调即可，不一定会完全遵照这些经验表格。</p></div><h1 id="模拟补偿器数字化"><a href="#模拟补偿器数字化" class="headerlink" title="模拟补偿器数字化"></a>模拟补偿器数字化</h1><p>模拟补偿器数字化法设计可以概括为如下三步：</p><ol><li>按照系统要求设计模拟补偿器</li><li>通过下面介绍的映射规则将它数字化</li><li>代入数字控制系统的采样周期，检查系统响应是否满足要求。如果不满足，重复步骤1和2。</li></ol><h2 id="模拟系统离散化的映射方法："><a href="#模拟系统离散化的映射方法：" class="headerlink" title="模拟系统离散化的映射方法："></a>模拟系统离散化的映射方法：</h2><ul><li>前向欧拉法（Euler’s forward method）：$s\approx\frac{z-1}{T}$</li><li>后向欧拉法（Euler’s backward method）：$s\approx\frac{z-1}{Tz}$</li><li>双线性法/塔斯汀法(Tustin’s method/bilinear transformation)：$s\approx\frac{2}{T}\frac{z-1}{z+1}$</li><li>零阶保持器（Zero-Order hold）:$C(z)=(\frac{z-1}{z})Z[\frac{C(s)}{s}]$</li></ul><h3 id="举个例子：Tustin’s-method离散化Ziegler-Nichols-method调谐的PI控制器"><a href="#举个例子：Tustin’s-method离散化Ziegler-Nichols-method调谐的PI控制器" class="headerlink" title="举个例子：Tustin’s method离散化Ziegler-Nichols method调谐的PI控制器"></a>举个例子：Tustin’s method离散化Ziegler-Nichols method调谐的PI控制器</h3><p><em>已知：系统的传输函数和框图为，其$K_c=201,\omega_c=14.2$：</em></p><script type="math/tex; mode=display">G(s)=\frac{30}{s(s^2+30s+200)}</script><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622161042296.png" alt="image-20240622161042296"></p><p><em>要求：使用Ziegler-Nichols method设计PI控制器，采样间隔为0.1s,并使用(i)Tustin method (ii)ZOH将其数字化</em></p><p><strong>step1：使用Ziegler-Nichols method为系统调谐PI控制器</strong></p><script type="math/tex; mode=display">K_p=0.4K_c=80.4,T_i=0.8\times\frac{2\pi}{\omega_c}=0.35398</script><script type="math/tex; mode=display">\frac{K_p}{K_i}=T_i\to K_i=\frac{K_p}{T_i}=227.25</script><p>因此：</p><script type="math/tex; mode=display">C(s)=80.4+\frac{227.25}{s}</script><p><strong>step2-(i)：使用Tustin method 将系统离散化</strong></p><p>将$s\approx\frac{2}{T}\frac{z-1}{z+1}$代入$C(s)$</p><script type="math/tex; mode=display">C(z)=K_p+K_i\times\frac{T}{2}\frac{z+1}{z-1}=\frac{zK_pz-2K_p+K_iTz+K_iT}{2(z-1)}</script><p>代入$T=0.1$</p><script type="math/tex; mode=display">C(s)=\frac{91.76z-69.04}{(z-1)}</script><p><strong>step2-(ii)：使用ZOH将系统离散化</strong></p><script type="math/tex; mode=display">C(z)=\frac{z-1}{z}Z[\frac{C(s)}{s}]=(\frac{z-1}{z})Z[\frac{80.4}{s}+\frac{227.25}{s^2}]</script><script type="math/tex; mode=display">=(\frac{z-1}{z})(80.4\frac{z}{z-1}+227.25T\frac{z}{(z-1)^2})</script><script type="math/tex; mode=display">=\frac{80.4(z-1)+227.254T}{z-1}</script><p>代入$T=0.1$</p><script type="math/tex; mode=display">C(z)=\frac{80.4z-57.68}{z-1}</script><h1 id="根轨迹设计法"><a href="#根轨迹设计法" class="headerlink" title="根轨迹设计法"></a>根轨迹设计法</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>$F(z)$的模长和角度可以表示为多个复数贡献的形式，例如下面这个：</p><script type="math/tex; mode=display">F(z)=\frac{a_3+ib_3}{(a_1+ib_1)(a_2+ib_2)}=\frac{r_3\angle\theta_3}{r_1\angle\theta_1r_2\angle\theta_2}</script><script type="math/tex; mode=display">|F(z)|=\frac{r_3}{r_2r_1}</script><script type="math/tex; mode=display">\angle F(z)=\angle(\theta_3-\theta_1-\theta_2)</script><p>假设现在有一个系统函数，它在$F(z)=(z+3)$。那么当$z=2+2j$时，系统函数的向量值为$(5+2j)$。</p><p>这里有一个很巧的事情：$(z+3)$的零点是$z=-3$。当$z=2+2j$时，系统函数的向量$(5+2j)$就等于从它贡献的零点连到$z+zj$的向量，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622182445261.png" alt="image-20240622182445261"></p><p>假设一个系统函数有好几个零极点，例如$F(s)=\frac{s+2}{s(s+1)}$，那么当s为某一个特定值时，系统函数内每一个复数分量就可以表示为他们贡献到零极点到这个特定s的连线，叠加在一起就是系统函数的值。例如当$s=-1+\sqrt{3}j$时</p><p>系统有零点s=-2，有极点s=0，-1。从-2，-1，0连接三条线到s，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622183316326.png" alt="image-20240622183316326"></p><p>可以分别求得其长度为$l_1=2,l_2=\sqrt{3},l_3=2$；其角度为$\theta_1=\frac{\pi}{3},\theta_1=\frac{\pi}{2},\theta_1=\frac{2\pi}{3}$</p><p>按照上面介绍的系统函数内各个复数叠加的理论，可以求得这个系统函数$|F(s)|=\frac{2}{2\times\sqrt{3}}=\frac{\sqrt{3}}{3}$，$\angle F(s)=\theta_3-\theta_2-\theta_1=-\frac{5}{6}\pi$</p><p>在前一章节<em>从特征函数的角度理解根</em>小节中提到过，如果要使得某种情况（z或者s等于某个定值时）的特征函数成立，其CLTF$F(z)$必须满足：</p><ul><li>$|F(z)|=1$</li><li>$\angle F(z)=\pm180^\circ(2k+1),k=0,1,2..$</li></ul><p>那么，理论上来说，我们可以给系统安插一个通式如下的补偿器，来使得$s$或$z$为某个人为指定的定值时，特征方程成立，即，满足上面的条件。此时系统的特征方程有一个根就会出现在这个人为指定的位置。</p><script type="math/tex; mode=display">G_D(z)=K\frac{z+\alpha}{z+\beta}=\frac{Kr_n\angle\theta_n}{r_d\angle\theta_d}</script><p>由于系统的特征方程根位置和系统当前的响应有直接关系，因此可以通过将对系统响应的需求转化为对根出现在某个点的需求。然后根据需求按照上面的法则设计补偿器。这就是根轨迹补设计法。</p><p>常用的转化公式为：（其中$\omega_d$为受阻震荡频率，$\omega_s$为采样频率，$\omega_n$为自然频率，$\zeta$为阻尼率）</p><script type="math/tex; mode=display">|z|=e^{T\sigma}=e^{-T\zeta\omega_n}=exp(-\frac{2\pi\zeta}{\sqrt{1-\zeta^2}}\frac{\omega_d}{\omega_s})</script><script type="math/tex; mode=display">\angle z=T\omega_d=\frac{2\pi\omega_d}{\omega_s}(rad/s)</script><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>现有如下系统，要求其阻尼比$\zeta=0.5$，setting time $t_s=2s$</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622172012219.png" alt="image-20240622172012219"></p><p><strong>Step1：将响应需求转化为根需求</strong></p><script type="math/tex; mode=display">t_s=\frac{4}{\zeta\omega_n}=2=\frac{4}{0.5\omega_n}\to\omega_n=4</script><script type="math/tex; mode=display">\omega_d=\omega_n\sqrt{1-\zeta^2}=3.464</script><p>假设采样周期$T=0.2$验证一下它符不符合采样的经验法则（在笔记ch4内介绍）：</p><script type="math/tex; mode=display">\omega_s=\frac{2\pi}{T}=31.42,\frac{\omega_s}{\omega_d}=9.07>8</script><p>因此符合经验法则的要求。套用前面的转化公式：</p><script type="math/tex; mode=display">|z|=exp(-\frac{2\pi\times0.5}{\sqrt{1-0.5^2}}\frac{3.464}{31.42})=0.6703</script><script type="math/tex; mode=display">\angle z=T\omega_d=0.2\times3.464=0.6928rad/s=36.69451605^\circ</script><p>这就是我们补偿后的人为确定的z，我们希望当z等于这个值时，特征方程成立。将其写为复数形式：</p><script type="math/tex; mode=display">Real=0.6703\times cos(36.69451605)=0.5158;Img=0.6703\times cos(36.69)=0.4281</script><script type="math/tex; mode=display">P=0.5158+j0.4281</script><p><strong>step2：将ZOH和模拟系统构成的新传输函数解出</strong></p><p>这里直接套用前面介绍的ZOH输入模拟系统的转化公式：</p><script type="math/tex; mode=display">G_{ZA}(z)=\frac{z-1}{z}Z[\frac{G(s)}{s}]=\frac{z-1}{z}Z[\frac{1}{s^2(s+2)}]=\frac{z-1}{z}Z[\frac{1}{2}(\frac{1}{s^2}-\frac{1}{s(s+2)})]</script><script type="math/tex; mode=display">=\frac{1}{2}\frac{z-1}{z}(T\frac{z}{(z-1)^2}-\frac{z(1-e^{-2T})}{2(z-1)(z-e^{-2T})})</script><p>代入$T=0.2$</p><script type="math/tex; mode=display">G_{ZA}(z)=\frac{0.01758(z+0.8760)}{(z-1)(z-0.6703)}</script><p><strong>Step3：计算系统现有零极点的角度贡献</strong></p><p>那么这个系统现在有：</p><ul><li>zeros：-0.8760</li><li>poles：1，0.6703</li></ul><p>我们希望系统达到这个状态：（$P=0.5158+j0.4281$）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240622175921165.png" alt="image-20240622175921165" style="zoom:50%;" /></p><p>先计算系统自带的零极点的角度贡献：</p><p>z=1的极点贡献了：（这里变成正数是因为它转过180度了，由复数角度的定义得来的。详见复变函数）</p><script type="math/tex; mode=display">arctan(\frac{0.4281-0}{0.5158-1})=-41.48^\circ=138.52^\circ</script><p>z=0.6703的极点贡献了：</p><script type="math/tex; mode=display">arctan(\frac{0.4281-0}{0.5158-0.6703})=-70.16^\circ=109.84^\circ</script><p>z=-0.8760的零点贡献了：</p><script type="math/tex; mode=display">arctan(\frac{0.4281-0}{0.5158-(-0.8760)})=17.10^\circ</script><p><strong>Step4：计算系统还需要的角度(补偿器提供的)</strong></p><p>要使得特征方程的根出现在我们想要的这个地方，需要让当z=P时，特征方程成立。也就是说OLTF的角度要满足$\angle F(z)=\pm180^\circ(2k+1),k=0,1,2..$，也就是系统自带的这些角度贡献+补偿器的角度贡献要满足$\pm180$度</p><p>补偿器通式为$K\frac{z+\alpha}{z+\beta}$，会引入一个极点和一个零点。为了简化计算，我们让它的零点贡献和系统自带的一个极点贡献抵消掉。这里取$z+\alpha=(z-0.6703)$来抵消，即$\alpha=0.6703$（$-70.16^\circ$极点贡献被抵消了）</p><script type="math/tex; mode=display">C(z)G(z)=\frac{(z-0.6703)}{z+\beta}\frac{0.01758(z+0.8760)}{(z-1)(z-0.6703)}</script><p>现在我们只需要计算$C(z)$中的这个极点，让系统角度满足即可</p><script type="math/tex; mode=display">\angle C(z)G(z)=(z=-0.8760的零点贡献)-(z=1的极点贡献)-(补偿器极点贡献)=\pm180^\circ</script><script type="math/tex; mode=display">=17.10^\circ-138.52^\circ-(补偿器极点)=\pm180^\circ</script><p>如果取$-180$，那么补偿器极点就需要贡献$-180+138.52+17.10=58.58^\circ$</p><script type="math/tex; mode=display">tan(58.58)=\frac{0.4281}{0.5158-\beta}</script><script type="math/tex; mode=display">\beta=0.2543</script><p>至此我们得到了补偿器的$\alpha$和$\beta$参数：</p><script type="math/tex; mode=display">C(z)=K\frac{z-0.6703}{z-0.2543}</script><p><strong>Step3：计算系统现有零极点的模长贡献</strong></p><script type="math/tex; mode=display">C(z)G_{ZA}(z)=K\frac{z-0.6703}{z-0.2543}\frac{0.01758(z+0.8760)}{(z-1)(z-0.6703)}=K\frac{0.01758(z+0.8760)}{(z-0.2543)(z-1)}</script><p>系统现有的模长贡献有：（目标点：$P=0.5158+j0.4281$）</p><ul><li><p>分子(z+0.8760)贡献了：$\sqrt{(0.5158-(-0.8760))^2+(-0.4281)^2}=\sqrt{(1.3918)^2+(0.4281)^2}$</p></li><li><p>分母(z-0.2543)贡献了：$\sqrt{(0.5158-0.2543)^2+(-0.4281)^2}=\sqrt{(0.2615)^2+(0.4281)^2}$</p></li><li>分母(z-1)贡献了：$\sqrt{(0.5158-1)^2+(-0.4281)^2}=\sqrt{(0.4842)^2+(0.4281)^2}$</li></ul><p>$|F(z)|=1$，即：</p><script type="math/tex; mode=display">0.01758K\times\frac{\sqrt{(1.3918)^2+(0.4281)^2}}{\sqrt{(0.2615)^2+(0.4281)^2}\times\sqrt{(0.4842)^2+(0.4281)^2}}=1</script><script type="math/tex; mode=display">0.01758K\times4.491218756=1</script><script type="math/tex; mode=display">K=\frac{1}{0.01758\times4.491218756}=12.67</script><p>至此，我们得到了补偿器的表达式：</p><script type="math/tex; mode=display">C(z)=12.67\frac{z-0.6703}{z-0.2543}</script>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Control-Systems-Part2-Lectrue1~3-数字控制系统基础</title>
      <link href="/posts/eb15a674.html"/>
      <url>/posts/eb15a674.html</url>
      
        <content type="html"><![CDATA[<h1 id="数字控制系统简介"><a href="#数字控制系统简介" class="headerlink" title="数字控制系统简介"></a>数字控制系统简介</h1><p>数字控制系统的核心是使用MCU、电脑之类的控制器通过软件的形式对数据进行处理。而不是模拟信号那样通过模拟器件来构成积分器微分器等等。</p><p>数字控制系统具有如下优点：</p><ul><li>对噪声的鲁棒性好：数字信号可以无损传输，只要不超过门限值，数字信号读取出来都是无损的。</li><li>灵活性高：数字控制系统主要通过软件编程来实现对数据的处理，这样的系统灵活性高，重新刷写程序即可设计新的系统</li><li>成本：数字系统的可靠性在升高而成本在下降</li><li>易用性：大规模集成电路可以更轻易地集成数字IC，这对数字信号处理更加友好</li></ul><h1 id="数字控制系统的基础-ADC和DAC"><a href="#数字控制系统的基础-ADC和DAC" class="headerlink" title="数字控制系统的基础-ADC和DAC"></a>数字控制系统的基础-ADC和DAC</h1><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620225053422.png" alt="image-20240620225053422" style="zoom:80%;" /></p><p>一个基本的数字系统如上图所示，其模拟输出的数字信号必须经过DAC转化为模拟信号交给模拟系统去执行，而反馈回来的模拟信号又必须通过ADC转化为数字信号以作为参考计算值。</p><h2 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h2><p>有两种常用的DAC电路：</p><ul><li>R-2R 梯子（R-2R ladder）网络。</li><li>加权电阻器</li></ul><h3 id="R-2R-ladder"><a href="#R-2R-ladder" class="headerlink" title="R-2R ladder"></a>R-2R ladder</h3><p>下图是一个3bits R-2R DAC的电路图。$b_1$是LSB，$b_2$是MSB。让我们分析一下这个电路。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620234426288.png" alt="image-20240620234426288" style="zoom:50%;" /></p><p><strong>（1）上图这样$b_2$接通的状态，</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620234916817.png" alt="image-20240620234916817" style="zoom: 50%;" /></p><ol><li>将电阻器件编为3组。如上图1，2，3三个环。</li><li>从最左侧第一组（环1）看起，水平的$2R$左侧接地，垂直的$2R$下面接地，因此以连接这两个$2R$的节点的视角来看，相当于两个等值对地并联电阻，因此在对节点来说它的等效电阻是$R$</li><li>现在看到中间这个环2，它的水平方向有个$R$连接到（2）中的节点，然后再经过（2）中等效的$R$地，因此其水平方向对地阻值是$2R$。其竖直方向又是$2R$接地，因此站在它的节点的视角来看，它也是2个$2R$并联接地，可以等效为$R$。</li><li>此时来到最后一组，水平方向的$R$和（3）中等效出来的$R$串联，阻值是$2R$。至此，电路等效成了这样：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620235520619.png" alt="image-20240620235520619" style="zoom:67%;" /></p><ol><li>上图中A点因为虚短电压为0V，因此水平方向的左右两个$2R$又可以等效为$R$。</li><li>那么总电流就是$i_2=\frac{V_{ref}}{3R}$。同时水平方向的两个电阻均匀分流，因此流经运算放大器的电流是$\frac{1}{2}i_2=\frac{V_{ref}}{6R}$</li><li>运算放大器的放大电阻为$3R$，因此输出电压$V_0=3R\times\frac{V_{ref}}{6R}=\frac{1}{2}V_{ref}$</li></ol><p>回顾一下将DAC的映射规则：MSB贡献最大值的一半，剩下的bit是距离MSB有n位就贡献$(\frac{1}{2})^{n+1}V_{ref}$。例如$010$就是$1/4\times V_{ref}$。$111$就是$\frac{1}{8}V_{ref}+\frac{1}{4}V_{ref}+\frac{1}{2}V_{ref}$</p><p>现在是MSB为$V_{ref}$，其他bit接地的情况。即$100_{B}$的情况，$V_0$应当等于$\frac{1}{2}V_{ref}$，分析出来的电压和DAC的映射规则符合。</p><p>（2）让我们来试想一下LSB（$b_0$）接通，其他接地的状态。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620234916817.png" alt="image-20240620234916817" style="zoom: 50%;" /></p><ol><li>从环3开始看起，环3节点右侧水平的$2R$和竖直的$2R$都位于接地的状态，因此等效为$R$</li><li>环$2$右侧水平的$R$和环3等效的$R$串联构成$2R$，并与竖直接地的$2R$等效成$R$</li><li>至此从环1节点的视角来看，左侧为$2R$接地，右侧为$2R$接地，竖直为$2R$接$-V_{ref}$，这个情况和MSB为1时的第五步一模一样。因此流过环3竖直$2R$的电流也为$i_2=\frac{V_{ref}}{3R}$，水平方向左右两侧分别分流$\frac{V_{ref}}{6R}$。</li><li>此时右侧的电流是流过运算放大器的，但是并非全部电流都经过运放的$3R$。当它经过环2时，站在环2的节点视角来看，水平为$2R$接地，竖直为$2R$接地，因此经过环2会被再次分走一半，只剩$\frac{V_{ref}}{12R}$。经过环1同理。如下图所示</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621002046973.png" alt="image-20240621002046973" style="zoom:67%;" /></p><ol><li>最终流向放大电阻$3R$的电流为$\frac{V_{ref}}{24R}$，因此$v_0=3R \frac{V_{ref}}{24R}=\frac{1}{8}V_{ref}$</li><li>总结一下我们发现，每经过1一个环，它的电流就变成了MSB电流的$1/2$，而距离MSB有n位就需要经过n个环，这恰好与DAC规则里面的<em>“MSB贡献最大值的一半，剩下的bit是距离MSB有n位就贡献$(\frac{1}{2})^{n+1}V_{ref}$”</em>对应上了。这就是这类DAC工作的原理</li></ol><p>利用电流可叠加的特性，对每个bit接1的情况单独分析，即可发现$V_0$的输出是每个bit接地贡献电流的总和。至此这个DAC推导完毕。总结其通式为：</p><script type="math/tex; mode=display">V_0=\frac{1}{2}(b_{n-1}+\frac{1}{2}b_{n-2}+...+\frac{1}{2^{n-1}}b_0)V_{ref}</script><h3 id="weighted-resistors"><a href="#weighted-resistors" class="headerlink" title="weighted resistors"></a>weighted resistors</h3><p>下图是weighted resistor DAC的电路图。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621002624126.png" alt="image-20240621002624126" style="zoom:67%;" /></p><p>这类DAC的本质就是电子系统里面学过的反相加法器，通过不同的放大配置电阻来实现每个bit占不同的权重。这里省略推导。通式同上。</p><h2 id="ADC-逐次逼近型ADC"><a href="#ADC-逐次逼近型ADC" class="headerlink" title="ADC-逐次逼近型ADC"></a>ADC-逐次逼近型ADC</h2><p>这类ADC其实在计算机组成与接口一课中学过。这里简单回顾一下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621003606628.png" alt="image-20240621003606628"></p><p>这类ADC由一个比较器，一个DAC，一个逼近寄存器（successive approximation register, SAR）,一个时钟信号，一个产生控制信号的控制器（SOC：Start of Converting; EOC: End of Converting）构成。</p><ol><li>一开始，SAR输出的值为0，DAC将其转换为模拟信号的0输出到$V_0$</li><li>比较器比较$V_{IN}$大还是$V_{0}$大，如果$V_{IN}$大，则将MSB置位1；再次比较</li><li>如果这次是$V_{0}$大，则将MSB回溯为0，MSB的后一位置为1；比较下一位</li><li>如果还是$V_{IN}$大，则将MSB的后一位置为1；比较下一位</li><li>重复这个过程，直到完成对最后一位的填写。</li></ol><p>整个过程其实是一个二分法，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621004812096.png" alt="image-20240621004812096"></p><p>这种ADC的采样时间通常在$10ns-200us$不等，并且要求$V_{IN}$在采样期间保持稳定。高性能的ADC系统包括一个S/H（采样保持）器件，该器件在转换期间保持ADC的输入恒定。</p><h2 id="数字采样的混叠（Aliasing）问题"><a href="#数字采样的混叠（Aliasing）问题" class="headerlink" title="数字采样的混叠（Aliasing）问题"></a>数字采样的混叠（Aliasing）问题</h2><p>当ADC以一个较低的频率去对模拟信号采样时，可能会出现下图这样的问题，导致采得的频率远小于信号实际的频率，这被称为Aliasing。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621005235928.png" alt="image-20240621005235928"></p><p>由于一个信号内会有不同的频率分量，因此有可能会有超出系统设计的高频频率分量因为Aliasing问题，在ADC采样后变成低频分量。为了解决这个问题，需要使用低通滤波器来滤除这些高频分量。在实际应用中这些被称为抗混叠滤波器（anti-alias filters）</p><p>当采样频率为最高频率2倍时（采样定理），原始信号才能完全被采样信号表达（无混叠问题）。</p><h1 id="S域和Z域及其稳定性"><a href="#S域和Z域及其稳定性" class="headerlink" title="S域和Z域及其稳定性"></a>S域和Z域及其稳定性</h1><h2 id="S到Z的映射"><a href="#S到Z的映射" class="headerlink" title="S到Z的映射"></a>S到Z的映射</h2><h3 id="s-plane-到-z-plane-的映射"><a href="#s-plane-到-z-plane-的映射" class="headerlink" title="s plane 到 z plane 的映射"></a>s plane 到 z plane 的映射</h3><p>在信号与系统中学过，S域用于衡量连续系统，Z域用于衡量离散系统。其中S域到Z域的推导就是令$z=e^{Ts}$，其中$s=j\omega+\sigma$。分离一下这个z:</p><script type="math/tex; mode=display">z=e^{Ts}=e^{T(j\omega+\sigma)}=e^{T\sigma}e^{jT\omega}</script><p>此时，这个复数z的幅值完全由$e^{T\sigma}$贡献，角度完全由$e^{jT\omega}$贡献。因此可以记为$z=r\angle\theta$，其中$r=e^{T\sigma}$，$\theta=\omega T$</p><p>回想s平面，其横轴为$\sigma$，纵轴为$\omega$。现在到了z平面，原本的横轴映射为了幅值；原本的纵轴映射成了角度。原本位于横轴n处的一条垂直的线（即，$\sigma=n,\omega不限$）现在变成了幅值为n的一个圆（即，$r=e^{Tn},\theta=\omega T=不限$）。</p><p>因此s平面到z平面的映射，就是把它s平面上的竖线卷成一个圆；其中s平面左侧的因为$\sigma&lt;0$，因此：</p><ul><li>$r=e^{\sigma T}&lt;1$，在单位圆内。</li><li>位于虚轴上的$\sigma=0$，对应$r=1$，位于单位圆上。</li><li>位于右半平面的$\sigma&gt;0$，映射到的就是$r&gt;1$的单位圆外。</li></ul><p>如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621011224553.png" alt="image-20240621011224553" style="zoom: 67%;" /></p><p>这样卷起来之后，原本在s平面水平的横线就被卷成了指向某一个方向的向量，如下图所示。从数学的角度也很好解释：某一条水平横线的表达式为$s=j\omega$，$\sigma$不限。映射到z就是$\theta=\omega T$，$r=e^{\sigma T}$不限。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621011418650.png" alt="image-20240621011418650" style="zoom:67%;" /></p><h3 id="终值定理和稳态误差转换"><a href="#终值定理和稳态误差转换" class="headerlink" title="终值定理和稳态误差转换"></a>终值定理和稳态误差转换</h3><p>在Part1介绍的拉普拉斯变换中介绍了unit step, unit ramp, 和 acceleration input的steady state error。这里将它们映射到Z域（其实用映射不是很准确，除了终值定理遵循映射关系，它的公式其实是由z系统下表示的系统函数推导出来的）</p><p><strong>单位阶跃响应</strong></p><ul><li>在s域下：$K_p=\lim_{s\rightarrow0}{G(s)H(s)}$，稳态误差：$e_{ss}=\frac{1}{1+K_p}$</li><li>在z域下：$K_p=\lim_{z\rightarrow1}{GH(z)}$，稳态误差：$e_{ss}=\frac{1}{1+K_p}$</li></ul><p>type0系统稳态误差存在，1阶及以上不存在。注意这里的type还是由分母孤立的s来定义，并非z。</p><p><strong>单位斜坡响应</strong></p><ul><li>在s域下：$K_V=\lim_{s\rightarrow0}{sG(s)H(s)}$，稳态误差：$e_{ss}=\frac{1}{K_V}$</li><li>在z域下：$K_V=\lim_{z\rightarrow1}{\frac{(1-z^{-1})GH(z)}{T}}$，稳态误差：$e_{ss}=\frac{1}{K_V}$</li></ul><p>type0系统稳态误差为无穷，type1为$\frac{1}{K_V}$，type2及以上无稳态误差</p><p><strong>单位加速度响应</strong></p><ul><li>在s域下：$K_a=\lim_{s\rightarrow0}{s^2G(s)H(s)}$，稳态误差：$e_{ss}=\frac{1}{K_a}$</li><li>在z域下：$K_a=\lim_{z\rightarrow1}{\frac{(1-z^{-1})^2GH(z)}{T^2}}$，稳态误差：$e_{ss}=\frac{1}{K_a}$</li></ul><p>type0,1稳态误差为无穷，type2为$\frac{1}{K_a}$</p><h2 id="s域的极点和时域响应的关系"><a href="#s域的极点和时域响应的关系" class="headerlink" title="s域的极点和时域响应的关系"></a>s域的极点和时域响应的关系</h2><h3 id="实数根和收敛速度的关系"><a href="#实数根和收敛速度的关系" class="headerlink" title="实数根和收敛速度的关系"></a>实数根和收敛速度的关系</h3><p>考虑一个系统：$G(s)=\frac{1}{s+a}$，这个系统的极点为$s=-a$，对单位冲击函数$\delta(t)$的响应就是传递函数本身，即$U(s)=\frac{1}{s+a}$，那么有：</p><script type="math/tex; mode=display">u(t)=e^{-at}</script><p>如果a为正数，即极点在左边平面，这个响应呈现随时间衰减趋势，且a越大衰减越快；如果a为负数，即极点在右半平面，这个响应呈现随时间增加趋势，且a越小递增越快。</p><p><strong>对应极点，就是极点越靠近负无穷，衰减越快，极点越靠近正无穷，增加越快，极点在0附近这个函数更趋于平缓</strong></p><h3 id="主导极点"><a href="#主导极点" class="headerlink" title="主导极点"></a>主导极点</h3><p>考虑一个二阶系统$G(s)=\frac{1}{s^2+2\zeta\omega_ns+\omega_n^2}$，对其施加单位冲击响应，输出为系统函数本身。系统函数的极点可令分母等于0后使用求根公式获得：</p><script type="math/tex; mode=display">P=-\zeta\omega_n\pm\omega_n\sqrt{\zeta^2-1}</script><p><strong>当$\zeta&gt;1$时：</strong></p><p>$\sqrt{\zeta^2-1}&gt;0$，$P_1,P_2$都为实数。输出可以写成：</p><script type="math/tex; mode=display">U(s)=\frac{1}{(s-P_1)(s-P_1)}=\frac{A}{s-P_1}+\frac{B}{s-P_2}</script><script type="math/tex; mode=display">u(t)=Ae^{P_1t}+Be^{P_2t}</script><p>假设两个极点都在右半平面。由于$P_1=-\zeta\omega_n+\omega_n\sqrt{\zeta^2-1}&gt;P_2=-\zeta\omega_n-\omega_n\sqrt{\zeta^2-1}$，遵照上面将的离负无穷越近收敛越快，$P_1$这收敛较慢，$P_2$收敛较快。系统由这两部分叠加，收敛较慢的信号决定了系统的收敛速度，因此称$P_1$为主导极点。（此时也对应了严阻尼，无过冲收敛的情况）</p><h3 id="虚部根于震荡频率的关系"><a href="#虚部根于震荡频率的关系" class="headerlink" title="虚部根于震荡频率的关系"></a>虚部根于震荡频率的关系</h3><p>继续考虑前面的二阶系统，<strong>当$\zeta$=0时</strong></p><script type="math/tex; mode=display">P_1=-\zeta\omega_n+\omega_n\sqrt{\zeta^2-1}=\omega_n\sqrt{-1}=j\omega_n</script><script type="math/tex; mode=display">P_2=-\zeta\omega_n-\omega_n\sqrt{\zeta^2-1}=-\omega_n\sqrt{-1}=-j\omega_n</script><p>此时这两个根完全在虚轴上，无实部分量。系统输出为：</p><script type="math/tex; mode=display">U(s)=\frac{1}{(s-j\omega_n)(s+j\omega_n)}=\frac{1}{s^2+\omega_n^2}</script><script type="math/tex; mode=display">u(t)=\frac{1}{\omega_n}sin(\omega_nt)</script><p><strong>可以看到，此时系统输出以$\omega_n$的频率进行震荡，且$|\omega_n|$越大震荡的频率越快。因此，极点在虚轴上距离零点越远，震荡频率越快</strong>（此时也对应了无阻尼，自由震荡的情况）</p><h3 id="结合实部和虚部的关系"><a href="#结合实部和虚部的关系" class="headerlink" title="结合实部和虚部的关系"></a>结合实部和虚部的关系</h3><p>继续考虑前面的二阶系统，<strong>当0&lt;$\zeta$&lt;1时</strong></p><script type="math/tex; mode=display">P_1=-\zeta\omega_n+\omega_n\sqrt{\zeta^2-1}=-\zeta\omega _n+j\omega_n\sqrt{1-\zeta^2}</script><script type="math/tex; mode=display">P_2=P=-\zeta\omega_n-\omega_n\sqrt{\zeta^2-1}=-\zeta\omega _n-j\omega_n\sqrt{1-\zeta^2}</script><p>定义$\omega_d=\omega_n\sqrt{1-\zeta^2}$，称为固有频率，此时:</p><script type="math/tex; mode=display">U(s)=\frac{1}{(s+\zeta\omega _n+j\omega_d)(s+\zeta\omega _n-j\omega_d)}=\frac{1}{(s+\zeta\omega_n)^2+\omega_d^2}</script><script type="math/tex; mode=display">\frac{1}{\omega_d}\frac{\omega_d}{(s+\zeta\omega_n)^2+\omega_d^2}</script><script type="math/tex; mode=display">u(t)=\frac{1}{\omega_d}e^{-\zeta\omega_nt}sin(\omega_dt)</script><p>其图像是包络为$e^{-\zeta\omega_nt}$，以$\omega_d$为频率震荡收敛的函数。因此根的虚部大小（$\omega_d$）决定了其震荡频率，实部大小（$-\zeta\omega_n$）决定了其收敛速度。（对应欠阻尼情况）。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621021125728.png" alt="image-20240621021125728"></p><h3 id="总结和映射至Z平面"><a href="#总结和映射至Z平面" class="headerlink" title="总结和映射至Z平面"></a>总结和映射至Z平面</h3><p>总结一下，在s域内：</p><ul><li>极点虚部绝对值越大信号的震荡频率越快</li><li>极点实部在左半平面，信号收敛；越靠近负无穷收敛越快</li><li>极点实部在右半平面，信号发散；约靠近正无穷发散越快</li><li>极点无实部只有虚部时，为临界稳定状态，保持固有频率震荡</li></ul><p>考虑s平面和z平面的映射关系，在z域内：</p><ul><li>极点相位角越大震荡频率越快</li><li>极点模长小于1时，信号收敛；越靠近0收敛越快</li><li>极点模长大于1时，信号发散；越靠近无穷发散越快</li><li>极点模长等于1时，为临界稳定状态，保持固有频率震荡</li></ul><p>最终可以得到下图：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621021829222.png" alt="image-20240621021828026"></p><h2 id="s域和z域稳定性关系"><a href="#s域和z域稳定性关系" class="headerlink" title="s域和z域稳定性关系"></a>s域和z域稳定性关系</h2><p>在上一节的分析中可以得出：</p><ul><li>s域所有极点在左半平面系统稳定；z域所有极点在单位圆内系统稳定</li><li>s域有极点在虚轴上系统临界稳定；z域所有极点在单位圆上系统临界稳定</li><li>s域所有极点在右半平面系统不稳定；z域所有极点在单位圆外系统不稳定</li></ul><h1 id="Z域下的稳定性判据"><a href="#Z域下的稳定性判据" class="headerlink" title="Z域下的稳定性判据"></a>Z域下的稳定性判据</h1><p>同前面介绍Routh-Hurwitz稳定性判据时一样，对于低阶系统，我们可以轻易得求得其零极点。但是对于高阶系统这比较困难。因此需要稳定性判据。前面介绍过的s域下的Routh-Hurwitz稳定性判据，这里会介绍 Jury’s Stability test 和 Bilinear transformation 映射到z域下的Routh-Hurwitz稳定性判据</p><h2 id="Jury’s-Stability-test"><a href="#Jury’s-Stability-test" class="headerlink" title="Jury’s Stability test"></a>Jury’s Stability test</h2><p>类似于 Routh - Hurwitz 方法，Jury’s Stability test 也是一个基于数理的稳定性测试。它用于确定多项式的根是否位于单位圆内。</p><p>考虑以下形式的传输函数特征方程：（$a_0&gt;0$）</p><script type="math/tex; mode=display">F(z)=a_0z^n+a_1z^{n-1}+...a_{n-1}z+a_n=0</script><p>与Routh-Hurwitz稳定性判据类似，Jury’s Stability test 也有一张表，需要使用的行数由特征方程的最高阶决定：$行数=2n-3$。例如假设最高是$z^4$，则需要5行。</p><ul><li>表中第一行以逆序和顺序的方式写上系统特征方程的系数。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621110757255.png" alt="image-20240621110757255"></p><ul><li>$b_k,c_k$的计算方法为：</li></ul><script type="math/tex; mode=display">b_k=\left|\begin{array}{cc}     a_0 &    a_{n-k}\\     a_n &    a_{k}\\  \end{array}\right|=(a_0\times a_{k}-a_n\times a_{n-k})</script><script type="math/tex; mode=display">c_k=\left|\begin{array}{cc}     b_{0} &    b_{n-1-k}\\     b_{n-1} &    b_{k}\\  \end{array}\right|=(b_{0}\times b_{k}-b_{n-1}\times b_{n-1-k})</script><p>如下面三图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621111555905.png" alt="image-20240621111555905" style="zoom:50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621111629918.png" alt="image-20240621111629918" style="zoom:50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621111708353.png" alt="image-20240621111708353" style="zoom:50%;" /></p><p>如果满足以下条件则系统稳定</p><ol><li>$F(1)&gt;0$</li><li>$(-1)^nF(-1)&gt;0$</li><li>$|a_0|&lt;a_n$</li><li>$|b_0|&gt;|b_{n-1}|,|c_0|&gt;|c_{n-2}|…$直到最后一个</li></ol><p><em>举个例子：$F(z)=z^4-1.2Z^3+0.07z^2+0.3z-0.08$</em></p><p><strong>step1</strong> 先对$F(1)$和$(-1)^nF(-1)&gt;0$进行判断：</p><script type="math/tex; mode=display">F(1)=1^4-1.21\times1^3+0.07\times1^2+0.3\times1-0.08=0.09>0</script><script type="math/tex; mode=display">(-1)^nF(-1)=(-1)^4[(-1)^4-1.21\times(-1)^3+0.07\times(-1)^2+0.3\times(-1)-0.08]=1.89>0</script><p><strong>step2</strong> 再对$|a_0|&lt;a_n$进行判断：</p><script type="math/tex; mode=display">|a_0|=0.08<1</script><p><strong>step3</strong> 最后再计算表格，对$|b_0|&gt;|b_{n-1}|,|c_0|&gt;|c_{n-2}|…$进行判断。Z有4阶，因此需要$2\times4-3=5$，因此使用5行。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621035453787.png" alt="image-20240621035453787" style="zoom: 80%;" /></p><p>最后发现</p><script type="math/tex; mode=display">|b_0|>|b_3|,|c_0|>|c_2|</script><p>因此系统稳定。</p><h3 id="bilinear-transformation-coupled-with-the-Routh-stability-criterion"><a href="#bilinear-transformation-coupled-with-the-Routh-stability-criterion" class="headerlink" title="bilinear transformation coupled with the Routh stability criterion"></a>bilinear transformation coupled with the Routh stability criterion</h3><p>Part1的Routh stability criterion只适用于s域，但是现在需要讨论离散的z域。这里的方法是使用 bilinear transformation 将z域映射回s域（它这里记作$w$域）：</p><script type="math/tex; mode=display">z=\frac{w+1}{w-1},w=\sigma+j\omega</script><p>映射回去之后，对$w$套用Routh-Hurwitz准则</p><p><em>举个例子：</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621040945660.png" alt="image-20240621040945660"></p><h1 id="采样后的数字控制系统"><a href="#采样后的数字控制系统" class="headerlink" title="采样后的数字控制系统"></a>采样后的数字控制系统</h1><h2 id="简单回顾：Z变换"><a href="#简单回顾：Z变换" class="headerlink" title="简单回顾：Z变换"></a>简单回顾：Z变换</h2><h3 id="抽头形式"><a href="#抽头形式" class="headerlink" title="抽头形式"></a>抽头形式</h3><p>在时域的一个信号，经过脉冲抽样器采样之后会变成下图右侧的样子。其数学表示为</p><script type="math/tex; mode=display">x^*(t)=\sum_{k=0}^{\infty}x(kT)\delta(t-kT)=x(0)\delta(t)+x(T)\delta(t-T)+...+x(kT)\delta(t-kT)...</script><p>这个式子的z变换为：</p><script type="math/tex; mode=display">X(z)=\sum_{k=0}^{\infty}x(kT)z^{-k}=x(0)z^0+z(T)z^{-1}+...+x(kT)z^{-k}+...</script><p>其中$T$为采样周期，$z^{-k}$就是延迟器（Recall：数字信号处理）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621113009801.png" alt="image-20240621113009801"></p><h3 id="S变换-时域-Z变换间的关系"><a href="#S变换-时域-Z变换间的关系" class="headerlink" title="S变换-时域-Z变换间的关系"></a>S变换-时域-Z变换间的关系</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621131827267.png" alt="image-20240621131827267"></p><p>以时域作为媒介，可以使用上述变化对直接对s域到z域进行变换。</p><h2 id="引入-冲击采样的传输系统"><a href="#引入-冲击采样的传输系统" class="headerlink" title="引入-冲击采样的传输系统"></a>引入-冲击采样的传输系统</h2><h3 id="引入-采样输入，采样输出"><a href="#引入-采样输入，采样输出" class="headerlink" title="引入-采样输入，采样输出"></a>引入-采样输入，采样输出</h3><p>考虑这样的一个系统：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621123052665.png" alt="image-20240621123052665"></p><p>在模拟情况下：</p><script type="math/tex; mode=display">Y(s)=U(s)G(s)</script><p>如果将$U(s)$采样为$U^*(s)$，则是：</p><script type="math/tex; mode=display">Y(s)=G(s)U^*(s)</script><p>如果对输出的$Y(s)$也进行采样为$Y^*(s)$，则可以看成两个离散序列卷积，是：</p><script type="math/tex; mode=display">Y^*(s)=(G(s)U^*(s))^*=G^*(s)U^*(s)</script><p>相当于对模拟系统离散化后，再和离散化的信号卷积。模拟信号离散化可以表示为z变换：</p><script type="math/tex; mode=display">G(z)=\sum_{k=0}^{\infty}g(kT)z^{-k}</script><p>其中$g(kT)$是对模拟信号的单位冲击响应的采样序列。因此：</p><script type="math/tex; mode=display">Y(z)=G(z)U(z)</script><h3 id="采样输入，采样传递，采样输出"><a href="#采样输入，采样传递，采样输出" class="headerlink" title="采样输入，采样传递，采样输出"></a>采样输入，采样传递，采样输出</h3><p>再考虑这样一个系统：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621123620252.png" alt="image-20240621123620252"></p><p>根据引入里面的结论，这个系统的表达式可以写为：</p><script type="math/tex; mode=display">Y(z)=G_1(z)G_2(z)U(z)</script><p>传递函数为：</p><script type="math/tex; mode=display">\frac{Y(z)}{U(z)}=G_1(z)G_2(z)</script><h3 id="采样输入，模拟传递，采样输出"><a href="#采样输入，模拟传递，采样输出" class="headerlink" title="采样输入，模拟传递，采样输出"></a>采样输入，模拟传递，采样输出</h3><p>那么对于这个系统：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621123755430.png" alt="image-20240621123755430"></p><p>首先对$U(s)$进行采样，输入系统$G_1(s)$，有：</p><script type="math/tex; mode=display">E(s)=U^*(s)G_1(s)</script><p>$E(s)$会以模拟信号的形式输入$G_2(s)$，有：</p><script type="math/tex; mode=display">Y(s)=E(s)G_2(s)=U^*(s)G_1(s)G_2(s)</script><p>对$Y(s)$进行采样，有：</p><script type="math/tex; mode=display">Y^*(s)=(G_1(s)G_2(s)U^*(s))^*=(G_1(s)G_2(s))^*U^*(s)</script><p>因此传递函数为</p><script type="math/tex; mode=display">\frac{Y(z)}{U(z)}=G_1G_2(z)</script><p><strong>注意！$G_1G_2(z)\neq G_1(z)G_2(z)$</strong></p><h2 id="使用0阶保持器（Zero-Order-Hold，ZOH）将数字信号输入模拟系统"><a href="#使用0阶保持器（Zero-Order-Hold，ZOH）将数字信号输入模拟系统" class="headerlink" title="使用0阶保持器（Zero-Order Hold，ZOH）将数字信号输入模拟系统"></a>使用0阶保持器（Zero-Order Hold，ZOH）将数字信号输入模拟系统</h2><h3 id="ZOH的系统函数"><a href="#ZOH的系统函数" class="headerlink" title="ZOH的系统函数"></a>ZOH的系统函数</h3><p>ZOH可以将离散的数字信号保持一段时间，使其可以输入模拟系统。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621124553389.png" alt="image-20240621124553389" style="zoom:67%;" /></p><p>假设ZOH的保持时间为T，那么其对单位冲激函数的输入会保持T的时间，可以写成时移的两个u(t)相减：</p><script type="math/tex; mode=display">ZOH(t)=1(t)-1(t-T)</script><script type="math/tex; mode=display">ZOH(s)=\frac{1}{s}-\frac{e^{-Ts}}{s}=\frac{1-e^{-Ts}}{s}</script><p>因为单位冲激函数的响应恰好就是系统函数，因此ZOH的函数就是：</p><script type="math/tex; mode=display">ZOH(s)=\frac{1-e^{-Ts}}{s}</script><h3 id="将ZOH输入模拟系统"><a href="#将ZOH输入模拟系统" class="headerlink" title="将ZOH输入模拟系统"></a>将ZOH输入模拟系统</h3><p>将ZOH进入模拟系统$G(s)$后的输出记为$G_{ZA}(s)$</p><script type="math/tex; mode=display">G_{ZA}(s)=\frac{1-e^{-Ts}}{s}G(s)=(1-e^{-Ts})\frac{G(s)}{s}=\frac{G(s)}{s}-e^{-Ts}\frac{G(s)}{s}</script><p>如果将$G_{ZA}(s)$的输出离散采样，回顾一下，时域时移性质在Z变换下和S变换下的表达式：</p><script type="math/tex; mode=display">L[f(t-t_0)]=F(s)e^{-st_0}</script><script type="math/tex; mode=display">Z[f(t-kT)]=z^{-kT}F(z)</script><p>因此我们可以得到：$Z[f(s)e^{-kTs}]=z^{-k}Z[F(s)]]$。所以上式可以写为：</p><script type="math/tex; mode=display">G_{ZA}(Z)=Z[\frac{G(s)}{s}]-z^{-1}Z[\frac{G(s)}{s}]=(1-z^{-1})Z[\frac{G(s)}{s}]</script><script type="math/tex; mode=display">=\frac{z-1}{z}Z[\frac{G(s)}{s}]</script><p>至此我们得到了ZOH输入模拟系统，再对输出采样的结果。这里的$Z[\frac{G(s)}{s}]$需参照上面<em>S变换-时域-Z变换间的关系</em>的表格，直接使用s变换对映射到z变换对来进行变换。</p><p>总结一下：</p><script type="math/tex; mode=display">ZOH(s)=\frac{1-e^{-Ts}}{s}</script><script type="math/tex; mode=display">G_{ZA}(s)=\frac{G(s)}{s}-e^{-Ts}\frac{G(s)}{s}</script><script type="math/tex; mode=display">G_{ZA}(z)=\frac{z-1}{z}Z[\frac{G(s)}{s}]</script><h2 id="采样周期与系统稳定性的关系"><a href="#采样周期与系统稳定性的关系" class="headerlink" title="采样周期与系统稳定性的关系"></a>采样周期与系统稳定性的关系</h2><p>考虑如下这个系统</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240621132107414.png" alt="image-20240621132107414"></p><p>系统传递函数为$G_{ZA}(z)$，根据上面总结的公式：</p><script type="math/tex; mode=display">G_{ZA}(z)=\frac{z-1}{z}Z[\frac{G(s)}{s}]=(\frac{z-1}{z})Z[\frac{5}{s(s+1)}]</script><p>由变换对$\frac{1}{s(s+a)}=\frac{1}{a}(1-e^{-at})=\frac{z(1-e^{-aT})}{a(z-1)(z-e^{-aT})}$可以算得：</p><script type="math/tex; mode=display">G_{ZA}(z)=5(\frac{z-1}{z})(\frac{z(1-e^{-t})}{(z-1)(z-e^{-t})})</script><script type="math/tex; mode=display">=5\frac{1-e^{-T}}{z-e^{-T}}</script><p>其中T为采样周期</p><p>系统的$OLTF(s)=H(s)ZOH(s)G(s)$，$OLTF(z)=2G_{ZA}(z)$，因此：</p><script type="math/tex; mode=display">OLTF(z)=10\frac{1-e^{-T}}{z-e^{-T}}</script><p>系统的$CLTF(z)=\frac{G_{ZA(z)}}{1+OLTF(z)}$</p><script type="math/tex; mode=display">CLTF(z)=\frac{5\frac{1-e^{-T}}{z-e^{-T}}}{1+10\frac{1-e^{-T}}{z-e^{-T}}}=\frac{5(1-e^{-T})}{z-11e^{-T}+10}</script><p>系统特征方程为：$z-11e^{-T}+10=0$，系统极点为$z=11e^{-T}-10$。对于z域，要求所有极点模长小于1，系统稳定，即：</p><script type="math/tex; mode=display">11e^{-T}-10<1 \&11e^{-T}-10>-1</script><script type="math/tex; mode=display">e^{-T}<1, -T<ln(1)=0,T>0</script><script type="math/tex; mode=display">e^{-T}>9,-T<ln(\frac{9}{11}), T<0.2</script><p>因此，求得若要系统稳定，采样周期必须$0&lt;T&lt;0.2$。那么最小采样频率（称为critical frequency）必须大于$f_{critical-frequency}=\frac{1}{T_{max}}=5Hz$，采样频率等于最小采样频率时，系统临界稳定。</p>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Control Systems Part1-5-状态空间表示</title>
      <link href="/posts/cbec893d.html"/>
      <url>/posts/cbec893d.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>本章节Dr.Zooba的PPT在原理阐释上比较模糊，以教会你套公式怎么做题为主，建议参考B站DR_CAN视频：<a href="https://www.bilibili.com/video/BV1fx41137dA/?spm_id_from=333.999.0.0&amp;vd_source=69d49a5680f58d9a0f04ae8cf1207d1d">【Advanced控制理论】2_状态空间_State Space_哔哩哔哩_bilibili</a>。本篇笔记在原理阐释部分以DR_CAN的视频笔记为主。</p></div><h1 id="状态空间表示法"><a href="#状态空间表示法" class="headerlink" title="状态空间表示法"></a>状态空间表示法</h1><h2 id="原理阐释"><a href="#原理阐释" class="headerlink" title="原理阐释"></a>原理阐释</h2><p>对于任意一个系统，其输入和输出可用微分方程表示，例如下图这个由弹簧、阻尼器、小物块构成的系统。小物块质量为m，位移为x，受力情况是：($\dot x$表示$x$的一阶导数，$\ddot x$表示二阶，以此类推)</p><ul><li>受拉力f(t)</li><li>受阻尼力$f_B=B \dot x$</li><li>受弹簧拉力$f_k=kx$</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/QQ_1723510708610.png" alt="QQ_1723510708610"></p><p>根据$F_{合力}=ma,a=v’=x’’$(位移的导数是速度，速度的导数是加速度)，因此可以列出方程：</p><script type="math/tex; mode=display">m\ddot x=f(t)-f_k-f_B=f(t)-kx-B\dot x</script><p>在上式中，<strong>记位移$x$是系统的输出，拉力$f(t)$是系统的输入</strong>。按照以往信号与系统的处理方式，会将该微分方程输入与输出各放一边后拉普拉斯变换。</p><p>但在现在控制理论中，会将其转化为状态空间方程的形式。一个信号经过微分器微分前后就是两个不同的状态（在离散系统中就是延迟器）。例如上式，$x$和$\dot x$就是两个不同的状态。在连续系统中$\dot x$就是$x$经过微分器之后的状态，而$\ddot x$是$\dot x$经过微分器之后的状态。在状态空间方程中，经过微分器即意味进入下一状态，因此状态空间方程是一阶微分方程组构成的。</p><p>将x记为状态$z_1$,$\dot x$记为状态$z_2$，称$z_1,z_2$位状态变量。原方程有：</p><script type="math/tex; mode=display">\ddot x=(f(t)-kx-B\dot x)\frac{1}{m}=\frac{1}{m}f(t)-\frac{k}{m}z_1-\frac{B}{m}z_2</script><p><strong>其中，标记的两状态变量存在方程组：</strong></p><ul><li>$\dot z_1 = \dot x = z_2$</li><li>$\dot z_2 = \ddot x=\frac{1}{m}f(t)-\frac{k}{m}z_1-\frac{B}{m}z_2$</li></ul><div class="note info flat"><p>回顾一下使用矩阵表达方程，对于如下方程组：</p><script type="math/tex; mode=display">x+y+z=6</script><script type="math/tex; mode=display">2y+5z=-4</script><script type="math/tex; mode=display">2x+5y-z=27</script><p>可以写成系数矩阵乘变量矩阵的形式，如下图。（如果没看懂怎么计算的需要复习一下矩阵乘法）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/QQ_1723513339220.png" alt="QQ_1723513339220"></p><p>将方程组的结果代入，就有下式</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/QQ_1723513603870.png" alt="QQ_1723513603870"></p></div><p>用矩阵来表达状态空间$z_1$和$z_2$的两个方程组：</p><script type="math/tex; mode=display">\left[\begin{array}{c}\dot z_1  \\\dot z_2\end{array}\right]=\left[\begin{array}{c}0 & 1  \\-\frac{k}{m} & -\frac{B}{m}\end{array}\right]\left[\begin{array}{c}z_1  \\z_2\end{array}\right]+\left[\begin{array}{c}0  \\\frac{1}{m}\end{array}\right][f(t)]</script><p>前面提到系统的输出是位移$x$，又因记$x=z_1$，因此系统输出$y=x=z_1$。还可以再列一个系统输出的方程：</p><script type="math/tex; mode=display">y=\left[\begin{array}{c}1 & 0\end{array}\right]\left[\begin{array}{c}z_1 \\z_2\end{array}\right]+[0][f(t)]</script><p>这两个矩阵方程记录了系统不同状态间的关系和输出与状态间的关系，被称为状态空间表达式。其可以概括地写为</p><script type="math/tex; mode=display">\boldsymbol{\dot x}=\boldsymbol{A}\boldsymbol{x}+\boldsymbol{Bu}</script><script type="math/tex; mode=display">\boldsymbol y=\boldsymbol{Cx}+\boldsymbol{Du}</script><p>其中ABCD为矩阵，A被称作plant coefficient matrix，B被称作 control matrix，C被称作output observation matrix，D被称作direct coupling matrix。$\boldsymbol {\dot x} $表示状态变量矩阵求导，u为输入矩阵，y为输出矩阵。这些矩阵构建的系统框图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/QQ_1723519860506.png" alt="QQ_1723519860506"></p><p>在前面弹簧系统的例子中：</p><script type="math/tex; mode=display">A=\left[\begin{array}{c}0 & 1  \\-\frac{k}{m} & -\frac{B}{m}\end{array}\right]， B=\left[\begin{array}{c}0  \\\frac{1}{m}\end{array}\right],  C=\left[\begin{array}{c}1 & 0\end{array}\right], D=[0]</script><script type="math/tex; mode=display">\boldsymbol {\dot x} =\left[\begin{array}{c}\dot z_1  \\\dot z_2\end{array}\right]</script><h2 id="状态空间方程与传递函数的关系"><a href="#状态空间方程与传递函数的关系" class="headerlink" title="状态空间方程与传递函数的关系"></a>状态空间方程与传递函数的关系</h2><p>如果将状态空间方程组的左右进行拉普拉斯变换：</p><script type="math/tex; mode=display">L[\boldsymbol{\dot x}]=L[\boldsymbol{A}\boldsymbol{x}+\boldsymbol{Bu}], L[\boldsymbol y]=L[\boldsymbol{Cx}+\boldsymbol{Du}]</script><script type="math/tex; mode=display">sX(s)=\boldsymbol AX(s)+\boldsymbol BU(s),Y(s)=\boldsymbol C X(s)+\boldsymbol DU(s)</script><p>可以发现这两个方程通过状态变量矩阵X(s)联系在一起。而对于状态变量矩阵有：</p><script type="math/tex; mode=display">(s\boldsymbol I-\boldsymbol A)\boldsymbol X(s)=\boldsymbol B U(s)</script><script type="math/tex; mode=display">X(s)=(s\boldsymbol I -\boldsymbol A)^{-1}\boldsymbol BU(s)</script><p>其中$I$为单位矩阵。</p><p>记$(s\boldsymbol I -\boldsymbol A)^{-1}=\Phi(s)$，上式即可写成：$X(s)=\Phi(s)  BU(s)$。将其代入$Y(s)$的等式中：</p><script type="math/tex; mode=display">Y(s)=\boldsymbol CX(s)+\boldsymbol DU(s)=[\boldsymbol C\Phi(s)\boldsymbol B+\boldsymbol D]U(s)</script><p>系统传递函数</p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=C(s\boldsymbol I -\boldsymbol A)^{-1} B+\boldsymbol D</script><div class="note info flat"><p>逆矩阵的求法：$A^{-1}=\frac{A^*}{|A|}$</p><p>其中$A^*$为A的伴随矩阵，$|A|$为A的行列式</p></div><h2 id="状态空间表示的通式"><a href="#状态空间表示的通式" class="headerlink" title="状态空间表示的通式"></a>状态空间表示的通式</h2><p>通常来说，在选择状态变量时，都是微分方程中的0阶、1阶、2阶等倒数，这样就可以通过状态变量矩阵的导数矩阵（即$\boldsymbol {\dot x}$）将他们相互连接起来构成方程组。</p><p>由上面的推导又可知，状态空间方程与传递函数间存在关系。下面进行进一步推导，将这个关系明晰起来。回到前面弹簧的例子中：</p><script type="math/tex; mode=display">A=\left[\begin{array}{c}0 & 1  \\-\frac{k}{m} & -\frac{B}{m}\end{array}\right]， B=\left[\begin{array}{c}0  \\\frac{1}{m}\end{array}\right],  C=\left[\begin{array}{c}1 & 0\end{array}\right], D=[0]</script><script type="math/tex; mode=display">sI-A=\left[\begin{array}{c}s & 0  \\0 & s\end{array}\right]-\left[\begin{array}{c}0 & 1  \\-\frac{k}{m} & -\frac{B}{m}\end{array}\right]=\left[\begin{array}{c}s & -1  \\\frac{k}{m} & s+\frac{B}{m}\end{array}\right]</script><script type="math/tex; mode=display">(s\boldsymbol I -\boldsymbol A)^{-1}=\frac{(sI-A)^*}{|(sI-A)|}=\frac{\left[\begin{array}{c}s & -1  \\\frac{k}{m} & s+\frac{B}{m}\end{array}\right]}{}</script><script type="math/tex; mode=display">C(s\boldsymbol I -\boldsymbol A)^{-1} B+\boldsymbol D</script><p>如下微分方程(s域变换后)。</p><script type="math/tex; mode=display">Y(s)=\frac{b_0 s^n+b_1s^{n-1}+...+b_{n-1}s+b_n}{(s+p_1)^3(s+p_4)(s+p_5)...(s+p_n)}\times U(s)</script>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Control Systems Part1-4b-超前、滞后补偿器设计</title>
      <link href="/posts/cbec893d.html"/>
      <url>/posts/cbec893d.html</url>
      
        <content type="html"><![CDATA[<h1 id="预补偿器（Pre-Compensator）的介绍"><a href="#预补偿器（Pre-Compensator）的介绍" class="headerlink" title="预补偿器（Pre-Compensator）的介绍"></a>预补偿器（Pre-Compensator）的介绍</h1><p>预补偿器和上文PID控制器位于系统中同一位置，它旨在用于调整系统响应的各个方面，包括稳态误差、Overshoot、setting time等等。在不重新设计整个控制系统的情况下，使用预补偿器是一种相对简单的方法来修改系统。PID其实就是一种特殊的预补偿器。</p><p>它的优点有：</p><ul><li>简单：无需重新设计整个系统</li><li>精确：可以通过对与补偿器的设计来消除系统稳态误差</li><li>灵活：它可以影响系统的方方面面而不直接修改系统</li></ul><p>它的缺点有：</p><ul><li>带宽限制：提高稳态误差性能会导致带宽变窄，从而影响系统快速响应变化的能力。</li><li>稳定性问题：如果设计不当，添加预补偿器可能会破坏系统的稳定性，特别是如果引预补偿器入了明显的相位滞后。</li><li>设计中的复杂性：对于某些系统，设计有效的预补偿器需要对系统响应进行复杂的分析和理解，这可能既复杂又耗时。</li></ul><h1 id="根轨迹下预补偿器的设计"><a href="#根轨迹下预补偿器的设计" class="headerlink" title="根轨迹下预补偿器的设计"></a>根轨迹下预补偿器的设计</h1><h2 id="前置知识：如何判断根是否在根轨迹上"><a href="#前置知识：如何判断根是否在根轨迹上" class="headerlink" title="前置知识：如何判断根是否在根轨迹上"></a>前置知识：如何判断根是否在根轨迹上</h2><h1 id="频率响应下的预补偿器（Pre-Compensator）设计"><a href="#频率响应下的预补偿器（Pre-Compensator）设计" class="headerlink" title="频率响应下的预补偿器（Pre-Compensator）设计"></a>频率响应下的预补偿器（Pre-Compensator）设计</h1><h2 id="引入-PID控制器与与补偿器的关系"><a href="#引入-PID控制器与与补偿器的关系" class="headerlink" title="引入-PID控制器与与补偿器的关系"></a>引入-PID控制器与与补偿器的关系</h2><h3 id="PI控制器"><a href="#PI控制器" class="headerlink" title="PI控制器"></a>PI控制器</h3><p>前面提到PI控制器有消除稳态误差的能力。PI控制器的通式为：</p><script type="math/tex; mode=display">G_c(s)=K_p(1+\frac{1}{K_is})=\frac{K_pK_is+1}{K_is}</script><p>但是由于PI控制器给分母引入了孤立s，会改变系统的类型造成高频衰减，从而破坏原本调好的动态响应。有没有什么类 PI 补偿的表达式，它在 s = 0 时产生显著的增益，从而减小稳态误差，但在较高频率下几乎为 1，对动态响应没有影响呢？</p><p>答案就是在分母上将在原点的极点移动一下，移动成靠近0的极点，这个极点的影响范围主要在低频（回顾波德图，0.1T-10T范围）。因此在低频时其幅频图还是收原来的PI控制器影响为主，但是在高频这个极点的贡献就失效了，而不像在直接在原点一样对全频有效；同时也因为这个移动，导致稳态误差无法彻底被消除，因此设计时还是需要考虑稳态误差。这就是相位滞后补偿器（Phase Lag Compensator）。</p><script type="math/tex; mode=display">G_{lag}(s)=K\frac{\tau s+1}{\alpha\tau s+1},\alpha>1</script><p>在这个表达式下，又保留了s = 0 时产生显著的增益，从而减小稳态误差的特性。管他叫滞后补偿器的原因是这个补偿器函数的波德图相位是负数，如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/2020080515233235.png" alt="在这里插入图片描述" style="zoom:50%;" /></p><h3 id="PD控制器"><a href="#PD控制器" class="headerlink" title="PD控制器"></a>PD控制器</h3><p>前面提到PI控制器有增加相位裕量的能力（增加系统稳定性）；同时，不影响稳态误差。其通式为：</p><script type="math/tex; mode=display">C(s)=K_p(1+K_ds)</script><p>我们注意到，PD 补偿的幅度会随着频率的增加而不断增大。这一特性并不受欢迎，因为它会放大高频噪声。</p><p>为了减轻 PD 补偿的高频放大，在比 PD 补偿器高得多的频率处，在分母中添加了一个一阶极点来抵消零点的增益（可以回顾波德图，这个一阶极点的影响范围会被局限在高频）。这就是超前补偿器（Phase Lead Compensator）。</p><script type="math/tex; mode=display">G_{lead}(s)=K\frac{\tau s+1}{\beta\tau s+1},\beta<1</script><p>管它叫超前补偿器的原因是补偿器函数波德图的相位是正数，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/20200805152307198.png" alt="在这里插入图片描述" style="zoom:50%;" /></p><h2 id="超前-滞后补偿器介绍"><a href="#超前-滞后补偿器介绍" class="headerlink" title="超前-滞后补偿器介绍"></a>超前-滞后补偿器介绍</h2><h3 id="滞后补偿器"><a href="#滞后补偿器" class="headerlink" title="滞后补偿器"></a>滞后补偿器</h3><p>用途：<strong>主要用于改善稳态误差，</strong>而不会显著影响系统的稳定性裕度。</p><p>工作原理：滞后补偿器通常在系统的传递函数中添加一个极点和一个零点，零点位于极点的左侧。这种配置增加了低频增益，而不会显著影响高频增益（高频零极点同时发力了），从而通过增加系统的类型或其直流增益来提高系统跟踪稳态值（如阶跃响应）的能力。</p><p>应用：适用于需要稳态精度但不希望对瞬态响应或高频特性进行重大修改的系统。</p><h3 id="超前补偿器"><a href="#超前补偿器" class="headerlink" title="超前补偿器"></a>超前补偿器</h3><p>用途：<strong>旨在改善系统的瞬态响应</strong>，包括减少上升时间、建立时间和增加相位裕量（从而提高稳定性）。</p><p>工作原理：超前补偿器在系统的传递函数中引入零点和极点，零点位于极点左侧）。在低频时以零点提供的为主导，使系统响应更快、响应速度更快。</p><p>应用：通常用于使系统响应更快或使边缘稳定系统稳定的情况。它们在控制系统中很常见，因为控制系统的响应速度和稳定性比稳态精度更重要。</p><h3 id="超前-滞后补偿器"><a href="#超前-滞后补偿器" class="headerlink" title="超前-滞后补偿器"></a>超前-滞后补偿器</h3><p>用途：结合超前和滞后补偿器的特性，以改善系统的瞬态和稳态响应</p><p>工作原理：超前滞后补偿器引入了两组极点和零点：一对提供相位超前（改善瞬态响应），另一对提供相位滞后（改善稳态误差）。该设计更加复杂，它旨在平衡瞬态和稳态性能之间的权衡。</p><p>应用：需要稳态精度和良好的瞬态响应。它们用于需要稳定响应、减少过冲和确保稳态误差符合设计规范的系统。示例包括航空航天、机器人和汽车工程中的先进控制系统。</p><h3 id="从补偿效果的角度来理解超前和滞后补偿器"><a href="#从补偿效果的角度来理解超前和滞后补偿器" class="headerlink" title="从补偿效果的角度来理解超前和滞后补偿器"></a>从补偿效果的角度来理解超前和滞后补偿器</h3><p>下图展示了分别有超前补偿器和滞后补偿器补偿的单位阶跃响应。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620160150974.png" alt="image-20240620160150974" style="zoom:67%;" /></p><p>下图是超前补偿器对系统补偿前后的波德图。可以看到超前补偿器对高频信号有一个增益，同时补偿后的相位也领先于补偿前的；</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620180005534.png" alt="image-20240620180005534" style="zoom:50%;" /></p><p>下图是滞后补偿器对系统补偿前后的波德图。可以看到滞后补偿器对高频有明显衰减（相对而言就是对低频的增益），同时补偿后的相位滞后于补偿前的。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620180255608.png" alt="image-20240620180255608" style="zoom:80%;" /></p><div class="note info flat"><p>请注意，超前补偿器或滞后补偿器不是超前补偿器增加相位裕度、滞后补偿器减少相位裕度。超前补偿器虽然整体抬高了相位裕度，但是它也抬高了高频，导致幅值穿越频率靠后。滞后补偿器虽然整体减小了相位裕度，但是也削减了高频，导致幅值穿越频率靠前。通常来说，这两种补偿器最终的结果都是保持或增加了相位裕度。</p></div><h2 id="超前、滞后补偿器设计"><a href="#超前、滞后补偿器设计" class="headerlink" title="超前、滞后补偿器设计"></a>超前、滞后补偿器设计</h2><h3 id="系统参数要求"><a href="#系统参数要求" class="headerlink" title="系统参数要求"></a>系统参数要求</h3><p>设计要求通常以稳态误差和相位裕度的约束形式给出，例如：</p><ul><li>对于某种输入，要求$e_{ss}&lt;0.01$</li><li>要求$PM&gt;45^\circ$</li></ul><p>如果设计要求是阻尼比，那么对于<strong>具有二阶特性的系统</strong>，我们可以使用以下关系将其转换为近似的相位裕度要求：</p><script type="math/tex; mode=display">PM(degrees)\approx100\zeta</script><h3 id="滞后补偿器设计"><a href="#滞后补偿器设计" class="headerlink" title="滞后补偿器设计"></a>滞后补偿器设计</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620160355088.png" alt="image-20240620160355088"></p><ol><li><p>记单位增益的相位滞后系统传输函数为$G_{lag}(s)$，前面提到，它无法完全消除稳态误差了。而稳态误差$e_{ss}=\frac{1}{1+\lim_{s\rightarrow0}{KG_{lag}(s)}}$可以通过加增益K来尽可能减小。因此，设计的第一步就是找到一个K来满足$e_{ss}$。</p></li><li><p>有了K之后，可以画出这个系统相位滞后补偿时开环传递函数的波德图，即$KG(s)H(s)$的波德图，找到系统目前的幅度穿越频率和其对应的相位裕度（记为$PM_{sys}$）</p></li><li><p>根据系统要求的参数，可以计算出一个新的相位裕度要求，记为$PM_{spec}$。此时我们的目标是通过滞后补偿器将系统新的相位裕度削减成$PM_{spec}$。由于$PM_{spec}$是使用经验公式约等于出的，同时下面介绍的计算补偿量的方法也不完全精确，因此通常需要额外补偿一下。将这个额外补偿的量记为$\phi_c$。</p></li><li><p>在前面画的波德图上，找到$PM_{spec}+\phi_c$对应的穿越频率$\omega_{gco}$。要使得当前系统的穿越频率变成这个新的$\omega_{gco}$，就需要给一个负增益，记为$K_{red}$。直接当前波德图将$\omega_{gco}$这一点的$幅值-0dB$即可拿到$K_{red}(dB)$</p></li><li><p>我们根据下面的公式来计算系统参数：</p></li></ol><script type="math/tex; mode=display">\tau=10/\omega_{gco}</script><script type="math/tex; mode=display">\alpha=10^{K_{red}/20}</script><script type="math/tex; mode=display">G_{lag}(s)=\frac{\tau s+1}{\alpha \tau s+1}</script><ol><li>至此我们求到了补偿器；再画出补偿器的波德图，看一看$PM$是否削减到位，如果不到位就再补狠一点再试。</li></ol><p>总体来说，设计步骤可以归纳为下图：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620164311907.png" alt="image-20240620164311907" style="zoom:67%;" /></p><p><em>举个例子</em></p><p><em>要求给如下系统设计一个补偿器，使得$K_V&lt;5 sec^{-1}$ ,相位裕度至少$40^\circ$，幅值裕度至少$10dB$，$\phi_c=12^\circ$</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620164544213.png" alt="image-20240620164544213" style="zoom:50%;" /></p><ol><li>首先根据CH1中介绍的寻找Unit ramp 输入下稳态速度常数的公式计算出需要的增益：</li></ol><script type="math/tex; mode=display">K_v=\lim_{s\rightarrow0}{sKG(s)}=K=5</script><p>因此$K=5$</p><ol><li>画出$KG(s)$的波德图，如下图所示</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620164806263.png" alt="image-20240620164806263"></p><ol><li>需要的相位裕度是$$</li></ol><p>由于滞后相位补偿器在低频点会有一个增益，这会导致幅频曲线抬高$\omega_{gco}$后移而，而下面根据补偿量计算补偿器参数的公式并没有考虑这个后移，因此可以适当多补偿一些，多补偿的值记为$\phi_c$，称为additional phase angle，使得系统。</p><p>找到一个新的$\omega_{gco}$，使其满足期望的相位；</p><h3 id="超前补偿器设计"><a href="#超前补偿器设计" class="headerlink" title="超前补偿器设计"></a>超前补偿器设计</h3><p>类似于滞后补偿器，超前补偿器的设计总结为下表。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620172117376.png" alt="image-20240620172117376"></p>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Control Systems Part1-4a-时延影响和PID</title>
      <link href="/posts/24faf8c6.html"/>
      <url>/posts/24faf8c6.html</url>
      
        <content type="html"><![CDATA[<h1 id="时间延迟对系统频响的影响"><a href="#时间延迟对系统频响的影响" class="headerlink" title="时间延迟对系统频响的影响"></a>时间延迟对系统频响的影响</h1><p>时延是输入与控制系统开始响应输出之间的时间差，其被称为lag或者dead time，记作T或表示成$e^{-sT}$(拉普拉斯变换的时移性质：$L[f(t-t_0)]=F(s)e^{-st_0}$)</p><h2 id="时延对频响相响图的影响"><a href="#时延对频响相响图的影响" class="headerlink" title="时延对频响相响图的影响"></a>时延对频响相响图的影响</h2><p>考虑一个系统函数为$G(s)$的一个系统，对其引入时间为T的时延，并求波德图</p><script type="math/tex; mode=display">G(s)e^{-sT}=|G(j\omega)|e^{\angle G(j\omega)}e^{-j\omega T}=|G(j\omega)|e^{j[\angle G(j\omega)-\omega T]}</script><ul><li>系统的幅频响应对应$|G(j\omega)|$，因此时延并不改变幅频响应。</li><li>但时间延迟从相频响应图中减去了$\omega T$，也就是说，随着频率增大，相位减少越大；换句话说，它削减了相位裕度。</li></ul><p>如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620110101045.png" alt="image-20240620110101045"></p><p>显然，如果时间延迟非常大，闭环系统将不稳定。</p><h2 id="从时域的角度看"><a href="#从时域的角度看" class="headerlink" title="从时域的角度看"></a>从时域的角度看</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620110546063.png" alt="image-20240620110546063" style="zoom:50%;" /></p><p>从时域的角度来看，延迟会造成（即，削减相位裕度会造成）</p><ul><li>更低的阻尼比</li><li>更多的振荡响应</li></ul><p><strong>当系统内带有非最小相位元件(带有时滞特性/延时，相位滞后)元件时，会产生非最小相位系统。因此我们一般不单独讨论延迟，而是将其看做非最小相位系统来讨论。</strong></p><h1 id="非最小相位系统"><a href="#非最小相位系统" class="headerlink" title="非最小相位系统"></a>非最小相位系统</h1><h2 id="什么是非最小相位系统"><a href="#什么是非最小相位系统" class="headerlink" title="什么是非最小相位系统"></a>什么是非最小相位系统</h2><p><strong>非最小相位系统（Nonminimum-Phase (NMP) Systems）</strong>是在复平面的右半平面（RHP）上具有零点，但系统仍旧稳定（极点还在左侧）的系统。由于<strong>根轨迹总是趋近并收敛于零点</strong>，因此当增益大到某一点，右半平面的零点有使系统极点趋向右半平面的趋势，可能造成系统不稳定。</p><p>（补充）反之，<strong>最小相位系统(Minimum-Phase (MP) Systems)</strong>就是s域右半平面没有零点或者极点的系统。最小相位系统无论何时都是稳定的。</p><p><strong>在具有相同幅值特性的系统中，对于大于零的任何频率，最小相位系统的相角总小于非最小相位系统</strong>；例如下图，是$G_1(s)=10\frac{s+1}{s+10}$（MP system）和$G_2(10\frac{s-1}{s+10})$(NMP system)的幅频图相频图。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620112615410.png" alt="image-20240620112615410" style="zoom:67%;" /></p><h2 id="从单位阶跃响应看最非小相位系统-负调"><a href="#从单位阶跃响应看最非小相位系统-负调" class="headerlink" title="从单位阶跃响应看最非小相位系统-负调"></a>从单位阶跃响应看最非小相位系统-负调</h2><div class="note info flat"><p>参考资料：<a href="http://aas.net.cn/fileZDHXB/journal/article/zdhxb/2015/1/PDF/2015-1-9.pdf">自动化学报</a></p></div><p><strong>一般情况下</strong>, 非最小相位系统对阶跃输入信号具有负调(Overshoot, 或称为下冲) 响应。下冲意味着阶跃输入的暂态响应一开始朝阶跃输 入的相反方向运动</p><p>下图展示了传递函数为$G(s)=\frac{(s-1)^2}{(s+1)^3}$的单位阶跃响应。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620115911551.png" alt="image-20240620115911551" style="zoom:50%;" /></p><p><strong>对于非最小相位系统而言，其单位阶跃响应穿过0的次数（不包含原点）大于或等于右半平面零点的个数。</strong>例如上图，右半平面零点有两个，都是1，因此穿越两次0。</p><p><strong>但是，</strong>当一个线性非最小相位系统<strong>含有非实零点</strong>时, 其阶跃响应<strong>并非一定</strong>具有负调特性（可能还是有）。如传递函数$G(s)=\frac{s^2-s+4}{(s+3)^3}$描述的非最小相位系统对阶跃信号的响应就是单调的, 没有负调特性，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620121619325.png" alt="image-20240620121619325" style="zoom:50%;" /></p><p>对于非线性非最小相位系统, 其阶跃响应<strong>一般具有负调特性</strong>,但因其种类繁多,无法用统一的定理 来判定其负调响应的类型。</p><h1 id="PID控制器"><a href="#PID控制器" class="headerlink" title="PID控制器"></a>PID控制器</h1><p>PID控制器是一种利用比例（Proportional）、积分（Integral）和微分（Derivative）三种动作来根据误差信号<strong>调节系统输入</strong>的反馈控制器。因为是调节系统输入，PID控制器一般作用于系统函数之前，和系统函数一起构成新的经过修补的前向传输函数。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620122131142.png" alt="image-20240620122131142"></p><p>PID控制器的通用式可以表达为（分别对应比例部分，积分部分，微分部分）：</p><script type="math/tex; mode=display">c(t)=K_p[e(t)+\frac{1}{K_i}\int_0^te(t)dt+K_D\frac{de(t)}{dt}]</script><script type="math/tex; mode=display">C(s)=K_p\bigg(1+\frac{1}{K_is}+K_ds\bigg)</script><p>而所谓调PID，其实就是去调$K_p,K_i,K_d$这三个系数。下面会详细介绍</p><h2 id="拆分研究"><a href="#拆分研究" class="headerlink" title="拆分研究"></a>拆分研究</h2><h3 id="P控制器"><a href="#P控制器" class="headerlink" title="P控制器"></a>P控制器</h3><p>只保留P控制器的话，那就相当于给了一个增益，即$C(s)=K_P$，它和系统级联构成的就是$K_PG(s)$。单看这个控制器，它相当于把原来输入系统函数的$e$（$e$是输入与当前输出的差）放大成了$K_Pe$。</p><p>下图展示了P控制器下，控制器的输入$e$和其对应的输出（即输入给$G(s)$的输入）：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620141336365.png" alt="image-20240620141336365" style="zoom:50%;" /></p><p>比例控制存在着一些不足——无法消除稳态误差。</p><p>假设系统$G(s)$自带稳态误差，那么对于单位阶跃信号（推导见CH1)：</p><script type="math/tex; mode=display">e_{ss}=\frac{1}{1+\lim_{s\rightarrow0}{K_PG(s)}}</script><p>可以看到因为原系统$\lim_{s\rightarrow0}{G(s)}\neq\infty$，$K_p$只是减小了稳态误差，没有完全消除。</p><h3 id="I控制器"><a href="#I控制器" class="headerlink" title="I控制器"></a>I控制器</h3><p>I控制器就是积分的部分，其s域为$C(s)=\frac{K_i}{s}$。该控制器会将$e$进行积分，即控制器输出为$K_i\int edt$，如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620142321190.png" alt="image-20240620142321190"></p><p>由于这个积分项会将前面若干次的误差进行累计，所以可以很好的消除稳态误差。从数学推导的角度来解释一下：</p><p>假设系统$G(s)$自带稳态误差，那么对于单位阶跃信号</p><script type="math/tex; mode=display">e_{ss}=\frac{1}{1+\lim_{s\rightarrow0}{\frac{K_i}{s}G(s)}}</script><p>此时分母这个$s$会使得后面这一项趋于无穷，进而导致$e_{ss}=0$</p><h3 id="D控制器"><a href="#D控制器" class="headerlink" title="D控制器"></a>D控制器</h3><p>D控制器是微分的部分，其s域为$K_ds$，即该控制器会对误差进行微分，求出误差的变化速率：$de/dt$。下图展示了控制器输入与输出关系</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620142438652.png" alt="image-20240620142438652" style="zoom:67%;" /></p><p>微分控制器不会影响稳态误差，因为在稳态误差发生时，$e$已然达到稳定，误差随时间的变化率为零，因此微分控制器在此时并不起作用。</p><h2 id="不同控制器多项结合"><a href="#不同控制器多项结合" class="headerlink" title="不同控制器多项结合"></a>不同控制器多项结合</h2><h3 id="PI控制器"><a href="#PI控制器" class="headerlink" title="PI控制器"></a>PI控制器</h3><script type="math/tex; mode=display">C(s)=K_p(1+\frac{1}{K_is})</script><ul><li>P控制器只能减少不能消除稳态误差，而I控制器可以完全消除稳态误差。因此这二者结合的控制器稳态误差被I消除，<strong>没有稳态误差</strong>。</li><li>给系统的分母引入了一个$s$，削减了系统的高频（s很大）增益，而噪声通常是高频的，因此削减了噪声的影响</li><li>在分母引入$s$，相当于加快向量负半虚轴的增量；同时削减高频增益还使得幅度穿越频率变得更靠前。二者综合，即，减小了相位裕量。</li></ul><p>控制器波特图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620144647268.png" alt="image-20240620144647268" style="zoom:67%;" /></p><h3 id="PD控制器"><a href="#PD控制器" class="headerlink" title="PD控制器"></a>PD控制器</h3><script type="math/tex; mode=display">C(s)=K_p(1+K_ds)</script><ul><li>给分子引入一个s可以略微降低低频增益并提高高频增益。使得穿越频率靠后，增加相位裕量。</li><li>但是也增加噪声对系统的影响，因为噪声往往是高频的。</li></ul><p>控制器波德图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620145225026.png" alt="image-20240620145225026" style="zoom: 67%;" /></p><h3 id="PID控制器-1"><a href="#PID控制器-1" class="headerlink" title="PID控制器"></a>PID控制器</h3><p>标准形式：</p><script type="math/tex; mode=display">C(s)=K_p\bigg(1+\frac{1}{K_is}+K_ds\bigg),T_i=\frac{K_p}{K_i},T_d=K_dK_p</script><p>并联形式：</p><script type="math/tex; mode=display">C(s)=K_p+\frac{T_i}{s}+T_ds</script><p>结合所有三种控制模式（比例、积分和微分），可以生产出没有稳态误差并减少振荡趋势的控制器。在后面Part2会介绍PID调谐原则，即如何调整$K_p,K_i,K_d$。</p>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电信传输理论-CH1-通信传输的基本概念</title>
      <link href="/posts/7cf324fe.html"/>
      <url>/posts/7cf324fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="通信系统简介"><a href="#通信系统简介" class="headerlink" title="通信系统简介"></a>通信系统简介</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240616123215614.png" alt="image-20240616123215614"></p><p>一个传输系统一般可分为5块（5 blocks），其组成上图所示。</p><ul><li>信源（Source）：提供需要传输的信息信号;</li><li>发射机（Transmitter）：对信源产生的信息进行编码、调制并对信号进行放大，使其符合信道的传输特性。例如moden将数字信号调制为模拟信号传输。</li><li>传输系统/信道等：可以是连接发射机和接收机的线，也可是一整个网络系统。<br>穿越它。</li><li>接收机（Receiver）：接收发射机发送的信号，并将其转换为可由目标设备处理的形式。例如modem会将模拟信号解调为数字信号再发给电脑。</li><li>信宿（sink/ destination）：服务器、电脑、手机等。信息的目的地。</li></ul><p>在通信系统中，Transmission一词强调信息的传输，Propagation一词强调承载信息的电磁波的传播。</p><h2 id="服务质量（Quality-of-Service-QoS"><a href="#服务质量（Quality-of-Service-QoS" class="headerlink" title="服务质量（Quality of Service, QoS)"></a>服务质量（Quality of Service, QoS)</h2><p>QoS指网络的服务质量，也指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力。</p><p>当网络发生拥塞的时候，数据可能被丢弃；为满足用户对不同应用不同服务质量的要求，就需要网络能根据用户的要求分配和调度资源，对不同的数据流提供不同的服务质量：对实时性强且重要的数据报文优先处理；对于实时性不强的普通数据报文，提供较低的处理优先级，网络拥塞时甚至丢弃。</p><p>High QoS指的就是服务质量很高，延迟，数据可靠性，数据传输速率等等很优秀</p><p>有的通信协议，例如MQTT这种物联网协议，也定义不同的QoS模式，来针对不同的场景设计不同的数据可靠性。</p><h1 id="衡量通信系统的两个常用单位-dB-amp-np"><a href="#衡量通信系统的两个常用单位-dB-amp-np" class="headerlink" title="衡量通信系统的两个常用单位-dB&amp;np"></a>衡量通信系统的两个常用单位-dB&amp;np</h1><h2 id="分贝（decibel）"><a href="#分贝（decibel）" class="headerlink" title="分贝（decibel）"></a>分贝（decibel）</h2><p>分贝是指将数值n取为以10为底的对数。</p><p>这么做的有点有二：</p><ul><li>将极小的或极大的数据保持在较好处理的范围内</li><li>将非线性的平方、立方关系化为线性关系</li></ul><h3 id="使用分贝表示功率"><a href="#使用分贝表示功率" class="headerlink" title="使用分贝表示功率"></a>使用分贝表示功率</h3><p>$P=UI=U^2/R=I^2R$</p><p>因为功率内含平方值，所以讨论功率时使用$10log_{10}(\frac{P_2}{P_1})$</p><p>功率的单位有 瓦特 （W）、毫瓦 （mW） 和微瓦 （μW），对这些不同单位的功率取对数，分别可以得到 dBW，dbm等</p><p><em>举个例子，下图这个$1W$进去$2W$出来的网络，网络增益是：</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240616130756521.png" alt="image-20240616130756521"></p><script type="math/tex; mode=display">Gain=10log(\frac{output}{input})=10log(\frac{2}{1})=3.0103dB</script><p>从这个例子不难看出，一倍的关系正好是3dB，因此当功率衰减一半时，被称为-3dB点。</p><p><em>假设有下图这个网络，网络衰减为27dB，求输出功率</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240616131316419.png" alt="image-20240616131316419"></p><p>这个例子可以简化计算，考虑衰减30dB（Gain = -30dB）的情况，即:</p><script type="math/tex; mode=display">log(\frac{output}{input})=-3,output=10^{-3}\times input=1mW</script><p>27dB比30dB多3dB，也就是多一倍，因此这个输出值大约是$2mW$</p><p><strong>dBW：</strong></p><p>dBW是值以1W作为基准（放在分母位置），求得现在的功率和1W的dB关系</p><script type="math/tex; mode=display">Power(dBW)=10log_{10}\frac{Power(W)}{1W}</script><p><strong>dBm:</strong></p><p>dBm是值以1mW作为基准（放在分母位置），求得现在的功率和1mW的dB关系</p><script type="math/tex; mode=display">Power(dBm)=10log_{10}\frac{Power(mW)}{1mW}</script><p>一对特殊值：$30dBm=0dBW=1W$, $-30dBW=0dBm=1mW$</p><h3 id="使用分贝表示电压电流"><a href="#使用分贝表示电压电流" class="headerlink" title="使用分贝表示电压电流"></a>使用分贝表示电压电流</h3><p>当讨论U，I这些参数的时候，它没有了功率自带的平方属性。但是我们仍然想统一dB的特殊点，例如-3dB点是半功率点。</p><p>因此，讨论电压电流时使用$20log_{10}(\frac{U_2}{U_1})$和$20log_{10}(\frac{I_2}{I_1})$</p><p>例如，$U_2/U_1=100$，那它们的dB形式就是：</p><script type="math/tex; mode=display">20log_{10}(100)=40dB</script><p>如果一个电压放大器增益为30dB，那么，$\frac{output}{input}$的关系是：</p><script type="math/tex; mode=display">30=20log\frac{output}{input}, \frac{output}{input}=10^{\frac{3}{2}}=31.62277</script><h2 id="奈培（Neper）"><a href="#奈培（Neper）" class="headerlink" title="奈培（Neper）"></a>奈培（Neper）</h2><p>北欧许多国家都使用一种以自然对数为替代10底的对数的单位，奈培 (𝑁𝑝)</p><script type="math/tex; mode=display">Power(Np)=\frac{1}{2}ln(\frac{P_2}{P_1})</script><p>假设现在功率比为1Np，那么：</p><script type="math/tex; mode=display">\frac{P_2}{P_1}=e^{2}</script><p>转化为dB形式：</p><script type="math/tex; mode=display">10log_{10}{(e^2)}\approx8.686dB</script><p>假设功率为1dB，那么：</p><script type="math/tex; mode=display">\frac{P_2}{P_1}=10^{0.1}</script><p>转化为Np形式：</p><script type="math/tex; mode=display">\frac{1}{2}ln(10^{0.1})\approx0.1151Np</script><div class="note danger flat"><p>五星级关系</p></div><p><strong>因此，Np和dB的关系是：1dB=0.1151Np； 1Np=8.686dB</strong></p><h2 id="dB单位下的线路组合"><a href="#dB单位下的线路组合" class="headerlink" title="dB单位下的线路组合"></a>dB单位下的线路组合</h2><h3 id="直接转换"><a href="#直接转换" class="headerlink" title="直接转换"></a>直接转换</h3><p>对于下图这样的情况，其输出的功率并非9dB，9dB是将两路信号相乘的结果，而这里是相加。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240616135054665.png" alt="image-20240616135054665"></p><p>因此，需要将其换算回mW的单位，相加后再求dB</p><script type="math/tex; mode=display">log^{-1}(0.6)+log^{-1}(0.3)=5.976mW</script><script type="math/tex; mode=display">10log_{10}(5.976mW/1mW)=7.7441dBW</script><p><em>例题：求输出功率</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240616135820082.png" alt="image-20240616135820082"></p><script type="math/tex; mode=display">log^{-1}(0.7)+log^{-1}(1.1)=17.601mW</script><script type="math/tex; mode=display">P=10log{(\frac{17.601mW}{1mW})}=12.455dBm</script><h3 id="多路同功率信号"><a href="#多路同功率信号" class="headerlink" title="多路同功率信号"></a>多路同功率信号</h3><p>试想一下有一个FDM信号群，每一路都是-16dBm，总共有12路。每一路的功率换算成mW是：</p><script type="math/tex; mode=display">log^{-1}(1.6)</script><p>那么，总共有12路，总功率是$12\times log^{-1}(1.6)$。求这个功率的dBm形式就是</p><script type="math/tex; mode=display">10log(12\times log^{-1}(1.6))=10log(12)+(-16dBm)</script><p>因此，$n$路同功率信号的功率叠加可以总结为：</p><script type="math/tex; mode=display">输入信号功率+10log(n)</script>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 电信传输理论与工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电信传输理论-罐装知识</title>
      <link href="/posts/9ab7db8e.html"/>
      <url>/posts/9ab7db8e.html</url>
      
        <content type="html"><![CDATA[<h1 id="CH1-传输通信的基本概念"><a href="#CH1-传输通信的基本概念" class="headerlink" title="CH1-传输通信的基本概念"></a>CH1-传输通信的基本概念</h1><h3 id="5-block系统模型"><a href="#5-block系统模型" class="headerlink" title="5 block系统模型"></a>5 block系统模型</h3><ul><li>source、transmitter、Transmission system、receiver、destination</li></ul><h3 id="Telecommunication-的定义"><a href="#Telecommunication-的定义" class="headerlink" title="Telecommunication 的定义"></a>Telecommunication 的定义</h3><ul><li>a transmission of signals in a long distance</li></ul><h3 id="奈培和分贝"><a href="#奈培和分贝" class="headerlink" title="奈培和分贝"></a>奈培和分贝</h3><script type="math/tex; mode=display">dB:10log(\frac{P_2}{P_1}); Np=\frac{1}{2}ln(\frac{P_2}{P_1})</script><p><strong>Np=8.686dB</strong></p><h1 id="CH2-数据传输"><a href="#CH2-数据传输" class="headerlink" title="CH2-数据传输"></a>CH2-数据传输</h1><h3 id="传输损伤"><a href="#传输损伤" class="headerlink" title="传输损伤"></a>传输损伤</h3><p>传输损伤来自</p><ul><li>衰减（Attenuation）和传输失真（Attenuation distortion）</li><li>延迟失真（Delay distortion）</li><li>噪声（Noise）</li></ul><p>其中噪声可以细分为：</p><ul><li>热噪声 thermal noise；$N=kTB$,玻尔兹曼常$k=1.38\times10^{-23}J/K$</li><li>互调噪声 intermediation noise</li><li>串扰 crosstalk</li><li>冲击噪声 impulse noise</li></ul><h3 id="信道容量"><a href="#信道容量" class="headerlink" title="信道容量"></a>信道容量</h3><ul><li>奈奎斯特带宽$R_B=2B$</li><li>香农公式$C=Blog_2(1+SNR)$</li></ul><h3 id="E-b-N-0-的两种表达式"><a href="#E-b-N-0-的两种表达式" class="headerlink" title="$E_b/N_0$的两种表达式"></a>$E_b/N_0$的两种表达式</h3><ul><li>与信号功率S相关：$S_{dBW}-10log(R)+228.6dBW-10logT$. （其中R为比特率，T为开尔文温度）</li><li>与频谱效率C/B相关：$E_b/N_0=\frac{B}{C}\cdot(2^{C/B}-1)$</li></ul><h1 id="CH3-传输介质"><a href="#CH3-传输介质" class="headerlink" title="CH3-传输介质"></a>CH3-传输介质</h1><h3 id="光纤的传输窗口"><a href="#光纤的传输窗口" class="headerlink" title="光纤的传输窗口"></a>光纤的传输窗口</h3><p>850nm，1310nm，1550nm</p><h3 id="天线相关"><a href="#天线相关" class="headerlink" title="天线相关"></a>天线相关</h3><ul><li>天线增益：$G=\frac{4\pi A_e}{\lambda^2}=\frac{4\pi f^2A_e}{c^2}$</li><li>波长频率和光速的关系：$f\lambda=c$</li><li>真空中光速$c=3\times10^8m/s$</li><li>全向单位增益天线的$A_e=\frac{\lambda^2}{4\pi}$</li><li>抛物面天线的$A_e=0.56A$</li><li>抛物面天线简化的增益：$G=\frac{7A}{\lambda^2}$</li></ul><h3 id="LoS传输"><a href="#LoS传输" class="headerlink" title="LoS传输"></a>LoS传输</h3><ul><li>大气散射后的传输距离：$3.57\sqrt{Kh}$，其中K经验值$\frac{4}{3}$</li><li>两天线间传输距离：$3.57(\sqrt{Kh_1}\sqrt{Kh_2})$</li></ul><h3 id="自由空间传播损耗"><a href="#自由空间传播损耗" class="headerlink" title="自由空间传播损耗"></a>自由空间传播损耗</h3><script type="math/tex; mode=display">L_{dB}=-20log(\lambda)+20log(d)+21.98, (\lambda,d单位均为m)</script><script type="math/tex; mode=display">L_{dB}=-20log(f)+20log(d)-147.56, (f单位为Hz，d单位为m)</script><h1 id="CH5-金属传输线"><a href="#CH5-金属传输线" class="headerlink" title="CH5-金属传输线"></a>CH5-金属传输线</h1><ul><li><h2 id="传输线特性参数公式总结"><a href="#传输线特性参数公式总结" class="headerlink" title="传输线特性参数公式总结"></a>传输线特性参数公式总结</h2><h3 id="相移常数"><a href="#相移常数" class="headerlink" title="相移常数"></a>相移常数</h3><ul><li>定义式：$\beta=\frac{2\pi}{\lambda}$</li><li>理想传输线，R=G=0时：$\beta = \omega\sqrt{LC}$</li><li>无无失真传输线，$R/L=G/C$，且高频下：$\beta  =j  \omega   \sqrt {LC}(rad/km)$</li></ul><h3 id="传输常数"><a href="#传输常数" class="headerlink" title="传输常数"></a>传输常数</h3><ul><li>定义式：$\gamma=\alpha+j\beta$</li><li>与传输线特征关联：$\gamma=\sqrt{(R+j\omega L)(G+j\omega C)}$</li><li>理想传输线，R=G=0时：$\gamma=j\beta=j\omega\sqrt{LC}$</li><li>无失真传输线，$R/L=G/C$或高频下：$\gamma   \approx   \frac {1}{2}   \frac {CR+GL}{\sqrt {LC}}  +<br>j\omega   \sqrt {LC}$</li></ul><h3 id="特征阻抗-Z-0"><a href="#特征阻抗-Z-0" class="headerlink" title="特征阻抗$Z_0$"></a>特征阻抗$Z_0$</h3><ul><li>定义式：$Z_0=\frac{V_x}{I_x}=\sqrt{\frac{R+j\omega L}{G+j\omega C}}$</li><li>无失真传输线或理想传输线下：$Z_0=\sqrt{\frac{L}{C}}$</li></ul><h3 id="衰减常数"><a href="#衰减常数" class="headerlink" title="衰减常数"></a>衰减常数</h3><ul><li>定义式：间隔单位距离的$V_1$和$V_2$, $V_1/V_2=e^{\alpha}$</li><li>理想传输线，R=G=0时：无衰减，$\alpha=0$</li><li>无失真传输线，$R/L=G/C$或高频下：$\alpha  =(  \frac {R}{2}   \sqrt {\frac {C}{L}}  +  \frac {G}{2}   \sqrt {\frac {L}{C}}  )(Np/km)$</li></ul><h3 id="相速度"><a href="#相速度" class="headerlink" title="相速度"></a>相速度</h3><ul><li>定义式：$v_p=\frac{\omega}{\beta}=f\lambda$</li><li>理想传输线下：$v_p=\omega/\beta =\frac{1}{\sqrt{LC}}$</li></ul><h3 id="群速度"><a href="#群速度" class="headerlink" title="群速度"></a>群速度</h3><ul><li>定义式：$v_g=\frac{d\omega}{d\beta}$</li><li>理想传输线下：$v_g=\frac{d\omega}{d\beta}=\frac{1}{\sqrt{LC}}$</li></ul></li></ul><h2 id="反射公式"><a href="#反射公式" class="headerlink" title="反射公式"></a>反射公式</h2><h3 id="电压反射系数（voltage-reflection-coefficient）"><a href="#电压反射系数（voltage-reflection-coefficient）" class="headerlink" title="电压反射系数（voltage reflection coefficient）"></a>电压反射系数（voltage reflection coefficient）</h3><ul><li>定义式：$\rho=\frac{V_r}{V_i}=\frac{I_r}{I_i}$($V_r,I_r$分别表示反射电压电流，$V_i,I_i$分别表示前进电压电流)</li><li>与 传输线特征阻抗$Z_0$ 和 负载阻抗$Z_L$ 的关系：$\rho=\frac{Z_L-Z_0}{Z_L+Z_0}$</li><li>回波损耗：$Return\ loss=20\log_{10}(\rho)$</li></ul><h3 id="电压驻波比（Voltage-standing-wave-ratio）"><a href="#电压驻波比（Voltage-standing-wave-ratio）" class="headerlink" title="电压驻波比（Voltage standing wave ratio）"></a>电压驻波比（Voltage standing wave ratio）</h3><ul><li>$S=\frac{1+|\rho|}{1-|\rho|}$</li><li>$|\rho|=\frac{S-1}{S+1}$</li></ul><h1 id="CH6-光传输线"><a href="#CH6-光传输线" class="headerlink" title="CH6-光传输线"></a>CH6-光传输线</h1><h3 id="光反射折射和NA"><a href="#光反射折射和NA" class="headerlink" title="光反射折射和NA"></a>光反射折射和NA</h3><ul><li>入射角与出射角和折射率的关系：$n_1sin(\theta_i)=n_2\sin(\theta_r)$</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240509172814675.png" alt="image-20240509172814675" style="zoom:50%;" /></p><ul><li>全反射临界角：$sin\theta_c=\frac{n_2}{n_1}$</li><li>Numerical Aperture (NA)：$NA=n_0sin(\phi_i)=\sqrt{n_1^2-n_2^2}$</li></ul><h3 id="光纤的传输损耗来源"><a href="#光纤的传输损耗来源" class="headerlink" title="光纤的传输损耗来源"></a>光纤的传输损耗来源</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240617000659152.png" alt="image-20240617000659152"></p><h3 id="光纤传输色散来源"><a href="#光纤传输色散来源" class="headerlink" title="光纤传输色散来源"></a>光纤传输色散来源</h3><ul><li>模式色散（多模主要） mode dispersion</li><li>材料色散（单模主要）material dispersion</li><li>波导色散 waveguide dispersion</li><li>偏振色散 polarization dispersion</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 电信传输理论与工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代通信网络-LC19传输层</title>
      <link href="/posts/8d8b0015.html"/>
      <url>/posts/8d8b0015.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="看来您不属于攻略组,请等待笔记验证后发布" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9eb7a4b704409383b4ad714d5af2c4498b50426366a0ca93a6bd6df6b81748e4">3624a8dbefab98d376ab749e8d6514135796b537ecc3174eaa74ea9a860fa4ff5ef13a354f6e766af7200a4cc62a7e7747ac7003a1c4cec8682db2a6a5b03d25781b44e02e4226e1e2d3be654734a013f051c31e62ff90564e7114acf4b5aaea58a5f57db061d0dd609d1d48e41613dcf9c615b41742ab8a270d8ad43ff254f89c59e17d9599eb87fa6c8251e0791a16241796552a7b0497f92af263442a036dced7c258760585029b6e3504e382ad4efd77553b05346d1b5ae7d835f88291cd8262fac0c99013bc5ae341dd2c60ce7cee54b8b75d80a805ef2d0ee3c93daa760410f0dfe33271316a6b3c6c2038658b85bab94afa043c1d6aab3f82f4b0cbb2e4c883b678dc67956cc75ff52d09c0ba1bc54db3180e5dc925359b1334fc4d60922be553252c7d56b25404b7d6c5767d71e246c18a0a3cf122aa51ef907d003da9ede04f77acb3895616f1bd5246acad4c984b1b39ba0051426818dc1bb10439f6775d5dad000f9dcbf85e64384dde5af74bcb03ad4be5c06b1ee1fde6e5a3cce2b699a14f565bb58a6ff150c64d781f10b5ed76c293fee65feef557b8d84e27106463d4438a79ec087d8ec3cba56bf915be20ac2cf577b2c26de72bab1c81c74fe2ccbcae22a53ffb754f8360942ede0d826cee4174862dd35d8dcf0b16a269495563c758c8bc13479d78e63fdc3c64825221f863e56754b312adde1bef96790c1aa2a83a532a32e48b1d694d16e70aef1e054658716cf25719d77b194797b4e4b883804b71c3742f7bac5ea52995d9b6ade8d47cea35c85d245d505e38d0a2d97a34f24f587e14fd571fdabceb7a4b2f92fd2da1eda65da079b8379b86540e54163af731745fc7303e0679e8ea8512dc597a40bed662a06ca9f66827dcc10c2fa3da667aee0f78dbccd6622512a31c1054063fd4823587a4972e7ebf58252c107d5249cca3e117e19f5bae9641f3ceb9a3dfeea8d4c81243fa765def8a6443b51bd60bb24c5ea09e51b6d26751e4043cc3c9775e5702d91c9f9715ad3d7fed26c115f6f75e04d26bc7176405afacee19d317a9d6d48b5bd53449acf4bed91bc2524501290a547ba600f9f2eb8e25674e6e7e327979cad468fc2a881714a2ec1c076d52847385ac0085c1e77167408be627b9063e0b2fe12c2109089009dacb7e2f6e32c6e4f35adf11dd03765d3ec8852a6975d1a13f0881c5461043f745fd3ef85c87c9600622fcd87bcf3dac795345fa7eb2a596c30d4ac61de3932149add2eced4bab0c9e408a275ad33d6c8f9dbdda3e49983d80aab3d232a402a6ef6abf0e081a1af7ac656b8c719670ef099e2cd8d3273bdcba23c64d86d05ac24f9a9376a578a85b334ae7071b90bd2b3808863a1e6ac936ec1cd0be4d89c9137d23b47d10f33e850b72bf4bba6801f968a41fb6a6ce381b123024d1cc649175f914ab3c3ad50d4a8267806cfd56984d78b8c8e78046174710a1fd61b37451325f6efcd5143c7fecc2b5d5e10f1fa3398595bd4d1b00638e616b4a0d2d53ace6d37483263bc8c7bd5f4b6bc5744ffa01a5798be368d0affcd3f533b4e2b31c4ae6389a8a5d5e226ade3b931dd2f0f6ef7df6e9749b60534d9568ad26269e8ce8c32bac6ef45d7ecb598ef7f55e13e5e67201d1bd664f4309fb697e49a3259f1d80d9918839dfff937445d00d7bb85c78e954ba34fb6826c08d50a80c37e4ae3dcd7d19c9765af3dc9d737af2b011a7139ad96d15b1ec99a8375cdade464e540d869899a8f387de812f7a5e0ee45a6d93d72c69dc43a17d95daf6071f262dc2bc6e0c70f5cb60bb6bdf26977e5ff755a755a227bd8bf0011b8b9f110c52604c1bee6c8f26deddb841d5f299af2f1636e27c9d2fca1c0f8c4c81bd1a2ae38b8ad13038fb2356851cf79140261ddf9bc5c14f2f72a73c2212b0dff409a8a20eac55636c0e178a04bab7de4f1bdb9f52c132d5d54ac293cbab47eeed9186d645679e111ba968b04818eac513b51ada68105446badaededae78419bf86bca07bc234eb6f4c181d14b6ab1ca3054906b799714254630afbd10e1acfa1ec68173e7108464c9f0e8bce09a8613dfadb27a93c9714506da06b044b115d5d37990c371526068ef4986fe05490719e199d22b2257f88a0a602c3fd1ab854803012e0dd62180255a3545bb3ef50b0d5259c4cf5a42211fe0b672a19076153171651136bbbac9918ecdb0a1e5fae7c8350d4e9c1a0c5e6965072c78d77a7562727e52059cde4b6db50d515a912666a757c8a8e2ed904519754997ea86a17d0f0b2f49517b0ede06b302bdc59e30690b80ee77d1247b097b61015a2d7019938ab7c21b9dd776d495fdd544fdbd4d14718d003cfda48904792ea0b6206d906db7944c650b5355c9b7aa09095e8b54e8fb354c2b5bebe9359513681431138e16a8879cd8ffefac3b5d7c476661c070870416b25b4e5722d9dded109084bf0dc8edca062f5c65d10eb46dd752663e310393a049f97bfa73a5e1a51a078290af4dc54af435ced210f13eed67669ff2ede0dbed9cc50551213582b9da7209f7cdc3c246d2ec94965d4d629a2e3e312018614f3cbfed9ad5a959e4325798366a5dcbbb3f2fdd426e7a489d9570213b8b16fe31cca9372fb5643a8ac3ca67c66f28ec73d0069a2019ee6c7082476bd0b29ddef879cde61f9d2b101a32d205a16c4c08373c93eabb14c1ce79948691172519ba9f0c7373ecefc72c7f8c299a3b6107acc7c9e16a24be6bd3c16a7ab0da5cb4e5f6f77ba2b5dabb3b01d734a93ec188564695a41d6a6a0e833c7082b0d6199fb77d519924b1893309bba1ee1b71ab36ac52a303723b3a329c726bd491234cc44d1f6d12aa43e3fd4107841efe1e9b309e23b1a3c23f9ac5aa900c85e9a79bfb0a393ec7bcb476ef3dcba2e91af3df3ef21bfb36132ab30c9a00fe8cbca981b0799da37e0433a7aa8b0e7392d5d9b1638e4359fc10c1c715fa25b51f2bda692ae39f8472d89a0d2ce42e388cd2fe0c9167a0271579c57bea86b5e42ea19880aec742b7a21aea2f5e2af8f7b8f12e269d39498a28603c615a81f0a4aac1568abb068acbdf70f3e8b231040c88ca5b6a3e3d0482d250badc3955301c22fd1c2533a29f73f1391ad90884633a6c11a51104f0a0fff1ddd812200b77b17c6cb4bfee49f34933ac2b8683230cfd6872145df62fcda4da5ac2394b35ca24d542a35c92ed2e8432b461d0bd62dd41</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">阿尔戈在迷宫区搜集到的零碎攻略信息,还在整理...</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 现代通信网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代通信网络-Ch17-网络层</title>
      <link href="/posts/f3f7fc88.html"/>
      <url>/posts/f3f7fc88.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>本节对应中文书第四章</p></div><div class="note info flat"><p>为什么网络物理上的传输是用的MAC地址，而还需要IP地址？</p><p>因为MAC理论作用于局域网内，局域网上理论上是通过广播的形式在寻找通信的对象。而IP地址是可以进行路由的，只有第一次时，需要广播寻找它在哪，后续的通信便可以记住。这样才能实现局域网“来去自由”。</p><p>而且，有一些设备的硬件地址不一样，为了使得异构网络能够统一地联通，需要使用IP地址。</p></div><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p>IP地址会给互联网上的每一个主机，路由器的每一个接口，都分配一个IP地址。</p><h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240605164819310.png" alt="image-20240605164819310"></p><p>IP地址被划分为了ABCDE五类，其中ABC三类为单播地址（一对一通信），是最常用的。在ABC三类中，前8 16 24位是网络号。网络号的前三位是类别号，用于区别其是哪一类。D类地址一般用于多播（一对多通信）。</p><p>在最初的时候，网络号的目的就是区分各个局域网。但是后面IP地址不够用了，因此产生了虚拟网（后面会讲，这里只需要知道网络号现在不完全是用来区分局域网的）。同一局域网上的主机或者路由IP地址中，网络号号段必须一样。</p><p>主机号由局域网内自己分配。</p><h2 id="子网掩码-subnet-masking"><a href="#子网掩码-subnet-masking" class="headerlink" title="子网掩码(subnet masking)"></a>子网掩码(subnet masking)</h2><p>由于两级IP地址不够灵活，在主机号的基础上，还可以再从主机号内借用若干比特来划分一段子网号(subnet-id)，来更精细化地分配局域网内的资源（三级编址）。在划分和子网后，在使用网络号进入网络后，会先使用子网号进入子网，再在子网内寻找主机。</p><p>子网掩码：子网掩码就是用来区隔主机号和子网号的，它将主机号全部用0表示。这样路由在寻找子网的时候，将子网掩码与ip地址进行与运算，即可抹去主机号，定位子网。例如<code>255.255.255.0</code>，就只保留最后8位作为主机号，前面的作为子网号。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240607141510368.png" alt="image-20240607141510368"></p><h2 id="无分类IP地址-CIDR"><a href="#无分类IP地址-CIDR" class="headerlink" title="无分类IP地址 CIDR"></a>无分类IP地址 CIDR</h2><div class="note info flat"><p>在2011年2月3日，IANA宣布IPv4地址已经全部耗尽。为了解决这个问题，IETF专门成立了IPv6研究工作组。</p></div><p>B类IP地址在1992年就已经分配了一半，眼看就要快分完了。同时，互联网主干网上路由表的项目数正在急剧增长。为了解决这个问题，IETF研究处了无分类编址，正式名称是无分类域间路由选择（Classless Inter-Domain Routing, CIDR）。</p><h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>CIDR消除了传统的ABC类地址划分和子网的概念。CIDR把32位的IP地址划分为前后两个部分。前面部分是“网络前缀”(network-prefix)，用来指明网络，后面部分则用来指明主机。因此CIDR使IP地址从三级编址(使用子网掩码)又回到了两级编址（只不过现在没有分类来指定网络号长度了）。下图是CIDR下的IP结构。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240607142055089.png" alt="image-20240607142055089" style="zoom:50%;" /></p><p>CIDR使用斜线记法来划分前后两段：IP地址后面的斜线，例如<code>192.168.1.1/24</code>, 表示前24位是网络号，后8位是主机号。类似于子网掩码，CIDR使用地址掩码（address mask）来方便与运算提取地址，例如/24的地址掩码就是255.255.255.0；由于部分网络还在使用子网掩码，因此CIDR的地址掩码在一些地方也被称为子网掩码。</p><p>如果用户想要，还可以在CIDR区隔开的主机号内，分出来几位，用来标记网络号。例如192.168.1.1/20, 主机号有8位，可以分隔出3位来作为网络号。</p><p>三个特殊的CIDR长度：</p><div class="table-container"><table><thead><tr><th style="text-align:center">网路前缀长度</th><th style="text-align:center">地址掩码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">/32</td><td style="text-align:center">255.255.255.225</td><td style="text-align:center">就是一个IP地址。用于主机路由</td></tr><tr><td style="text-align:center">/31</td><td style="text-align:center">255.255.255.254</td><td style="text-align:center">只有两个IP地址，主机号为0和1，用于点对点通信</td></tr><tr><td style="text-align:center">/0</td><td style="text-align:center">0.0.0.0</td><td style="text-align:center">默认路由</td></tr></tbody></table></div><h3 id="路由聚合-route-aggregation"><a href="#路由聚合-route-aggregation" class="headerlink" title="路由聚合(route aggregation)"></a>路由聚合(route aggregation)</h3><p>在CIDR工作模式下，</p><h2 id="网际控制报文协议ICMP（网络层）"><a href="#网际控制报文协议ICMP（网络层）" class="headerlink" title="网际控制报文协议ICMP（网络层）"></a>网际控制报文协议ICMP（网络层）</h2><p>网际控制报文协议（Internet Control Message Protocol, ICMP）:这是一个差错报告机制，属于网络层协议，被封装在IP packet内。主要用于在IP主机和路由器之间<strong>传递控制消息</strong>，用于报告主机是否可达、路由是否可用等。这些控制消息虽然并不传输业务数据，但是对于收集各种网络信息、诊断和排除各种网络故障以及用户数据的传递具有至关重要的作用。</p><p>下图是ICMP报文，可以看到，ICMP报文是作为IP包的Payload存在的。因此ICMP并不属于TCP或者UDP中的任意一种，是网络层里面的控制信令一般的存在。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240607143457986.png" alt="image-20240607143457986" style="zoom:67%;" /></p><p>(上图的格式不要求背，大概了解就行)</p><ul><li>Type字段表示ICMP消息的类型</li><li>Code字段表示ICMP消息类型细分的子类型；</li></ul><p>下图是ICMP支持的报文（了解即可）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240607144255971.png" alt="image-20240607144255971"></p><p>一个典型的例子就是<code>ping</code>指令。<code>ping</code>通过使用ICMP报文来检查对象ip地址是否可达。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.1.1</span><br></pre></td></tr></table></figure><h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h2><p>在了解格式之间，首先需要了解MTU：</p><h3 id="最大传输单元MTU"><a href="#最大传输单元MTU" class="headerlink" title="最大传输单元MTU"></a>最大传输单元MTU</h3><p>在IP层下面的每一种数据链路层协议都规定了一个数据帧中的数据字段的最大长度，这称为最大传送单元 MTU(Maximum Transfer Unit)。当一个 IP 数据报封装成链路层的帧时，此数据报的总长度(即首部加上数据部分)一定不能超过数据链路层所规定的 MTU值。例如，最常用的以太网就规定其MTU值是1500字节。若所传送的数据报长度超过数据链路层的 MTU 值，就必须把过长的数据报进行分片处理。</p><p>IP包头内有几个字段都和MTU有关系。</p><h3 id="IP数据报的格式-1"><a href="#IP数据报的格式-1" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h3><p>在TCP/IP标准中，各种数据格式以4字节(32bit)为单位描述。下图是IP数据报的完整格式</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240607150020957.png" alt="image-20240607150020957" style="zoom:67%;" /></p><ul><li><strong>版本：</strong>占4位，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4(即IPv4)。</li><li><strong>首部长度：</strong>占4位。首部长度字段所表示数的单位是32bit(即，首部长度为1表示长32位，4字节)。因为IP首部的固定长度是20字节，因此首部长度字段的<strong>最小值是5</strong>(即二进制表示的首部长度是0101)。设置更长的首部长度会扩充可选字段部分。<strong>当想要添加的首部长度不是4字节的整数倍时，必须用填充字段加以填充。</strong>因此IP数据报的数据部分永远在4字节的整数倍时开始，这样在实现协议时较为方便。首部长度限制为60字节的缺点是有时可能不够用.但这样做是希望用户尽量减少开销.最常用的首部长度是20字节。</li><li><p><strong>区分服务：</strong>占8位，这是一种保证QoS的字段。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998年年IETF把这个字段改名为区分服务DS（Differentiated Services）。</p></li><li><p><strong>总长度：</strong>总长度指首部和数据之和的长度，<strong>单位为字节</strong>。单一IP包最多传输$2^{16}=65536$字节</p></li><li><p><strong>标识（identification）：</strong>当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</p></li><li><p><strong>标志（flag）：</strong>占3位，仅前两位有意义。标志字段中的最低位记为MF(More Fragment)，MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个；标志字段中间的一位记为 DF(Don’t Fragment)，意思是“不能分片”，只有当 DF=0时才允许分片。</p></li><li><p><strong>片偏移：</strong>占13位。片偏移指出:较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以<strong>8个字节</strong>为偏移单位。这就是说，每个分片的长度一定是8字节(64位)的整数倍。下图是一个切片例子：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240607153618274.png" alt="image-20240607153618274"></p></li><li><p><strong>生存时间（TTL）：</strong>占8位，生存时间字段常用的英文缩写是TTL(Time To Live)，表明这是数据报在网络中的寿命.由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子(例如从路由器$R_1$，转发到$R_2$，再转发到$R_1$；，然后又转发到$R_2$，因而白白消耗网络资源。最初的设计是以秒作为TTL值的单位；后面随着技术发展，路由转发时间大大缩短，因而改为跳数限制：<strong>若数据报在路由器消耗的时间小于1秒，就把TTL值减1，这也就相当于是跳数限制</strong>。<strong>当TTL值减为零时，就丢弃这个数据报。</strong></p></li><li><p><strong>协议：</strong>占8位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个协议进行处理。常见协议如下图</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240607153337199.png" alt="image-20240607153337199"></p><ul><li><strong>首部检验和：</strong>占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和(一些字段，如生存时间、标志、片偏移等都可能发生变化)。</li></ul><h1 id="互联网的路由协议"><a href="#互联网的路由协议" class="headerlink" title="互联网的路由协议"></a>互联网的路由协议</h1><div class="note danger flat"><p>五星级，这部分中路由算法不在这门课的要求，但路由协议是重点。</p></div><h2 id="内部网关协议RIP（重点！）"><a href="#内部网关协议RIP（重点！）" class="headerlink" title="内部网关协议RIP（重点！）"></a>内部网关协议RIP（重点！）</h2><h3 id="如何工作-1"><a href="#如何工作-1" class="headerlink" title="如何工作"></a>如何工作</h3><p>RIP(Routing Information Protocol)：是内部网关协议 IGP 中最先得到广泛使用的协议，它的中文名称叫做路由信息协议，但很少被使用。RIP是一种<strong>分布式</strong>的基于距离向量的<strong>路由选择协议</strong>，是互联网的标准协议，其最大优点就是简单，但不适用于大规模应用，因此只是内部网关协议。</p><p><strong>RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。</strong></p><ul><li>若左手是一个网络，右手是一个网络，中间使用路由器连接；即，使用路由器直连两个网络，距离定义为1</li><li>若网络间由多个路由器连接，距离为路由器数量+1；例如 NetworkA—路由1—路由2—路由3—NetworkB 距离是4.</li></ul><p>RIP定义的这个距离，也称为<strong>跳数（hop count）</strong>。RIP认为跳数越少，路由路径越好；尽管有路由转发速度更快效率更高的路由，RIP也不会选择。<strong>RIP最大允许通过15跳，若跳数为16，则理解为不可达。</strong>因此RIP仅适用于小型网络。</p><div class="note info flat"><p>在有的教材中，也称直连网络的距离为0为不可达。这个和定义为1的差异不大。</p></div><p>RIP的特点：</p><ul><li>仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。</li><li>路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的<strong>路由表+需要几跳</strong>。也就是说，交换的信息是:“我到本自治系统中所有网络的(最短)距离，以及到每个网络应经过的下一跳路由器”</li><li>按固定时间交换刷新路由信息，时间可自定义。</li></ul><p>路由器在刚开始工作的时候，路由表是空的；第一时间它会得出直连网络的信息（距离为1的网络）；然后它会收到来自其他路由的RIP信息，也记录在自己的路由表上。下一次它对外同步自己的路由表时，就可以携带别人告诉它的RIP信息。经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。</p><p>下面是一个详细的例子：</p><ul><li>现在你CQUPT，上新街告诉你：你到解放碑可以经过我，我这里1跳后到达。此时CQUPT知道，去解放碑需要2跳（你就坐吧，坐上了346到黄角垭下车这辈子都完了）</li><li>此时，如果CQUPT发现自己的路由表没有解放碑，那就把解放碑添加到自己路由表；</li><li>如果CQUPT发现自己校门口打个车就可以去解放碑（即，只需要1跳），那么什么也不做（也就是距离更大了，不予更新）；</li><li>如果CQUPT记录的是四公里路由-2跳到解放碑，则把去往解放碑的路由表拿路由上新街的信息覆盖掉。</li><li>如果CQUPT发现之前上新街发过一次RIP信息给自己，现在又发了一次，则不管这次跳数变多还是变少，都直接覆盖上次的信息（同一路由发过来了新的数据，更新信息）。</li><li>如果3分钟还没有收到相邻路由器更新路由表，则将该路由器标记为不可达，即16跳。</li></ul><p>RIP报文使用UDP封包，因为TCP的三次握手消耗资源太大。下图是其包格式。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240612173559766.png" alt="image-20240612173559766"></p><h3 id="RIP存在的特殊问题"><a href="#RIP存在的特殊问题" class="headerlink" title="RIP存在的特殊问题"></a>RIP存在的特殊问题</h3><p>RIP 存在的一个问题是当网络出现故障时，<strong>要经过比较长的时间才能将此信息传送到所有的路由器</strong>。我们可以用下图简单例子来说明。设三个网络通过两个路由器互连起来，并且都已建立了各自的路由表。图中路由器交换的信息只给出了我们感兴趣的一行内容。路由器R1中的“1，1，直接”表示“到网1的距离是 1，直接交付”。路由器R2中的“1，2,R1,”表示“到网1的距离是 2，下一跳经过 R1”。<br>现在假定路由器R1,到网1的链路出了故障，R1无法到达网1。于是路由器R把到网1的距离改为16(表示到网1不可达)，因而在R1的路由表中的相应项目变为“1，16,直接”。但是，很可能要经过 30 秒钟后 R1才把更新信息发送给R2。然而 R2,可能已经先把己的路由表发送给了R1，其中有“1，2，R1,”。</p><ul><li>R1收到 R2的更新报文后，误认为可经过 R2到达网 1，于是把路由信息修改为:“1，3，R2”，表明“我到网1的距离是 3，下一跳经过R2”，并把更新后的信息发送给 R2。</li><li>同理，R2接着又更新自己的路由表为“1,4,R1,”，以为“我到网1距离是 4，下一跳经过 R1”。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240612174351774.png" alt="image-20240612174351774"></p><p>这种现象我们称之为错误消息洪泛，这是RIP收敛性不好的原因。</p><h2 id="开放最短路优先OSDF"><a href="#开放最短路优先OSDF" class="headerlink" title="开放最短路优先OSDF"></a>开放最短路优先OSDF</h2><p>OSPF(Open Shortest Path First)：这个协议的名字是开放最短路径优先。它是为克服 RIP的缺点在 1989年开发出来的。OSPF的原理很简单，但实现起来却较复杂。“开放”表明OSPF 协议不是受某一家厂商控制，而是公开发表的。“最短路径优先”是因为使用了Dijkstra提出的最短路径算法SPF。</p><p>OSPF使用分布式链路状态协议(link state protocol)，即不像RIP那样用距离来衡量路由选择，而是一整个链路状态。</p><ul><li>OSPF在同步链路状态信息时，使用洪泛法(flooding)。路由器通过所有输出端口向所有相邻的路由器发送信息，每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。而RIP 协议是仅仅向自己相邻的几个路由器发送信息。</li><li>这个发送的链路状态信息，可能包含费用，距离，时延，带宽等等（包含什么可自定义）。这些被称为“度量(metric)”，有时也把它称为“代价”。</li><li>只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。而不像RIP那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。</li><li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库(链接状态数据库)，这个数据库实际上就是全网的拓扑结构图.这个拓扑结(构图在全网范围内是一致的(这称为链路状态数据库的同步)</li></ul><h2 id="边界网关协议BGP（了解）"><a href="#边界网关协议BGP（了解）" class="headerlink" title="边界网关协议BGP（了解）"></a>边界网关协议BGP（了解）</h2><p>由于互联网的规模太大，使得自治系统之间（不同网络之间）的路由选择非常困难。连接在互联网主干网上的路由器，必须对任何有效的IP地址都能在路由表中找到匹配的目的网络。然而，目前互联网的主干网路由器中，一个路由表的项目数早已超过了5万个网络前缀。如果使用链路状态协议，则每一个路由器必须维持一个很大的链路状态数据库。</p><div class="note info flat"><p>对应《计算机网络》谢希仁 (第7版) 4.8章</p></div><h1 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>由于IP地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。而且考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。</p><p>假定在一个机构内部的计算机通信也是采用TCP/IP协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其IP地址.这就是说，让这些计算机使用仅在本机构有效的IP地址(这种地址称为本地地址)，而不需要向互联网的管理机构申请全球唯一的IP地址(这种地址称为全球地址)。这样就可以大大节约宝贵的全球IP地址资源。</p><p>但是，如果任意选择一些IP地址作为本机构内部使用的本地地址，那么在某种情况下可能会引起一些麻烦。例如，有时机构内部的某台主机需要和互联网连接，那么这种仅在内部使用的本地地址就有可能和互联网中某个IP地址重合，这样就会出现地址的二义性问题。</p><p>为了解决这一问题，RFC 1918指明了一些专用地址(private address)。这些地址只能用于一个机构的内部通信，而不能用于和互联网上的主机通信。换言之，专用地址只能用做本地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。</p><ul><li>10.0.0.0~10.255.255.255 (或记为10.0.0.0/8，它又称为24位块)</li><li>172.16.0.0~172.31.255.255 (或记为172.16.0.0/12，它又称为20位块)</li><li>192.168.0.0~192.168.255.255 (或记为192.168.0.0/16，它又称为16位块)</li></ul><p>采用这样的专用地址的互连网络称为专用互联网或本地互联网，或更简单些，就叫做专用网。显然，全世界可能有很多的专用互连网络具有相同的专用IP地址，但这并不会引起麻烦，因为这些专用地址仅在本机构内部使用.专用IP地址也叫做可重用地址(可重复使用的地址)。</p><h2 id="NAT技术"><a href="#NAT技术" class="headerlink" title="NAT技术"></a>NAT技术</h2><p>网络地址转换 NAT (Network Address Translation)：NAT规定路由器至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址。这种方法需要在专用网连接到互联网的路由器上安装NAT软件 （被称为NAT路由）。</p><p>举个例子：专用网内部的主机A发往互联网上主机B的IP数据报:源IP地址是<code>192.168.0.3</code>，而目的IP地址是<code>213.18.2.4</code>。NAT路由器把IP数据报的源IP地址 <code>192.168.0.3</code>，转换为公网IP地址<code>172.38.1.5</code>，然后转发出去。因此，主机B收到这个IP数据报时，以为A的IP地址是 <code>172.38.1.5</code>。当B给A发送应答时，IP数据报的目的IP地址是NAT路由器的IP地址 <code>172.38.1.5</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240614144432765.png" alt="image-20240614144432765"></p><p>此时，如果内网只有一个用户，那所有通信都来源于这个用户，没有问题。但是，如果内容有多个用户，那应该如何区分返回到<code>172.38.1.5</code>IP的数据报是要发给内网哪个机器的？这是用TCP层内的port number （这是TCP运输层的地址）来区分的。在出去时，把IP换成公网IP，并映射一个对应的端口号给这个包。在返回回来时，使用端口号来区分用户。</p><p>这要求NAT路由器也要维护一张表，表内包含  内网IP，Port ID； 外网IP，Port ID</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/1718348775401.jpg" alt="1718348775401" style="zoom: 10%;" /></p><p>这样使用端口的NTA也叫做NAPT （Network Address and Port Translation）。不使用端口的NAT被称为传统NAT。</p>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 现代通信网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Control Systems Part1-2&amp;3-频率响应分析法:几种图像和渐进法绘制波德图</title>
      <link href="/posts/c235a86e.html"/>
      <url>/posts/c235a86e.html</url>
      
        <content type="html"><![CDATA[<h1 id="波德图-（Bode-plot）"><a href="#波德图-（Bode-plot）" class="headerlink" title="波德图 （Bode plot）"></a>波德图 （Bode plot）</h1><h2 id="引入-什么是波德图"><a href="#引入-什么是波德图" class="headerlink" title="引入-什么是波德图"></a>引入-什么是波德图</h2><p>波德图是一种用于体现系统<strong>开环传输函数(open loop transfer function)</strong>频率响应的图。波德图一般是由二张图组合而成，一张<strong>幅频图</strong>（幅度通常以dB为单位），一张<strong>相频图</strong>（相位通常以degree 为单位），两图都采用对数形式的横坐标（频率轴，单位rad/sec）。下图是一个波德图的例子</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240618195336441.png" alt="image-20240618195336441"></p><h2 id="采样法画波德图"><a href="#采样法画波德图" class="headerlink" title="采样法画波德图"></a>采样法画波德图</h2><h3 id="幅频图"><a href="#幅频图" class="headerlink" title="幅频图"></a>幅频图</h3><ol><li>将$s=j\omega$代入求开环传输函数的幅频响应 $|H(s)|$（拉普拉斯变换$s=\sigma+j\omega,\ \sigma=\ 0$ 就等效于傅里叶变换了，详见信号与系统-拉普拉斯变换）</li><li>将其转换为对数形式（$20log\left(\left|H\left(j\omega\right)\right|\right)$）</li><li>变化频率$\omega$计算输出得到幅频图。（注：$|H(j\omega)|$就是开环传输函数在复平面的模长，也就是$\sqrt{\left(Real^2+Img^2\right)}$）</li></ol><h3 id="相频图"><a href="#相频图" class="headerlink" title="相频图"></a>相频图</h3><p>依旧代入s=j\omega，求开环传输函数的相频响应$angle(H(j\omega))$。具体步骤如下：</p><ol><li>分别求得开环传输函数的实部和虚部，将其画在复平面上</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240618195655651.png" alt="image-20240618195655651"></p><ol><li>如果开环传输函数落在第一、四象限：$\phi=arctan\left(\frac{Im}{Re}\right)$，注意这里 Im 和 Re 不是绝对值，要带符号的！</li><li>如果开环传输函数落在第二象限：$\phi=\pi-arctan\left(\frac{\left|Im\right|}{\left|Re\right|}\right)$，或是$\phi=\pi+arctan\left(\frac{Im}{Re}\right)$，因为这里Im一定是正，Re一定是负，因此二式等效。</li><li>如果开环传输函数落在第三象限：$\phi=arctan\left(\frac{\left|Im\right|}{\left|Re\right|}\right)-\pi$</li></ol><p>(这一部分就是复变函数里面复数角度主值的求法)</p><p>形象一点来说这个相位角就是，一二象限为正，三四象限为负，<strong>取开环传输函数向量到正半Re轴的角度</strong>。至此，得到相频图。</p><p>幅频图和相频图可以叠加在一张图上，也可以分开作图。</p><div class="note info flat"><p>到这里可以发现，画幅频图和相频图需要变化$\omega$进行扫频操作。这个由人来画是非常困难的，后面会介绍更友好的渐近线画法（非常重要）。在MATLAB中，可以使用函数<code>bode()</code>来绘制波德图。</p></div><h2 id="系统函数不同成分对幅频、相频图的影响"><a href="#系统函数不同成分对幅频、相频图的影响" class="headerlink" title="系统函数不同成分对幅频、相频图的影响"></a>系统函数不同成分对幅频、相频图的影响</h2><h3 id="积分和微分"><a href="#积分和微分" class="headerlink" title="积分和微分"></a>积分和微分</h3><p>Recall——拉普拉斯变换的时域积分性质：</p><script type="math/tex; mode=display">\bigg(\int_{0^-}^{t}\bigg)^nf(t)\leftrightarrow \frac{1}{s^n}F(s)</script><p>Recall——拉普拉斯变换的时域微分性质，若$f(t)$为因果信号，则有：</p><script type="math/tex; mode=display">f^{(n)}(t)\leftrightarrow s^nF(s)</script><p>因此，我们把函数函数分母含有孤立的s称为积分器，把分子含有孤立的s称为微分器。</p><p>现在假设一个系统传输函数有一个微分器或积分器，把它分离出来，可以写成</p><script type="math/tex; mode=display">G(s)=s^{\pm1}G'(s)</script><p>其中$G’(s)$表示剥离和积分器或者微分器的传输函数；$s^{\pm1}$的-1和+1分别代表微分器和积分器。</p><h4 id="（1）积分或微分对幅频图像的影响"><a href="#（1）积分或微分对幅频图像的影响" class="headerlink" title="（1）积分或微分对幅频图像的影响"></a>（1）积分或微分对幅频图像的影响</h4><p>在采样法画波德图中提到，幅频需要将其转化为$20log\left(\left|H\left(j\omega\right)\right|\right)$后计算结果。不妨将$s^{\pm1}G’(s)$代入 (这里面$s=j\omega$频率都为正)，来将积分器或微分器对幅频图的影响剥离开。可以发现：</p><script type="math/tex; mode=display">20log(|H(j\omega)|)=20log(|s^{\pm 1}G'(s)|)=20log(s^{\pm1})+20log(|G'(s)|)</script><p>也就是说，对于积分器，其会带给幅值一个$-20log(s)$的减少；而微分器会给幅值带来$20log(s)$的增加。那么这个加减量和频率的关系是怎么样的呢？将频率代入：$20log(\omega)$</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240618205925097.png" alt="image-20240618205925097"></p><p>此时可以发现，频率每增加10倍，幅值上升或下降20dB，因此：</p><ul><li><strong>积分器$\frac{1}{s}$对幅值的影响是-20dB/decade</strong></li><li><strong>微分器s对幅值的影响是+20dB/decade</strong></li><li><strong>有几个微分器或者积分器，就叠加几次；例如有两个微分器，就是-20dB/decade+(-20dB/decade)=-40dB/decade</strong></li></ul><h4 id="（2）积分或微分对相频图的影响"><a href="#（2）积分或微分对相频图的影响" class="headerlink" title="（2）积分或微分对相频图的影响"></a>（2）积分或微分对相频图的影响</h4><p>考虑一个只有微分器或者积分器的系统，也就是说它的实部为0，虚部由微分器或积分器引入：</p><ul><li>微分器系统内$虚部=j\omega$，实部等于0，因此向量在正虚轴上，相位为$+90\degree$</li><li>微分器系统内$虚部=\frac{1}{j\omega}=j\frac{1}{-\omega}$，因此向量在负虚轴上，相位为$-90\degree$</li></ul><p>如果系统内有多个积分器或微分器，他们会互相约掉，只留下最多的；例如假设有2个积分器4个微分器，$\frac{1}{s^2}{s^4}=s^2$，此时$虚部=j\omega^2$因此在正虚轴上，相位为$+90\degree$；</p><p><strong>换句话说，如果微分占主导，则为$+90\degree$；如果微分占主导，则为$-90\degree$</strong></p><p>下图分别展示了微分器（左）积分器（右）的影响。</p><table>    <tr><td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240618212004389.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240618212013671.png"></center></td>    </tr></table><h3 id="增益"><a href="#增益" class="headerlink" title="增益"></a>增益</h3><p>增益只作用于传输函数的分子，是一个常数项，用K表示。例如$\frac{K}{s+1}$。如果把这个K提出来，可以理解为将系统$\frac{1}{s+1}$的结果放大了K倍。将增益从传输函数内剥离：</p><script type="math/tex; mode=display">G(s)=KG'(s)</script><p>同样地，$G’(s)$表示剥离了增益剩下的传输函数。</p><h4 id="（1）对幅频图而言"><a href="#（1）对幅频图而言" class="headerlink" title="（1）对幅频图而言"></a>（1）对幅频图而言</h4><p>（在下面默认增益为正）</p><script type="math/tex; mode=display">20log(|H(j\omega)|)=20log(|KG'(s)|)=20log(K)+20log(|G'(s)|)</script><p>所以，增益对幅频图而言，<strong>会将其整体抬升$20log(K)$</strong></p><h3 id="2-对相频图而言"><a href="#2-对相频图而言" class="headerlink" title="(2) 对相频图而言"></a>(2) 对相频图而言</h3><p>增益的影响并不会改变虚部和实部的比例，因此它的相频图无影响</p><h3 id="一阶系统"><a href="#一阶系统" class="headerlink" title="一阶系统"></a>一阶系统</h3><p>一个一阶系统的s域表示是$(Ts+1)^{\pm 1}$。我们还是将其从一个传输函数内剥离开，和前面一样的思想，这里就不重复了。</p><h4 id="1-对幅频图而言"><a href="#1-对幅频图而言" class="headerlink" title="(1)对幅频图而言"></a>(1)对幅频图而言</h4><script type="math/tex; mode=display">20log(|(Ts+1)^{\pm1}|)=\pm20log(\sqrt{(\omega T)^2+1^2})</script><ul><li>当$(\omega T)^2$很小时，可以近似忽略掉它，<strong>认为其对幅值的影响为0</strong>；这个很小的界限是$\omega&lt;&lt;1/T$，在这里为了方便就取$\omega&lt;1/T$。我们将$\frac{1}{T}$称为Break frequency 或 corner frequency；</li><li>当$(\omega T)^2$很大时，可以近似忽略掉1，认为其对幅值的影响是$\pm 20log(\omega T)=\pm[20log(\omega)+20log(T)]$。这以引入里面那个波德图举例，因为T一般小于1，因此$20log(T)$一般为负值，代入$-[20log(\omega)+20log(T)]$相当于加了一点增量，这就是引入里面那个图在下降点附近有略微抬升的原因，即，高阶系统需要对谐振频率进行抬升补偿的原因。<strong>因为近似法只是求个大概，因此这里忽略这个20log（T）</strong>。因此当$\omega&gt;1/T$时，认为其和积分器一样，<strong>提供20dB/decade 的上升或下降</strong>。</li></ul><div class="note info flat"><p>PPT下面会介绍二阶系统的谐振频率补偿，后面不会用，笔记省略了，但是这里展示了为什么会产生谐振峰值振幅。</p></div><h4 id="（2）对相频图而言"><a href="#（2）对相频图而言" class="headerlink" title="（2）对相频图而言"></a>（2）对相频图而言</h4><ul><li>对于$(Ts+1)^{1}$，在$s=j\omega$很小时，几乎由实部1占据主导，因此其相位是$0\degree$；而当$s$大到一定程度，虚部会慢慢发力，会慢慢将相位拉到90°。认为这个很小的界定点是$s=\frac{T}{10}$，认为很大的界定点是$s=10T$。这刚好是2个decade变化90度，因此斜率为$45\degree/decade$</li><li>同理，对于$(T_s+1)^{-1}$，在$s=j\omega$很小时，其相位是$0\degree$；而当$s$大到一定程度，会慢慢将相位拉到-90°。斜率为$-45\degree/decade$</li></ul><p>分别如下面2图所示</p><table>    <tr><td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619002641518.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619002700515.png"></center></td>    </tr></table>## 使用渐进法绘制波德图<div class="note info flat"><p>PPT上有一种先分别画出微（积）分器、增益、一阶系统三者波德图，再将其叠加的方法（相当于分别考虑其三者对幅度和相位的影响，再叠加在一起），但是这种方法不好用，就不在这里详细介绍了，看懂了上面的推导应该可以轻易看懂PPT上的叠加法。</p></div>对于任意一个n阶系统，它都可以拆分成多个一阶系统和积分器，微分器的组合。让我们来对上面的积/微分器，增益K，一阶系统函数对幅频图和相频图的影响结合起来做一个归纳：<div class="note danger flat"><p>五星级归纳和五星级起始幅度相位确定</p></div>### 对幅频图的归纳- 当传输函数分子有孤立的s时，会对幅频图贡献+20dB/decade的上升；- 当传递函数分子有一阶系统时$Ts+1$时，在$\frac{1}{T}$点后它会贡献20dB/decade的上升；- 当传递函数分母有孤立s时，会对幅频图贡献-20dB/decade的下降；- 当传递函数分母有孤立一阶系统$\frac{1}{Ts+1}$时，在$\frac{1}{T}$点后它会贡献-20dB/decade的下降；- 当出现增益K时，对全频段提供$+20log(K)$的抬升可以发现对于$\frac{1}{Ts+1}$，$s_{root}=-\frac{1}{T}$；对于$Ts+1$，$s_{zero}=-\frac{1}{T}$。此时结合一下一阶系统和传递函数的斜率贡献，可以再次归纳为这几点- 传递函数的零点$+20dB/decade$的斜率；在原点的零点（微分器）会提供初始斜率，其他零点在$-s_{zero}$频率后开始提供- 传递函数的极点提供-20dB/decade的斜率；在原点的极点（积分器）会提供初始斜率，其他零点在$-s_{zero}$频率后开始提供### 对相频图的归纳- 当传输函数分子有孤立的s时，会对相频图+90°的初始相位；- 当传递函数分子有一阶系统时$Ts+1$时，在$0.1T$点后它会贡献45°/decade的上升，上升到$10T$点或触及90°后结束；- 当传递函数分母有孤立s时，会对幅频图贡献-90°的初始相位；- 当传递函数分母有孤立一阶系统$\frac{1}{Ts+1}$时，在$0.1T$点后它会贡献-45°/decade的下降，下降到$10T$点或触及-90°后结束；- 当出现增益K时，不会影响相位### 确定起始幅度和相位（在手绘波德图时，一般以$\omega=0.1$做为起始频率，记录为$\omega_0$，当然这也可以是0.2，1等等值）**（1）起始幅度**不难看出，一阶系统无法在起始点直接做出幅度贡献，因此起始点的幅度由K主导决定，再算上0-0.1这个区间内积分器或微分器贡献的。因此，记原点处零点个数为$N_z$,极点个数为$N_p$，再记$N_o=N_z-N_p$。起始点幅度可以表示为：$$20logK+20N_olog(\omega_0)$$**(2) 起始相位**由上面相位归纳可以看出，起始点相位只有积分器或者微分器贡献相位。如果分母的孤立s占主导，则为-90°；如果分子孤立s占主导，则为+90°；如果二者可以约掉，则为0°；### 根据归纳绘制波德图此时便可以根据以上归纳对波德图进行绘制了。如下例：对于单位负反馈系统$$G(s)=\frac{2s}{0.1s+1}$$极点有：-10；零点有0；幅频图：在一开始，只有零点贡献+20dB/decade；到达10之后，有极点贡献-20dB/decade，与零点的贡献叠加后为0dB/decade；同时，起始点代入起始点公式$20logK+20N_olog(\omega_0)$，算出$20log(2)+20\times(1-0)log(0.1)=-14dB$![image-20240619102439434](https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619102439434.png)相频图：可以看到这个系统函数在原点处分子孤立s占主导，那么就是微分器贡献的+90°相位；在1时分母极点开始发力，提供-45°/decade的斜率，一直到100结束。![image-20240619104259076](https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619104259076.png)## 幅值裕度(Gain margin)&相位裕度(phase margin)### 定义- **幅度穿越频率（Gain crossover frequency）：**指幅频图 **幅度与0dB的交点**的频率- **相位穿越频率（Phase crossover frequency）:**指相频图 **相位与-180°交点的**频率<img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619110025998.png" alt="image-20240619110025998" style="zoom:80%;" />- **幅值裕度（gain margin，GM）**：0dB与 在 相位穿越频率对应的幅度值 的差值，即：$0dB-Magitude(\omega_{phase\ crossover\ frequency})$- **相位裕度（phase margin，PM）**幅度穿越频率对应的相位 与 -180° 的差值，即：$Phase(\omega_{magitude\ crossover\ frequency})-(-180\degree)$=$Phase(\omega_{magitude\ crossover\ frequency})+180\degree$![image-20240619110100396](https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619110100396.png)### 幅值裕度、相位裕度与稳定性的关系<div class="note danger flat"><p>五星级关系</p></div>- 如果幅值裕度和相位裕度都为正，则系统稳定- 如果幅值裕度和相位裕度都为0，则系统临界稳定（marginally stable）- 如果任意一个为负值，则系统不稳定结合我们前面提到的，增益K会使得幅频图整体抬升，即缩小幅值裕度。当幅值裕度有正数变为0再变为负数，系统就会从稳定变为不稳定。将让系统临界稳定的增益记为$K_c$，只有当$K<K_c$时系统才稳定。如下图。![image-20240619114928359](https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619114928359.png)同时，稍加推导还可发现：$$20log(K_c)+Magnitude(\omega)=0dB,\ \ 20log(K)+Magnitude(\omega)=现在的振幅$$$$GM=0dB-现在的振幅=20log(K_c)-20log(K)=20log(\frac{K_c}{K})$$因此：$$GM=20\log(\frac{K_c}{K})$$## 由频响反推闭环传输函数当相位裕度PM<60°时，有：$$PM=100\zeta\degree;\ \ \frac{Bandwidth_{(-3dB)}}{\omega_n}=1-0.5\zeta$$即，可以分别求得$\zeta$和$\omega_n$## 幅频曲线与稳态误差$e_{ss}$的关系### 单位阶跃响应CH1中介绍过，对于单位阶跃响应：$$K_p=\lim_{s\rightarrow0}{G(s)H(s)},\ e_{ss}=\frac{1}{1+K_p}$$观察一下，$ \lim_{s\rightarrow0}{G(s)H(s)}$ 刚和波德图幅频的原点$s=j\omega，\omega=0$一致，因此，幅频图的初始值就是$20log(K_p)$![image-20240619134602347](https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619134602347.png)### 单位斜坡响应& 单位抛物线响应这两种响应的证明比较复杂，只需要知道初始斜率的延长线与0dB线的交点频率分别对应$K_v$和$K_a$即可<table>    <tr><td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619135637658.png"></center><td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619135701619.png"></center><td>    </tr></table><h1 id="极坐标图-Polar-plot"><a href="#极坐标图-Polar-plot" class="headerlink" title="极坐标图 (Polar plot)"></a>极坐标图 (Polar plot)</h1><h2 id="引入-什么是极坐标图"><a href="#引入-什么是极坐标图" class="headerlink" title="引入-什么是极坐标图"></a>引入-什么是极坐标图</h2><p>对于一个系统，它的开环系统函数为$GH(s)$，这是一个复数，可以写成$|GH(j\omega)|\angle(\theta)$或者$Real(GH(j\omega))+jImg(GH(j\omega))$的形式。</p><p>而回想一下坐标轴呢：</p><p>在极坐标系下，向量在坐标上的位置由其模长和角度决定，对应$|GH(j\omega)|\angle(\theta)$.</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619140530618.png" alt="image-20240619140530618"></p><p>在笛卡尔子坐标系下我们把X轴定义为实轴，Y轴定义为虚轴，对应$Real(GH(j\omega))+jImg(GH(j\omega))$；</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619140332707.png" alt="image-20240619140332707"></p><p>这两种坐标轴其实画出来的图像是完全一样的。</p><p>极坐标图就是在这样的坐标图下，<strong>把$s$从$0\rightarrow +\infty$时</strong>$GH(s)$的值画在坐标上。例如下面这个例子</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619140815404.png" alt="image-20240619140815404"></p><p>极坐标图的优势是：</p><ul><li>极坐标图的优势在于可以在一个紧凑的图表中显示完整的频率响应信息</li><li>每种类型的传递函数都对应于一个特征轨迹，其基本性质很容易记住</li></ul><h2 id="如何绘制极坐标图"><a href="#如何绘制极坐标图" class="headerlink" title="如何绘制极坐标图"></a>如何绘制极坐标图</h2><ol><li>求出开环传输函数OLTF，将$s=j\omega$代入</li><li>求出$\omega=0$时$GH(j\omega)$的值，这是极坐标图的起始点</li><li>求出$\omega=\infty$时$GH(j\omega)$的值，这是极坐标图的终点</li><li>通过$Img(GH(j\omega))=0$解出$\omega$来检查其是否和实轴相交，并解出交点</li><li>通过$Real(GH(j\omega))=0$解出$\omega$来检查其是否和虚轴相交，并解出交点</li><li>再找几个$\omega$介于这些特殊点间的值，来提高绘图精度</li><li>平滑的曲线连接这些点</li></ol><p><em>举个例子:$G(s)=\frac{1}{s(s+1)}$</em></p><script type="math/tex; mode=display">G(s)=\frac{1}{s(s+1)}=\frac{1}{j\omega(j\omega+1)}=\frac{1}{-\omega^2=j\omega}</script><script type="math/tex; mode=display">=\frac{1}{-\omega^2+j\omega}\times\frac{-\omega^2-j\omega}{-\omega^2-j\omega}=\frac{-\omega^2-j\omega}{\omega^4+\omega^2}=\frac{-1}{\omega^2+1}-j\frac{1}{\omega(\omega^2+1)}</script><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619142736729.png" alt="image-20240619142736729"></p><h1 id="奈奎斯特稳定性准则（Nyquist-Stability-Criterion）"><a href="#奈奎斯特稳定性准则（Nyquist-Stability-Criterion）" class="headerlink" title="奈奎斯特稳定性准则（Nyquist Stability Criterion）"></a>奈奎斯特稳定性准则（Nyquist Stability Criterion）</h1><div class="note info flat"><p>参考视频：<a href="https://www.bilibili.com/video/BV1yg4y1B7JM/?spm_id_from=333.337.search-card.all.click&amp;vd_source=69d49a5680f58d9a0f04ae8cf1207d1d">【自动控制原理】13_奈奎斯特稳定性判据_Nyquist Stability Criterion_Part 1_哔哩哔哩_bilibili</a></p><p>参考资料：<a href="https://gr.xjtu.edu.cn/c/document_library/get_file?folderId=1797493&amp;name=DLFE-28935.pdf">奈奎斯特稳定判据 西安交通大学-刘剑毅</a></p></div><h2 id="前置知识-柯西幅角定理-（Cauchy’s-Argument-Principle）"><a href="#前置知识-柯西幅角定理-（Cauchy’s-Argument-Principle）" class="headerlink" title="前置知识-柯西幅角定理 （Cauchy’s Argument Principle）"></a>前置知识-柯西幅角定理 （Cauchy’s Argument Principle）</h2><p>(参考资料中对柯西幅角定理进行了证明，若有兴趣可以自行了解)</p><p><strong>柯西幅角定理：</strong>复平面1上的点通函数$F(s)$映射到复平面2（也就是，复平面1是s的值，复平面2是$F(s)$的值）。现有封闭曲线$C_S$包围复平面1上函数$F(s)$的Z个 零点和P个极点。当封闭曲线$C_S$以顺时针方向包围一周时， 在复平面2上也会有封闭曲线$C_F$将以逆时针方向绕原点旋转 N=P-Z 圈</p><ul><li>若N为正数，则$C_F$以逆时针方向环绕，且包围原点；</li><li>若N为0，则$C_F$以顺时针还是逆时针方向环绕不确定，但不包围原点；</li><li>若N为负数，则$C_F$以顺时针方向环绕，且包围原点；</li></ul><p>也就是说，可以通过经过函数映射的复平面的旋转关系，来判断画出来的线内是否包含零极点。如果我们去画一条包围s域右半平面的线，再去看经过系统函数映射出来的线的图像，那么是否就可以判断s平面右半包不包含零极点了？</p><h2 id="奈奎斯特路径（Nyquist-path）"><a href="#奈奎斯特路径（Nyquist-path）" class="headerlink" title="奈奎斯特路径（Nyquist path）"></a>奈奎斯特路径（Nyquist path）</h2><p>上文提到的“一条包围s域右半平面的线”，就被称为奈奎斯特路径，也叫Nyquist counter。</p><p><strong>奈奎斯特路径</strong>是 s 平面中的闭合等值线，它完全包围了 s 平面  的整个右半部分（Right Half Plane, RHP），同时不穿过（绕行）虚轴上或位于 0 处的 $G(s)H(s)$ 的任何极点。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619200329093.png" alt="image-20240619200329093"></p><h2 id="绘制奈奎斯特图"><a href="#绘制奈奎斯特图" class="headerlink" title="绘制奈奎斯特图"></a>绘制奈奎斯特图</h2><p>奈奎斯特图是极坐标图的延续，极坐标图的扫频范围是$0$到$\infty$，而奈奎斯特图的扫频范围奈奎斯特路径定义的范围。画图步骤如下：</p><p><strong>如果$G(s)H(s)$在虚轴上没有极点，则：</strong></p><ol><li>解算出$G(s)H(s)$在虚轴的所有零极点</li><li>绘制从$\omega=0$扫频到$\omega=\infty$的极坐标图；此时完成了奈奎斯特路径上线条ad的扫频</li><li>绘制从$\omega=-\infty$扫频到$\omega=0$的极坐标图；此时完成了奈奎斯特路径上线条fa的扫频</li><li>求得$s=\lim_{R\rightarrow\infty}{Re^{j\theta}},-90\degree&lt;\theta&lt;90\degree$时$G(s)H(s)$的解，对应线条def，通常这个解会趋于一个点。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619200652648.png" alt="image-20240619200652648"></p><p><strong>如果$G(s)H(s)$在虚轴上有极点，则：</strong></p><p>在前面四步的基础上，需要执行第五步：</p><ol><li>取$s\rightarrow poles$但不等于，半径为$\lim_{\rho\rightarrow0}{\rho e^{j\theta}}$，对极点进行绕行</li></ol><p><em>举个例子</em></p><p>对于系统开环传输函数：</p><script type="math/tex; mode=display">G(s)=\frac{1}{s(s+1)}</script><ol><li>首先取$\omega=0^+$扫频到$\omega=\infty$的，可以画出路径下半平面的(c)</li><li>首先$\omega=0^-$扫频到$\omega=-\infty$的，可以画出上班平面的路径(c)</li><li>取$s=\lim_{R\rightarrow\infty}{Re^{j\theta}},-90\degree&lt;\theta&lt;90\degree$,对应的是$G(s)=0$这个点</li><li>取$s\rightarrow 0$且距0半径为$\lim_{\rho\rightarrow0}{\rho e^{j\theta}}$，$90°&lt;\theta&lt;-90°$对其进行绕行，对应是$|G(s)|\rightarrow \infty,$90°&lt;\theta&lt;-90°$，即路径(b)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619205715154.png" alt="image-20240619205715154"></p><h2 id="奈奎斯特稳定性判"><a href="#奈奎斯特稳定性判" class="headerlink" title="奈奎斯特稳定性判"></a>奈奎斯特稳定性判</h2><p>要研究系统是否稳定，就是去研究它的闭环传递函数的所有极点都在左半平面。然而，闭环传递函数是</p><script type="math/tex; mode=display">\frac{G(s)}{1+G(s)H(s)}</script><p><strong>我们现在的讨论都是基于开环传递函数$G(s)H(s)$做的，如何将它们关联呢？</strong></p><p>令$G(s)=\frac{N_G}{D_G}$，$H(s)\frac{N_H}{D_H}$</p><script type="math/tex; mode=display">G(s)H(s)=\frac{N_GN_H}{D_GD_H}</script><script type="math/tex; mode=display">1+G(s)H(s)=1+\frac{N_GN_H}{D_GD_H}=\frac{D_GD_H+N_GN_H}{D_GD_H}</script><script type="math/tex; mode=display">\frac{G(s)}{1+G(s)H(s)}=\frac{\frac{N_G}{D_G}}{\frac{D_GD_H+N_GN_H}{D_GD_H}}=\frac{D_HN_G}{D_GD_H+N_GN_H}</script><p>此时我们发现，$G(s)H(s)$和$1+G(s)H(s)$的分母相等，即二者极点相等。$1+G(s)H(s)$的分子和$\frac{G(s)}{1+G(s)H(s)}$的分母相等，即$1+G(s)H(s)$的零点和$\frac{G(s)}{1+G(s)H(s)}$的极点相等。</p><p>此时，可以发现，$1+G(s)H(s)$的极点和$G(s)H(s)$的极点相同；</p><p>假设现在这个用作映射的函数$F(s)=1+G(s)H(s)$，那么$N=P-Z$的意义就是，<strong>被s域右半平面框住</strong>的$G(s)H(s)$的极点个数减去$\frac{G(s)}{1+G(s)H(s)}$的极点个数；</p><p><strong>我们将$F(s)$左右同时减1做为新的映射函数</strong>，$F’(s)=F(s)-1=G(s)H(s)$。因为这个映射是线性的，所以对于映射过去的绕圈圈的图就是把围绕(0,0)绕圈变成了围绕(-1,0)绕圈，<strong>其他性质不变（即零极点让它绕圈的方向和次数）</strong>。这个$F’(s)$，就是奈奎斯特图的映射了。</p><p>我们知道，当$\frac{G(s)}{1+G(s)H(s)}$右半平面出现极点时，即$Z!=0$时，系统就不稳定。若$Z=0$，那么系统就稳定。换句话说，也就是N=P时，系统稳定。N代表的是绕圈的圈数，P代表的时OLTF的极点个数。至此我们得到了奈奎斯特稳定性判据。</p><p><strong>奈奎斯特稳定性判据：当奈奎斯特图绕圈的圈数等于OLTF右侧极点个数时，系统稳定。(N=P 或 N=P-Z, Z=0)</strong></p><p><em>举个例子</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240619234609300.png" alt="image-20240619234609300" style="zoom:67%;" /></p><p>对于上图，被奈奎斯特路径框住的零点有2个，因此Z=2；极点0个，因此P=0；$N=P-Z=-2$，因此奈奎斯特图顺时针绕两圈。但是由于$N!=P$，所以系统不稳定。</p><h2 id="奈奎斯特图与幅值裕度和相位裕度的关系"><a href="#奈奎斯特图与幅值裕度和相位裕度的关系" class="headerlink" title="奈奎斯特图与幅值裕度和相位裕度的关系"></a>奈奎斯特图与幅值裕度和相位裕度的关系</h2><p>回顾前面，幅值裕度是指的$0dB-相位穿越频率下的幅度$的值。而奈奎斯特图下，某一点距原点的距离就是其幅值，距离正半轴的角度是其相位。</p><p>相位穿越频率是相位等于$-180°$的时候，也就是其与负半实轴的交点。而0dB就是增益为1时，也就是单位圆。也就是说，幅值裕度就是$20log(1-负半实轴交点的幅值)$。</p><p>同理可得，相位裕度就是$曲线与单位圆的交点的相位-180°$。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620002214843.png" alt="image-20240620002214843"></p><h1 id="尼柯尔斯图-（Nichols-Chart）（了解即可）"><a href="#尼柯尔斯图-（Nichols-Chart）（了解即可）" class="headerlink" title="尼柯尔斯图 （Nichols Chart）（了解即可）"></a>尼柯尔斯图 （Nichols Chart）（了解即可）</h1><h2 id="引入-M环和N环"><a href="#引入-M环和N环" class="headerlink" title="引入-M环和N环"></a>引入-M环和N环</h2><h3 id="M环"><a href="#M环" class="headerlink" title="M环"></a>M环</h3><p>常数 M 环（Constant M-Circles）是单位反馈系统的闭环幅度频率响应的轨迹。</p><p>假设有一个单位反馈控制系统：</p><script type="math/tex; mode=display">T(s)=\frac{G(s)}{1+G(s)}</script><p>代入$s=j\omega$，去掉拉普拉斯变换的衰减常数；并将其虚部和实部拆分。</p><script type="math/tex; mode=display">T(j\omega)=\frac{G(j\omega)}{1+G(j\omega)}=\frac{P(\omega)+jQ(\omega)}{(P(\omega)+1)+jQ(\omega)}</script><p>那么这个信号在某一频率$\omega$下的幅度就是$|T(j\omega)|$，记幅度为$M$，有：</p><script type="math/tex; mode=display">M^2=|T^2(j\omega)|=\frac{P^2(\omega)+jQ^2(\omega)}{(P(\omega)+1)^2+jQ^2(\omega)}</script><p>这个式子经过移相改写之后可以改写成一个圆的表达式（这里就不推了，这不是重点），圆的大小随着M的大小变化而变化，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620011130188.png" alt="image-20240620011130188" style="zoom: 67%;" /></p><h3 id="N环"><a href="#N环" class="headerlink" title="N环"></a>N环</h3><p>常数 N 环（Constant N-Circles）是单位反馈系统的闭环相位频率响应轨迹。</p><p>对于和M环一样的系统：</p><script type="math/tex; mode=display">T(j\omega)=\frac{G(j\omega)}{1+G(j\omega)}=\frac{P(\omega)+jQ(\omega)}{(P(\omega)+1)+jQ(\omega)}</script><script type="math/tex; mode=display">\phi=arctan(\frac{Q}{P})-arctan(\frac{Q}{P+1})</script><p>这个也是个随着相位$\phi$改变而增大的圆</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620012112698.png" alt="image-20240620012112698" style="zoom:50%;" /></p><p>使用极坐标表示的幅度和相位，那不就是N环和M环的交点吗？</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620012229992.png" alt="image-20240620012229992" style="zoom: 50%;" /></p><h2 id="尼柯尔斯图"><a href="#尼柯尔斯图" class="headerlink" title="尼柯尔斯图"></a>尼柯尔斯图</h2><p>在上面的M环和N环中，是M环和N环都没有以对数形式给出。而尼科尔斯图对其进行了改进，尼柯尔斯图是将线性非时变系统在不同频率下的增益分贝值及相位绘在一直角坐标系的图上，尼柯尔斯图将二种波德图（波德增益图及波德相位图）结合成一张图，而频率只是曲线中的参数，不直接在图中显示。</p><p>尼科尔斯图的坐标有两部分：</p><ul><li>下面和右侧的线性坐标表示OLTF的幅值和相位，其中横轴表示开环相位，纵轴表示开环幅值</li><li>中间一圈一圈的表示M环和N环</li></ul><p>画尼科尔斯图时，只需使用开环传递函数，和画极坐标图类似的操作即可。</p><p>例如：</p><script type="math/tex; mode=display">G(s)=\frac{1}{s(s+1)(s+3)}</script><script type="math/tex; mode=display">G(j\omega)=\frac{-4\omega^2}{-16\omega^4-(\omega^3-3\omega)^2}+j\frac{(\omega^3-3\omega)}{-16\omega^4-(\omega^3-3\omega)^2}</script><p>这是开环传递函数，从$0-\infty$范围内进行扫频，求得OLTF的幅值和角度，对应线性坐标系标上去即可。</p><p>这条线和非线性坐标系交点处由M环和N环得出的闭环传输函数特征。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620013119357.png" alt="image-20240620013119357" style="zoom: 50%;" /></p><p>其幅值裕度和相位裕度如下图，都是线性坐标系下的交点。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240620014304381.png" alt="image-20240620014304381" style="zoom: 50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Control Systems Part1-1-控制系统概述及其基本分析</title>
      <link href="/posts/b1714978.html"/>
      <url>/posts/b1714978.html</url>
      
        <content type="html"><![CDATA[<h1 id="控制系统概述"><a href="#控制系统概述" class="headerlink" title="控制系统概述"></a>控制系统概述</h1><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240523193531200.png" alt="image-20240523193531200"></p><p>如上图所示，根据有无feedback，控制系统被分为开环控制系统和闭环控制系统两类。在一个抽象出的系统中，使用Sensor取回需要的数据，Controller处理数据并转换为控制信号，Actuator收到控制信号后将其转化为物理上的输出</p><div class="note info flat"><p>这一门课仅涉及闭环线性时不变控制系统</p></div><h2 id="开环控制系统"><a href="#开环控制系统" class="headerlink" title="开环控制系统"></a>开环控制系统</h2><p>开环控制系统因为没有反馈的存在，因此系统的精度取决于校准的程度。</p><p>而且，开环控制系统无法消除收到的干扰或运行变化所造成的影响。</p><h2 id="闭环控制系统"><a href="#闭环控制系统" class="headerlink" title="闭环控制系统"></a>闭环控制系统</h2><p>闭环控制系统将它现在的实际输出与期望的输出进行对比，再进行控制。这个过程被称为反馈。</p><p>通常来说，<strong>使用负反馈</strong>来控制一个系统。（i.e., 将系统期望的输出-现在的输出，得到error值）。在这门课中，只学习负反馈的情况。</p><h1 id="对系统进行建模（引入）"><a href="#对系统进行建模（引入）" class="headerlink" title="对系统进行建模（引入）"></a>对系统进行建模（引入）</h1><h2 id="使用拉普拉斯变换表达系统传输函数"><a href="#使用拉普拉斯变换表达系统传输函数" class="headerlink" title="使用拉普拉斯变换表达系统传输函数"></a>使用拉普拉斯变换表达系统传输函数</h2><p>一个带有反馈的系统，其系统可以用一个差分方程来描述。通式是：</p><script type="math/tex; mode=display">\frac {d^ {n}y}{dt^ {n}} + a_ {n-1} \frac {d^ {n-1}y}{dt^ {n}1} + a_ {1}  \frac {dy}{dt} +  a_ {0} y(t)=  b_ {m}  \frac {d^ {m}x}{dt^ {m}}  + b_ {1}  \frac {dx}{dt}  +  b_ {0}  x(t)</script><p>通过变换将$y(t)$移动到一边之后，可以得到带有$x(t)$的和不带$x(t)$的两部分。带有$x(t)$的部分构成了系统的强迫响应（即，由外部激励引起的）。没有$x(t)$的部分是系统系统的自由响应。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240618182432887.png" alt="image-20240618182432887"></p><p>对这个系统函数进行拉普拉斯变换，$y(t)$和$x(t)$变换为$Y(s)$和$X(s)$。移项后即可传输函数$H(s)$</p><script type="math/tex; mode=display">H(s)=\frac{Y(s)}{X(s)}=\frac{b_ms^m+b_{m-1}s^{m+1}+...+b_1s+b_0}{s^n+a_{n-1}s^{n-1}+...+a_1s+a_0}</script><p>对于这个传输函数：</p><ul><li>分子称为特征多项式（Characteristic Polynomial）: 传输函数的分母</li><li>特征函数（Characteristic Equation）: 让传输函数分母=0</li><li>极点：分母=0的解</li><li>零点：分子=0的解</li></ul><h2 id="系统的各项指标"><a href="#系统的各项指标" class="headerlink" title="系统的各项指标"></a>系统的各项指标</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240523211938096.png" alt="image-20240523211938096" style="zoom:33%;" /></p><p>任何一个系统都可以被描述为上图的形式，其中：</p><ul><li>G：前向传输函数（Forward Transfer Function）</li><li>H：反馈传输函数（Feedback Transfer Function）</li><li>GH：开环传输函数（Open-loop transfer function）</li><li>C/R：闭环传输函数（closed-loop transfer function）$\frac{C}{R}＝\frac{𝐺}{1±𝐺𝐻}$；对于分母，<strong>正反馈是减，负反馈是加</strong>。</li><li>E/R：误差比（Error ratio）$\frac{𝐸}{R}＝\frac{1}{1±𝐺𝐻}$</li><li>B/R：primary feedback ratio $\frac{𝐵}{𝑅}＝\frac{𝐺𝐻}{1±𝐺𝐻}$</li></ul><h3 id="开环与闭环传输函数："><a href="#开环与闭环传输函数：" class="headerlink" title="开环与闭环传输函数："></a>开环与闭环传输函数：</h3><p>对于上图所示的这个系统，其闭环传输函数为$\frac{C}{R}＝\frac{𝐺}{1±𝐺𝐻}$​，其推导很简单，以负反馈系统为例：</p><script type="math/tex; mode=display">[𝑅−𝐶⋅𝐻(𝑠)]G(𝑠)=C</script><script type="math/tex; mode=display">  RG(𝑠)−CG(𝑠)H(𝑠)=C</script><script type="math/tex; mode=display">RG=C[1+𝐺(𝑠)𝐻(𝑠)]</script><script type="math/tex; mode=display">\frac{𝐶}{𝑅}=\frac{𝐺}{1+𝐺𝐻}</script><p>研究闭环传递函数的原因很好理解：C(s)=R(s)H(s)，可以轻易通过闭环传输函数得到系统输出</p><p>那什么是开环传递函数呢？其定义是：断开系统的主反馈通路，则前向通路传递函数$G(s)$与反馈通路传递函数$H(s)$的乘积称为系统的开环传递函数。因此，该系统的开环传递函数就是$GH(s)$</p><p>为什么需要开环传递函数呢？开环传递函数虽然没有直接的物理意义，但是其却包含了系统内所有的传输函数，因此可以从数学层面通过开环传递函数对系统的零极点、稳定性进行研究，且相较于闭环传递函数，减少了计算量。</p><div class="note info flat"><p>开环传递函数是针对于闭环系统而言的，而不是指开环系统的传递函数</p></div><h3 id="二阶系统传输函数的构成"><a href="#二阶系统传输函数的构成" class="headerlink" title="二阶系统传输函数的构成"></a>二阶系统传输函数的构成</h3><p>对于任意一个二阶系统，其可以表示为</p><script type="math/tex; mode=display">\frac{\omega_n^2}{s^2+2\zeta\omega_ns+\omega_n^2}</script><p>其中：</p><ul><li>$\zeta$称为阻尼比(damping ratio)。</li><li>$\omega_n$称为无阻固有频率（damped natural frequency），其物理意义是在系统没有阻尼的时候，自然振荡的频率。</li></ul><p>对这个系统求单位阶跃响应（$u\left(t\right)\ $）：</p><script type="math/tex; mode=display">L\left[u\left(t\right)\right]＝u(s)=\frac{1}{s}</script><script type="math/tex; mode=display">C\left(s\right)=u\left(s\right)H\left(s\right)=\frac{\omega_n^2}{\left(s^2+2\zeta\omega_ns+\omega_n^2\right)s}</script><p>将该式因式分解后反拉普拉斯变化得到时域响应</p><script type="math/tex; mode=display">C\left(s\right)=\frac{1}{s}-\frac{s+2\zeta\omega_n}{s^2+2\zeta\omega_ns+\omega_n^2}=\frac{1}{s}-\frac{s+\zeta\omega_n}{\left(s+\zeta\omega_n\right)^2+\omega_d^2}-\frac{\zeta\omega_n}{\left(s+\zeta\omega_n\right)^2+\omega_d^2}</script><script type="math/tex; mode=display">c(t)=1-\frac{1}{1-\zeta^2}e^{-\zeta\omega_nt}sin(\omega_dt+\beta), \beta=arctan(\sqrt{1-\zeta^2}/\zeta)=arccos\zeta</script><p>其中$\omega_d=\omega_n{\sqrt{1-\zeta^2}}$，称为阻尼固有频率（damped natural frequency），是系统受阻时的角频率。<br>在$\zeta=0$时，称为<strong>无阻尼（undamped）</strong>，系统<strong>持续振荡</strong>，系统极点位<strong>于虚轴上</strong>；<br>在$\zeta＝1$时，称为严<strong>阻尼（Critically damped）</strong>，系统<strong>不会出现振荡</strong>，而是直接逼近稳态值，极点<strong>位于左实轴</strong>；<br>在$0&lt;\zeta&lt;1$时，称为欠阻尼（underdamped）, 系统在振荡后收敛于稳态值，极点位于<strong>s域左侧，有虚部分量</strong>。<br>如下面三图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240617201547167.png" alt="image-20240617201547167"></p><h1 id="瞬态响应的各项指标"><a href="#瞬态响应的各项指标" class="headerlink" title="瞬态响应的各项指标"></a>瞬态响应的各项指标</h1><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240617202208031.png" alt="image-20240617202208031"></p><p>在这样的一个二阶系统响应中：</p><ul><li>Raise time $t_r$: 响应从10%-90% 或 0%-100% 所需的时间；</li></ul><script type="math/tex; mode=display">t_r=\frac{\pi-\beta}{\omega_d}</script><ul><li>Peak time $t_p$：响应到达最高峰值所需的时间；</li></ul><script type="math/tex; mode=display">t_p=\frac{\pi}{\omega_d}</script><ul><li>Maximum Overshoot $M_p$：$\frac{响应过冲-终值}{终值} $的比例；</li></ul><script type="math/tex; mode=display">M_p=e^{-(\sigma/\omega_d)\pi}=e^{-(\sqrt{1-\zeta^2})\pi}\times100%</script><ul><li>Settling time $t_s$：响应稳定至稳态值所需的时间，通常允许2%或5%的误差：（下式中T被称为时间常数，由瞬态响应的衰减速度决定，$T=\frac{1}{\zeta\omega_n}$。）</li></ul><script type="math/tex; mode=display">t_s=4T=\frac{4}{\zeta\omega_n}(2\% criterion);  t_s=3T=\frac{3}{\zeta\omega_n}(5\% criterion)</script><h1 id="系统稳态分析"><a href="#系统稳态分析" class="headerlink" title="系统稳态分析"></a>系统稳态分析</h1><h2 id="基于开环传递函数的系统的分类"><a href="#基于开环传递函数的系统的分类" class="headerlink" title="基于开环传递函数的系统的分类"></a>基于开环传递函数的系统的分类</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240617205014113.png" alt="image-20240617205014113"></p><p>对于G(s)，如果其分母有单独的$s^N$，N为几它就是type N系统。例如没有单独的s只有（Ts+1），那就是type0系统；有s(Ts+1)，就是type1系统</p><div class="note info flat"><p>注意：系统的阶数(order)是指的分母内s的最高次，这里系统的类别（type）是指的孤立s的次数</p></div><h2 id="系统的稳态误差"><a href="#系统的稳态误差" class="headerlink" title="系统的稳态误差"></a>系统的稳态误差</h2><p>对于一个实际的控制系统，其稳态输出不可能在任何 情况下都与输入量一致或相当，也不可能在任何形式的扰 动作用下都能准确地恢复到原平衡位置。因此控制系统的稳态误差是一项重要的技术指标。</p><h3 id="稳态误差的定义"><a href="#稳态误差的定义" class="headerlink" title="稳态误差的定义"></a>稳态误差的定义</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240617212226838.png" alt="image-20240617212226838"></p><p><strong>系统误差的定义：</strong>系统的输入$r(t)$和主反馈信号$b(t)$之差。</p><script type="math/tex; mode=display">e(t)=r(t)-b(t)</script><p><strong>稳态及误差</strong>：当时间趋于无穷时的系统误差即为稳态误差，记为$e_{ss}$</p><script type="math/tex; mode=display">e_{ss}=\lim_{t\rarr\infty}e(t)</script><p>只有当系统稳定时，研究稳态误差才有意义。</p><h3 id="如何求稳态误差"><a href="#如何求稳态误差" class="headerlink" title="如何求稳态误差"></a>如何求稳态误差</h3><p>对于任意一个系统，其开环传递函数为G(s)H(s)，其中前向传递函数$G(s)$:</p><script type="math/tex; mode=display">G(s)=\frac{K(T_as+1)(T_bs+1...(T_ms+1))}{(T_1s+1)(T_2s+1)...(T_ps+1)}</script><p>闭环传递函数是输出比输入得到的，因此有</p><script type="math/tex; mode=display">\frac{G(s)H(s)}{1+G(s)H(s)}=\frac{Y(s)}{R(s)}</script><script type="math/tex; mode=display">Y(s)=\frac{G(s)H(s)}{1+G(s)H(s)}R(s)</script><p>根据上图，$B(s)$有：</p><script type="math/tex; mode=display">B(s)=Y(s)H(s)</script><p>而$E(s)$恰好等于$R(s)-B(s)$，因此：</p><script type="math/tex; mode=display">E(s)=R(s)-Y(s)H(s)=R(s)-\frac{G(s)H(s)}{1+G(s)H(s)}R(s)=R(s)\bigg[\frac{1+G(s)H(s)-G(s)H(s)}{1+G(s)H(s)}\bigg]</script><script type="math/tex; mode=display">=R(s)\frac{1}{1+G(s)H(s)}</script><p>而前面小节介绍的误差比就是:</p><script type="math/tex; mode=display">\frac{E(s)}{R(s)}=\frac{1}{1+G(s)H(s)}</script><p>现在已经有了$E(s)$的表达式，由终值定理，$\lim_{s\rightarrow0}sF(s)=\lim_{t\rightarrow\infty}f(t)$，也就是系统稳定的情况。因此：</p><script type="math/tex; mode=display">e_{ss}=\lim_{t\rarr\infty}e(t)=\lim_{s\rarr0}sE(s)=\lim_{s\rarr0}s\frac{1}{1+G(s)H(s)}R(s)</script><p><strong>只有稳定的系统，才可计算稳态误差。</strong></p><h2 id="不同type系统的稳态误差"><a href="#不同type系统的稳态误差" class="headerlink" title="不同type系统的稳态误差"></a>不同type系统的稳态误差</h2><p>为了更直观地简便举例解释，现考虑H(s)为1，即单位负反馈的情况。此时$G(s)H(s)=G(s)$，那么$\frac{1}{1+G(s)H(s)}R(s)$可以作如下推导：</p><script type="math/tex; mode=display">G(s)=\frac{K(T_as+1)(T_bs+1...(T_ms+1))}{(T_1s+1)(T_2s+1)...(T_ps+1)}</script><script type="math/tex; mode=display">\frac{1}{1+G(s)H(s)}R(s)=\frac{1}{1+\frac{K(T_as+1)(T_bs+1...(T_ms+1))}{(T_1s+1)(T_2s+1)...(T_ps+1)}}R(s)</script><script type="math/tex; mode=display">=\frac{(T_1s+1)(T_2s+1)...(T_ps+1)}{(T_1s+1)(T_2s+1)...(T_ps+1)+K(T_as+1)(T_bs+1...(T_ms+1)){}}R(s)</script><p>也就是，这个式子变成了：（这个式子后面作为辅助解释）</p><script type="math/tex; mode=display">\frac{G(s)分母}{G(s)分母+G(s)分子}R(s)</script><h3 id="unit-step-输入下"><a href="#unit-step-输入下" class="headerlink" title="unit step 输入下"></a>unit step 输入下</h3><p>输入信号u(t)的$U(s)=\frac{1}{s}$。此时：</p><script type="math/tex; mode=display">\lim_{s\rarr0}sE(s)=\lim_{s\rarr0}s\frac{1}{1+G(s)H(s)}R(s)=\lim_{s\rarr0}sE(s)=\lim_{s\rarr0}\frac{1}{1+G(s)H(s)}</script><p>记单位阶跃输入下的静止位置误差常数 （static position error constant）是$K_p$，等于开环传递函数$G(s)H(s)$的极限:</p><script type="math/tex; mode=display">K_p=\lim_{s\rarr0}{G(s)H(s)}</script><p>那么$e_{ss}$就可以由如下式子求到：</p><script type="math/tex; mode=display">e_{ss}=\frac{1}{1+K_p}(仅unit\ step输入适用)</script><p>同时我们发现，对于G(s)没有孤立s在分母的函数（即type0系统），$e_{ss}=\frac{1}{1+K_p}$适用。但是一旦G(s)的分母存在孤立s，那么$K_p=G(0)=\infty$，$e_{ss}=0$；</p><p>这一点通过上面推出的$\frac{G(s)分母}{G(s)分母+G(s)分子}R(s)$也很好解释，G(s)分母存在s，且$s\rightarrow0$，因此$e_{ss}=0$</p><p><strong>因此，对于系统输入单位阶跃响应，稳态误差有：</strong></p><ul><li><strong>type0系统的$e_{ss}=\frac{1}{1+K_p}$</strong></li><li><strong>type1或更高type系统$e_{ss}=0$，$K_p=\lim_{s\rightarrow0}{G(s)H(s)}$</strong></li></ul><h3 id="unit-ramp-输入下"><a href="#unit-ramp-输入下" class="headerlink" title="unit ramp 输入下"></a>unit ramp 输入下</h3><p>输入信号$r(t)$的$R(s)=\frac{1}{s^2}$，此时：</p><script type="math/tex; mode=display">\lim_{s\rarr0}sE(s)=\lim_{s\rarr0}s\frac{1}{1+G(s)H(s)}R(s)=\lim_{s\rarr0}sE(s)=\lim_{s\rarr0}\frac{1}{s+sG(s)H(s)}</script><p>因此$s\rightarrow0$，分母$s+sG(s)H(s)$前面孤立的s可以直接当0对待，因此分母只剩下$sG(s)H(s)$</p><p>记单位斜坡输入下静止速度误差常数 （static velocity error constant）是$K_v$，等于$sG(s)H(s)$的极限:</p><script type="math/tex; mode=display">K_v=\lim_{s\rarr0}{sG(s)H(s)}</script><p>此时$e_{ss}$</p><script type="math/tex; mode=display">e_{ss}=\frac{1}{K_v}</script><p>当G(s)分母没有孤立s（即，type0系统时），$K_v=sG(0)=0$</p><script type="math/tex; mode=display">e_{ss}=\frac{1}{K_v}=\infty</script><p>使用$\frac{G(s)分母}{G(s)分母+G(s)分子}R(s)$也很好解释，$R(s)=\frac{1}{s^2}$，$G(s)分母$未能对其引入的s进行消除，分母带趋近于0的s，因此$e_{ss}=\infty$</p><p>同理可得，当type1系统时，$e_{ss}=\frac{1}{K_v}$，type2及以上系统$e_{ss}=0$</p><p><strong>因此，对于系统输入单位斜坡响应，稳态误差有：</strong></p><ul><li><strong>type0系统$e_{ss}=\infty$</strong></li><li>type1系统$e_{ss}=\frac{1}{K_v},K_v=\lim_{s\rightarrow0}{sG(s)H(s)}$</li><li>type2或更高type系统$e_{ss}=0$</li></ul><div class="note info flat"><p>PPT还介绍了unit-parapolic input和它的$K_a$推导思路和前面一致。后面没怎么用，这里就省略了</p></div><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240618113318399.png" alt="image-20240618113318399"></p><h1 id="劳斯-赫尔维茨（Routh–Hurwitz）稳定性准则"><a href="#劳斯-赫尔维茨（Routh–Hurwitz）稳定性准则" class="headerlink" title="劳斯-赫尔维茨（Routh–Hurwitz）稳定性准则"></a>劳斯-赫尔维茨（Routh–Hurwitz）稳定性准则</h1><div class="note info flat"><p>参考视频：<a href="https://www.youtube.com/channel/UCq0imsn84ShAe9PBOFnoIrg">YouTube-Brian Douglas</a></p></div><p>Routh-Hurwitz 稳定性准则是对控制系统稳定性的一种数学检验，是线性时间不变 （LTI） 控制系统稳定性的必要和充分条件。</p><p>在信号与系统中学过，系统特征方程（传输函数的分母=0）解出来的特征根有：</p><ul><li>完全在左半平面时，系统stable</li><li>在虚轴上时，系统critical stable（保持频率振幅不变的震荡）</li><li>出现在右半平面时，系统unstable</li></ul><p>在系统阶数较少时，我们可以利用因式分解将分母拆开，来求得极点。也可以很轻易地用部分分式展开法来求逆变换，观察其时域区域在$t\rightarrow\infty$是否收敛。</p><script type="math/tex; mode=display">H(s)=\frac{1}{s+1}\frac{1}{s-2}\frac{1}{s+3}=\frac{A}{s+1}+\frac{B}{s-2}+\frac{C}{s+3}</script><p>但是，当遇到阶数非常非常高的系统时怎么办呢？有没有什么办法无需进行因式分解，就可以看出有没有极点出现在右半平面的方法？这就是Routh-Hurwitz 稳定性判据在干的事儿。</p><h2 id="Routh-Hurwitz判据"><a href="#Routh-Hurwitz判据" class="headerlink" title="Routh-Hurwitz判据"></a>Routh-Hurwitz判据</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>如果一个特征方程里面的所有项，有一项出现了与其他不同的符号，例如下面这个</p><script type="math/tex; mode=display">s^4+3s^3-5s^2+s+2</script><p>此时可以立马判定这个系统是不稳定的，因为它一定会拆分出一个$(s-C)$(C是任意正常数项)的项目，来凑这个负号。</p><p>但是当符号全部相同时，就无法判定了。因为这种情况下可能会节出来实部为正，含有虚数的特征根。（无论是正负号，若全负号可以把它提一个-1出来放在传输函数分子，变成正号）。例如下面这个例子</p><script type="math/tex; mode=display">G(s)=\frac{1}{s^4+2s^3+3s^2+10s+8}=\frac{1}{s^2-s+4}\frac{1}{s+2}\frac{1}{s+1}</script><script type="math/tex; mode=display">roots:0.5\pm j\sqrt{3.75};\ -2;\ -1</script><p>因此我们必须使用其他更复杂的代数手段来判定，简单地观察符号是行不通的。</p><h3 id="Routh-矩阵"><a href="#Routh-矩阵" class="headerlink" title="Routh 矩阵"></a>Routh 矩阵</h3><p>Routh矩阵定义了一种填写矩阵的方法，可以通过观察矩阵的第一列来看出是否有右半平面的根</p><p>首先，假设特征函数是：</p><script type="math/tex; mode=display">D(s)=As^6+Bs^5+Cs^4+Ds^3+Es^2+Fs^1+Gs^0</script><p>因为特征函数有6阶，因此有7列。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/82903b0bb7c5c672360ca95b57916ef9.jpeg" alt="82903b0bb7c5c672360ca95b57916ef9"></p><ol><li>首先将ABCDEFG按照上图第一步填入矩阵</li><li>使用$\frac{BC-DA}{B}$算出黄色格子，如上图第二步</li><li>使用$\frac{BE-FA}{B}$算出红色格子，如上图第三步</li><li>使用$\frac{BG-0\times A}{B}$算出绿色格子，如上图第四步；此时到达了末尾，因此绿色格子后面填0，换行</li><li>使用$\frac{黄\times D-红\times B}{黄}$算出蓝色格子，如上图第五步</li><li>使用$\frac{黄\times F-绿\times B}{黄}$算出棕色格子，如上图第六步；此时棕色格子后面，绿色格子下面按照这个规则算出来等于0，因此换行；</li><li>保持这个规则，<strong>一直算到全部为0的一行，舍弃掉该行</strong>，剩下的就是Routh矩阵</li></ol><p>通式可以写为：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240618172608910.png" alt="image-20240618172608910" style="zoom: 80%;" /></p><h3 id="稳定性判定"><a href="#稳定性判定" class="headerlink" title="稳定性判定"></a>稳定性判定</h3><ul><li>当Routh矩阵的第一列全部是正数时，系统稳定</li><li>Routh矩阵的第一列有几次符号变化，就有几个右边平面的根</li></ul><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>沿用前面例子的系统传输函数：</p><script type="math/tex; mode=display">G(s)=\frac{1}{s^4+2s^3+3s^2+10s+8}=\frac{1}{s^2-s+4}\frac{1}{s+2}\frac{1}{s+1}</script><script type="math/tex; mode=display">roots:0.5\pm j\sqrt{3.75};\ -2;\ -1</script><p>首先，转写为Routh矩阵，上式特征方程为$s^4+2s^3+3s^2+10s+8$。按照下图展示的步骤进行转写</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/548c8b22d6156ae90f01039e33259533.jpg" alt="548c8b22d6156ae90f01039e33259533"></p><p>在Routh矩阵中，第一列经历了从2到-2 和 从-2到18 两次符号变换。因此：系统不稳定，有两个位于右侧的根</p>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 控制系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电信传输理论-CH6-光传输线</title>
      <link href="/posts/f7c4d047.html"/>
      <url>/posts/f7c4d047.html</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>对于光而言，其频率非常高，因此在讨论光时一般不直接讨论频率，而转为讨论光波的波长（通常以nm为单位）。</p><p>最开始的时候，塑料光纤作为“打通光纤通信最后一米，让用户终端使用光通信”的存在，有很多人在研究。这种光纤只能在较短距离内传输。但是它最终还是没有赶上时代，现在使用较少。</p><p>在CH3中简略介绍过光纤，其中介绍了单模和多模光纤，其粗细有差异。一般来说，单模线芯粗细约为9um，多模线芯粗细越为50um。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240325202348684.png" alt="image-20240325202348684"></p><p>将光纤无法做“接头”，因为光的指向性非常明确。一能一条线做一个“插头”。同时，光纤间连接时需要使用融纤机进行融接。</p><p>在光纤传输系统中，首先使用发光二极管（light-emitting diodes）将电信号转化为光，在接收端再用光电二极管（photodiodes）转化为电信号。</p><p>没有发射设备发出单一频率的辐射。LED 的输出线宽（linewidth）通常约为 60 nm，激光器的线宽为 5 至 10 nm，而“单模激光器”的线宽可以小于 0.01 nm。这与本节中会介绍的色散有关，这代表即使信号源是单色的（单频），也会发生频率扩展。</p><p>光纤的通信能力有如下参数来量化：</p><ul><li>光接接收度（light acceptance）</li><li>光损耗（light loss）</li><li>带宽（Bandwidth）</li></ul><p>这三个参数由两个更底层的物理性质决定：光纤的有效直径（active diameter）和光纤内使用的材料的折射率（refractive）。下面将介绍由数学量化的光纤分析：</p><h1 id="光的折射和反射理论"><a href="#光的折射和反射理论" class="headerlink" title="光的折射和反射理论"></a>光的折射和反射理论</h1><h2 id="折射率-Refractive-Index"><a href="#折射率-Refractive-Index" class="headerlink" title="折射率(Refractive Index)"></a>折射率(Refractive Index)</h2><p>光纤的折射率用n来表达，其定义如下</p><script type="math/tex; mode=display">n=\frac{真空光速}{介质光速}=\frac{velocity\ in\ a\ vacuum}{velocity\ in\ a\ medium}</script><p>（由定义式可以看出，真空中折射率为1）</p><p>在光纤中，其介质不同程度地会阻碍光，因此光速比真空中慢。折射率&gt;1</p><p>同时，不同的波长在同一介质中传输速率也有差异，因此波长不同，在同一介质下折射率也不同。因此，光的折射率需要针对某个波长来讨论：</p><script type="math/tex; mode=display">n_\lambda=\frac{真空光速(所有波长都一样)}{波长\lambda的波在介质中光速}</script><p>光通信中常用波长如下图所示，<strong>这里五星级的是</strong>CH3中介绍的850nm，1310nm，1550nm三个传输窗口。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240509172508791.png" alt="image-20240509172508791" style="zoom:50%;" /></p><h2 id="反射和折射的基本理论"><a href="#反射和折射的基本理论" class="headerlink" title="反射和折射的基本理论"></a>反射和折射的基本理论</h2><div class="note danger flat"><p>这里五星级！</p></div><h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p>对于两个具有不同折射率$n_1,n_2$的介质，光的折射遵循如下规则：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240509172814675.png" alt="image-20240509172814675" style="zoom:50%;" /></p><p>其中，入射角$i$和出射角$r$关系如下：</p><script type="math/tex; mode=display">\frac{sin(i)}{sin(r)}=\frac{n_2}{n_1}</script><p>或者可以把入射和反射都放在等号两边便于记忆：</p><script type="math/tex; mode=display">(入射)n_1sin(i)=n_2sin(r)(反射)</script><p>可以看到，<strong>当$n_2&lt;n_1$时</strong>，出射角会大于入射角。假如增大入射角，则出射角也会一起增大，如下图箭头所示方向</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240509175429646.png" alt="image-20240509175429646" style="zoom: 67%;" /></p><p>则出射角可能大于90度。这就会产生“全反射”</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>当光经过界面时，一部分会被折射，一部分会被反射。对于反射而言，入射角等于反射角。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/v2-09c0b3dcfd9249914db9aa1484812200_r.jpg" alt="光 - 知乎" style="zoom: 50%;" /></p><h2 id="全反射（total-internal-reflection）"><a href="#全反射（total-internal-reflection）" class="headerlink" title="全反射（total internal reflection）"></a>全反射（total internal reflection）</h2><p>对于不同折射率的介质，当光线<strong>从光密介质</strong>（较高折射率的介质）<strong>进入到光疏介质</strong>（较低折射率的介质），入射角大于临界角(critical angle)时，会发生<strong>全反射(total internal reflection)</strong>：光线全部向内面反射（没有能量损耗）,同时入射角等于出射角。对应下图就是$n_1&gt;n_2$</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240509173159516.png" alt="image-20240509173159516" style="zoom:50%;" /></p><p>其中，临界角(critical angle)的计算公式是：</p><script type="math/tex; mode=display">sin\theta_c=\frac{n_2}{n_1}</script><p><strong>由上可以看出，光纤中，线芯的折射率高于包层</strong></p><h2 id="非涅尔反射（Fresnel-reflection）"><a href="#非涅尔反射（Fresnel-reflection）" class="headerlink" title="非涅尔反射（Fresnel reflection）"></a>非涅尔反射（Fresnel reflection）</h2><p>当光从一种折射率为$n_1$的介质向另一种折射率为$n_2$的介质传播时，在两者的交界处（通常称作界面）若入射角小于临界角度，则会同时发生光的反射和折射。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240509174807740.png" alt="image-20240509174807740" style="zoom:33%;" /></p><p>这样不全的反射就被称为非涅尔反射。其中入射功率$P_0$，折射功率$P_f$，反射功率$P_L$关系如下：</p><script type="math/tex; mode=display">P_L=\frac{(n_1-n_2)^2}{(n_1+n_2)^2}P_0</script><script type="math/tex; mode=display">P_f=\frac{4n_1n_2}{(n_1+n_2)^2}P_0</script><h1 id="光纤传输理论"><a href="#光纤传输理论" class="headerlink" title="光纤传输理论"></a>光纤传输理论</h1><h2 id="光纤内部的全内反射（介绍）"><a href="#光纤内部的全内反射（介绍）" class="headerlink" title="光纤内部的全内反射（介绍）"></a>光纤内部的全内反射（介绍）</h2><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>在 18 世纪，人们发现光可以通过液体射流来引导，因为液体内具有高折射率，当液体穿过周围的低折射率空气时，液体内的光将会发生全反射</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240513192316679.png" alt="image-20240513192316679" style="zoom: 67%;" /></p><p>这个过程使用反射方程来建模，即可得到下图。因此，理论来说，使用一个纤芯，只要入射角满足临界角条件即可对光实现引导。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240513192443543.png" alt="image-20240513192443543"></p><p>但是上图是非常理想的core，实际制造中，core的表面其实是凹凸不平的，因此会造成一部分损耗。称之为“Surface defects”，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240513193148005.png" alt="image-20240513193148005"></p><p>因此，仅仅和使用纤芯来对光进行引导是不够的，需要在纤芯外面再加一层包层，包层折射率小于纤芯 （实际应用中通常$n_1$和$n_2$差值很小）。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240513193449446.png" alt="image-20240513193449446"></p><p>这样的结构被称为core–cladding interface (CCI)。通常根据纤芯径和包层直径来定义光纤，以微米为单位。下图是一些常见的光纤参数（不需要记）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240513194217173.png" alt="image-20240513194217173" style="zoom:50%;" /></p><h3 id="阶跃光纤内的两种传输方式"><a href="#阶跃光纤内的两种传输方式" class="headerlink" title="阶跃光纤内的两种传输方式"></a>阶跃光纤内的两种传输方式</h3><p>当一東光线从光纤端面耦合进光纤时，光纤中有两种传输的方式:</p><ul><li>一种是光线始终在一个包含光纤中心轴的平面内传播，并且一个传播周期与中心轴相交两次，这种光线常称为<strong>子</strong><br><strong>午线</strong>，包含光纤中心轴的固定平面就称为<strong>子午面</strong>，如下图(a)中MN平面所示;</li><li>另一种其传播的轨迹不在同一个平面内，并不与光纤中心轴相交，这种光线就称为斜射光线，如下图(b)所示。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240616084949190.png" alt="image-20240616084949190"></p><h3 id="子午线阶跃光纤传播模型（五星级）"><a href="#子午线阶跃光纤传播模型（五星级）" class="headerlink" title="子午线阶跃光纤传播模型（五星级）"></a>子午线阶跃光纤传播模型（五星级）</h3><div class="note info flat"><p>五星级例题，《电信传输原理 第2版》P90</p></div><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240513201828600.png" alt="image-20240513201828600"></p><p>已知纤芯半径为a，折射率为$n_1$；包层折射率为$n_2$，并且$n_1&gt;n_2$。<strong>空气的折射率为$n_0=1$</strong></p><p>因为$n_1&gt;n_2$，因此折射角大于入射角，可以发生全反射。</p><p>光线以$\phi_i$的角度，从空气$n_0$入射至$n_1$,因此有：（注意，这个地方的入射角和出射角和前面介绍的是情况互补的，但是公式依旧适用（可以用光路可逆来解释））</p><script type="math/tex; mode=display">\theta_z=arcsin(\frac{n_0}{n_1}sin\phi_i)</script><script type="math/tex; mode=display">\theta_i=90\degree-\theta_z</script><p>如果$\theta_i&lt;\theta_c$，则是上图①的情况，有部分光折射出去。若$\theta_i&gt;\theta_c$，则是②的情况，发生全反射。那么这个临界角度反应到$\phi_i$上是多少呢？记临界情况$\phi_i=\phi_0,\theta_z=\theta_{z_0},\theta_i=\theta_c$</p><script type="math/tex; mode=display">n_0sin(\phi_0)=n_1sin(\theta_{z_0})=n_1sin(90\degree-\theta_c)=n_1cos(\theta_c)</script><p>也就是说，只要求得$n_1cos(\theta_c)$的值，就可以逆推$\phi_0$</p><script type="math/tex; mode=display">n_1cos(\theta_c)=n_1\sqrt{1-sin^2(\theta_c)}</script><p>根据折射公式$n_1sin(\theta_c)=n_2$，因此有：</p><script type="math/tex; mode=display">n_1cos(\theta_c)=n_1\sqrt{1-(\frac{n_2}{n_1})^2}=n_1\sqrt{\frac{n_1^2-n_2^2}{n_1^2}}</script><p>如果将包层和纤芯的折射率的差异使用 <strong>相对折射率差</strong>$\Delta$来描述：</p><script type="math/tex; mode=display">\Delta = \frac{n_1^2 -n_2^2}{2n_1^2}\approx\frac{n_1-n_2}{n_1}</script><p>上式可以写为：</p><script type="math/tex; mode=display">n_1cos(\theta_c)=n_1\sqrt{\frac{n_1^2-n_2^2}{n_1^2}}=\sqrt{2\Delta}=\sqrt{n_1^2-n_2^2}</script><p>回到最初的$n_0sin(\phi_0)=n_1cos(\theta_c)$:</p><script type="math/tex; mode=display">\phi_0=arcsin\bigg(\frac{\sqrt{n_1^2-n_2^2}}{n_0}\bigg)</script><h3 id="光纤数值孔径（Numerical-Aperture-NA）"><a href="#光纤数值孔径（Numerical-Aperture-NA）" class="headerlink" title="光纤数值孔径（Numerical Aperture, NA）"></a>光纤数值孔径（Numerical Aperture, NA）</h3><p>不妨直接将子午线模型中的$n_0sin(\phi_0)=n_1cos(\theta_c)$直接定义为$n_0sin(\phi_0)=NA$。其中NA为光纤数值孔径，表征光纤收集光的能力。</p><script type="math/tex; mode=display">NA=n_0sin(\theta_0)=\sqrt{2\Delta}=\sqrt{n_1^2-n_2^2}</script><p>可见，纤芯与包层折射率差异$\Delta$越大，NA越大，代表光线集光能力越强。通信用的光纤NA较小，故称为<strong>弱导光纤</strong>。</p><div class="note info flat"><p>如果遇到光的接受度（light acceptance），就是NA</p></div><h2 id="光纤的传输损耗"><a href="#光纤的传输损耗" class="headerlink" title="光纤的传输损耗"></a>光纤的传输损耗</h2><p>光纤的损耗可以大体分为：</p><ul><li>光纤本身的传输损耗：由光纤本身物理性质产生的损耗。</li><li>光纤使用事引起的传输损耗：在安装时，由于弯曲/接头连接/融接等操作中引起的损耗。</li></ul><div class="note danger flat"><p>五星级</p></div><p>其中又可以分为数个小类，如下表所示。<strong>下表中前3列（就是不含最后的详细描述）要求掌握。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240516164306539.png" alt="image-20240516164306539"></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240516164432076.png" alt="image-20240516164432076"></p><div class="note info flat"><p>bnh的补充小课堂：微弯曲损耗有可能是在从光纤生产到光缆的过程中产生的。由于生产工艺造成了一些应力不均等，造成了光纤产生了非常非常微小的弯曲。</p></div><h2 id="色散特性"><a href="#色散特性" class="headerlink" title="色散特性"></a>色散特性</h2><h3 id="多模模式色散（mode-dispersion）"><a href="#多模模式色散（mode-dispersion）" class="headerlink" title="多模模式色散（mode dispersion）"></a>多模模式色散（mode dispersion）</h3><p>模式色散一般存在于<strong>多模光纤</strong>中。因为，在多模光纤中同时存在多个模式，<strong>不同模式沿光纤轴向传播的群速度不同</strong>，它们到达终端时，必定会有先有后，出现时延差，形成模式色散，从而引起脉冲宽度展宽，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240516172557207.png" alt="image-20240516172557207"></p><h3 id="材料色散（materialdispersion）"><a href="#材料色散（materialdispersion）" class="headerlink" title="材料色散（materialdispersion）"></a>材料色散（materialdispersion）</h3><p>光波在光学介质中传播时其介质材料的折射率n随波长λ变化而产生的，使得各波长的光信号传播速度不同，在接收端产生的波形时域扩展的现象。</p><h3 id="波导色散（waveguide-dispersion）"><a href="#波导色散（waveguide-dispersion）" class="headerlink" title="波导色散（waveguide dispersion）"></a>波导色散（waveguide dispersion）</h3><p>波导色散是对于光纤的某一传输模式，在不同的光波长下的群速度不同引起的脉冲展宽。它与光纤结构的波导效应有关，因此也被成为结构色散。</p><h3 id="偏振色散（Polarization-Mode-Dispersion）"><a href="#偏振色散（Polarization-Mode-Dispersion）" class="headerlink" title="偏振色散（Polarization Mode Dispersion）"></a>偏振色散（Polarization Mode Dispersion）</h3><p>一个信号脉冲沿着理想的对称圆形单模光纤在不受外界干扰情况下传输时,光纤输入端的光脉冲可分裂成两个垂直的偏振输出脉冲,以相同的的传播速度进行传输,并同时到达光纤输出端,这两个脉冲叠加在一起会重现出它们在光纤输入端时的偏振状态,实际上光纤由于上文所述的种种原因,会引起双折射,即x轴方向和y轴方向上的折射率是不一样的,这将引起偏振模色散（Polarization Mode Dispersion）</p><ul><li>多模光纤：模式色散为主</li><li>单模光纤：材料色散为主</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 电信传输理论与工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代通信网络-LC4-数据链路交换技术</title>
      <link href="/posts/a8a0740e.html"/>
      <url>/posts/a8a0740e.html</url>
      
        <content type="html"><![CDATA[<div class="note danger flat"><p>这一章节要求：能明确地对分组交换和电路交换的特征，技术等进行明确地表述。很重要！</p></div><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><em>讲故事部分</em></p><p>最开始的时候，电话终端是需要配电源的，在需要发起一次通信时，摇动电话上的手柄，通过电磁感应产生一个信号发送给接线员。接线员知道你要和那里接通和后，人工将两根金属线连通。这便是最初的人工交换机。后面出现了机电交换机，通过机械取代人工工作。后续电路开关成熟，产生了程控交换，至此，交换技术和计算机搭上界了。</p><p>在计算机的世界中，表示数字0-9至少需要4bit，那么就可以表示0-F（HEX）。因此键盘上后续加入了* 和 #，分别占A和B（HEX），0-9对应0-9（HEX）。后面几位保留。</p><p>在ch1-基本交换技术中，已经对交换进行了初步的介绍，现在的交换主要电路交换和分组交换；而这里面的细分方式又分为面向连接和和面向无连接。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/Screenshot_2024-04-19-15-14-43-656_com.miui.notes.jpg" alt="Screenshot_2024-04-19-15-14-43-656_com.miui.notes" style="zoom:50%;" /></p><p>如果带宽资源充分，分组交换的带宽资源使用率更好。但是分组交换无法确保通信持续的质量。</p><p>在通信网络中，我们需的要通信的设备称为“station”，将交换设备称为“node”。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240419153209667.png" alt="image-20240419153209667" style="zoom: 50%;" /></p><p>通信网络是由一个一个node连接构成，node可以互相交换数据，也可以将数据发送给station。不同的nodes之间可能没有直接的通路，因此需要一个中间介质来进行转发。</p><h1 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h1><p>电路交换的定义在 <em>CH1-OVERVIEW</em>中有详细介绍。</p><p>在曾经电路交换盛行的时候，其组成的网络被成为交换网络，每一个节点被成为交换机。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240424163554667.png" alt="image-20240424163554667"></p><p>以前拨打长途电话需要加区号，例如重庆是023，这一层就是供给Long-distance office 选择通路使用，后面的本地号码供给end office 选择通路使用。这样的号码是提供给交换机用的，属于“控制数据”。建立连接后通话的数据，为“业务数据”。</p><p>在电路交换中，含有控制数据的帧，被成为“信令”，类比与计算机网络中就是“协议”。</p><p>在拨号完成后，交换机只接收到了信令，此时正在完成通路的建设（建立连接）。最初使用电路交换时，信令也是分层的，但其来源于OSI模型（现在计算机网络是TCP/IP），其作用是建立连接，释放连接。</p><p>在连接建立完成后，<strong>电路交换的“业务数据”是没有头部的</strong>。这是电路交换中的“透明传输”。与计算机网络的透传有点差异的是，计算机网络中Header会被读取，只是不关心payload。而电信网络中业务数据没有Header。</p><div class="note info flat"><p>透明传输指的是，在通信过程中，通信的模块不关心payload的内容，只是根据自己的协议将你的Payload送到目的地，再将payload交由其他东西处理。</p></div><h1 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h1><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><div class="note info flat"><p>在CH1-OVERVIEW中对分组交换原理有详细介绍</p></div><p>最初，电路交换是为电信网络业务而生；分组交换是为计算机网络业务而生。分组交换中，一个packet会同时包含payload和header（控制信息）。</p><p>但是在某一段时期，运营商推了一个叫做“IP”电话的业务，主要面向低资费长途业务，深受小情侣青睐。这是因为在长途传输时，如果使用传统的电路交换，通信资源占用很大。而IP电话在长途传输的跨省节点间使用分组交换，大大降低了通信成本。但最初IP电话的通信质量并不高。</p><p>分组交换的特性决定了，它一定是先存储后转发（必须先存一个完整的packet，再发送出去）；对比电路交换，电路交换的存储（缓冲）都是比特级的。因此分组交换的延迟更大，同时对缓存空间有更大的要求。</p><div class="note info flat"><p>从上面这段也可看出，每个节点都有自己的时延，不单单只有传播时延迟。这些时延可能是分组交换下的排队时延，错误造成的节点阻塞等等造成的。</p></div><p>在分组交换中，通常会以流量限制来避免通信链路阻塞。因为通信链路阻塞（缓存溢出）会导致数据被丢弃，因此要尽量避免阻塞。</p><h2 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h2><p>在CH1中对数据报的大概工作原理，“路由”的概念已经有了一个基础介绍。</p><p>如下图所示，datagram不一定会让各个数据走同样的路由。因此可能出现数据乱序。同时，因为中间节点需要先缓存再转发，因此转发时延明显更大。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240426142610258.png" alt="image-20240426142610258" style="zoom: 80%;" /></p><h2 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h2><p>虚电路虽节点都有各自的路由表，但一旦路由建立，路径便不会再做更改。它中间路由的节点只需要查看数据包从哪来，然后换上新的要到哪去的标签，因此它中间的转发时间没有datagram那么多。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240426143018970.png" alt="image-20240426143018970" style="zoom:80%;" /></p><h2 id="虚电路和数据报比较"><a href="#虚电路和数据报比较" class="headerlink" title="虚电路和数据报比较"></a>虚电路和数据报比较</h2><h3 id="Virtual-circuits"><a href="#Virtual-circuits" class="headerlink" title="Virtual circuits:"></a>Virtual circuits:</h3><ul><li>路径不可变换，因此链路保证时序。</li><li>转发更加迅速</li><li>可靠性不如数据报</li></ul><h3 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h3><ul><li>路径可变换，更灵活</li><li>不需要进行呼叫建立(call setup)</li><li>更可靠</li></ul><h2 id="分组大小和传输时间"><a href="#分组大小和传输时间" class="headerlink" title="分组大小和传输时间"></a>分组大小和传输时间</h2><p>下图展示了不同分组大小和传输时间间的关系。这个分组的大小被称之为“交换粒度”。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240426144119945.png" alt="image-20240426144119945"></p><p>包越大，交换时粒度越粗。但有时数据比较小也要用很大一个包。可以看到，越小的包，Header开销越大。</p><p>有些包长短可调，这种对个体而言是有优势的。但是不利于系统，因为可变的包必须要先读header来确认包大小。或是在头和尾引入特定的编码来分割payload，这也是额外的开销。</p><h1 id="一个典型的虚电路——ATM"><a href="#一个典型的虚电路——ATM" class="headerlink" title="一个典型的虚电路——ATM"></a>一个典型的虚电路——ATM</h1><h2 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h2><div class="note info flat"><p>ATM这部分要求不太多，但是它是虚电路交换的代表，所以需要有个概念。这一章节要求通过ATM例子掌握“虚电路”的核心概念。</p></div><p>ATM是一种典型的分组-虚电路交换。</p><p>一开始，电信网络和计算机网络分别采用了Circuit switching(CS) 和 Packet Switching(PS)。他们各自都清楚自己的优缺点。ATM是便在这二者之间取了一个平衡。它有Packet的概念，同时通信之前又需要建立连接，且路由路径恒定。</p><p>ATM传输以<strong>信元</strong>（cell）为单位，每个信元<strong>固定53字节</strong>，其中Header是<strong>5字节</strong>。交换机通过点对点的ATM链路相互连接，称为“接口”（interfaces）。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240508165429927.png" alt="image-20240508165429927" style="zoom:50%;" /></p><div class="note danger flat"><p>五星级：ATM传输以<strong>信元</strong>（cell）为单位，每个信元<strong>固定53字节</strong>，其中Header是<strong>5字节</strong>。</p></div><h2 id="ATM的特点"><a href="#ATM的特点" class="headerlink" title="ATM的特点"></a>ATM的特点</h2><ul><li>帧时序为顺序</li><li>使用固定的信元长度</li><li>以离散的块打包数据</li><li>一个物理连接上支持多个逻辑连接</li><li>有差错和流量控制能力，但不多</li></ul><h2 id="协议层模型"><a href="#协议层模型" class="headerlink" title="协议层模型"></a>协议层模型</h2><p>如下图，ATM是一个运作在物理层之上的协议。其上层必须是AAL层，该层提供了5中不同的业务模型接口,在3G网络中，用得比较多的是语音接口和数据接口。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240508163129682.png" alt="image-20240508163129682" style="zoom:50%;" /></p><h2 id="ATM接口"><a href="#ATM接口" class="headerlink" title="ATM接口"></a>ATM接口</h2><p>ATM的交换/接入节点被称为接口。其中和用户连接的被成为 “User-network interface (UNI)”，节点与节点间连接的被成为 “network node interface (NNI)”。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240508165429927.png" alt="image-20240508165429927" style="zoom:50%;" /></p><h2 id="ATM信元"><a href="#ATM信元" class="headerlink" title="ATM信元"></a>ATM信元</h2><h3 id="逻辑连接"><a href="#逻辑连接" class="headerlink" title="逻辑连接"></a>逻辑连接</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240508165827127.png" alt="image-20240508165827127" style="zoom: 67%;" /></p><p>说ATM是虚电路的代表，是因为在不同的节点间，共享了物理通路，但是又分割出了不同的逻辑通路和逻辑信道。上图是ATM中信元结构图，可以看到在header中有一个Vitural Path Indentifier (VPI) 和 Virtual Channel Identifier (VCI)，这就是逻辑连接的标识头。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240508165802628.png" alt="image-20240508165802628" style="zoom: 50%;" /></p><p>上图中，physical transmission path 含有多个Vitual Path，使用VPI标识，VP内又有多个Virtual Channel，使用VCI标识。</p><p>由于所有通向这个大区域的数据都具有同样的VPI，在进行大粒度交换时只需要看VPI即可。</p><p>如果一个交换机同时根据Cell的VPI和VCI进行交换，那么它可以完成更小粒度的交换。</p><p>这是ATM提供不同交换粒度的原理。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/1715159981965.jpg" alt="1715159981965" style="zoom:80%;" /></p><p>在网络中的每个节点内，都存有一张表。表内存有一组输入的VPI&amp;VCI，一组输出的VPI&amp;VCI，这二者标识了一个唯一的设备。交换机根据VCI和VPI进行交换。</p><h3 id="信元流控差异"><a href="#信元流控差异" class="headerlink" title="信元流控差异"></a>信元流控差异</h3><p>UNI和NNI间使用不同的信元格式。UNI Header内有一段流控的头(GFC)，位于octet1 的5:8 bit，而NNI没有。其余部分没有差异，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240508165827127.png" alt="image-20240508165827127" style="zoom: 67%;" /></p><p>在ATM中，流量控制只由终端控制，中间节点不控制。</p><p>形象点说就是，堵车有两种解决方式：</p><ol><li>每个路口都站个警察或者用红绿灯管控；</li><li><p>根据路上的流量实行限行政策，让部分用户不能开车。</p><p>ATM就是使用的这里面的第二个。</p></li></ol><p>前面ATM的特点中说：ATM有流控，但不多。就是因为它只在终端做流控，有一定几率出现某几个线路上车过多的情况。</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>通信系统常用差错控制方法有三种：</p><ul><li>自动重发请求法（ARQ）:接收端译码器判决收到的码序列有没有错误，通过反馈信道把判决结果告诉发送端。发送端根据判决信号重发接收端认为有错的信息，直到接收端认为正确为止。需双向信道。这个技术前面有所讲解。</li><li>前向纠错法（FEC）:接收端不仅能发现错误而且能自动纠正接收码字传输中的错误。比如Turbo码和卷积码。实时性较好，但编译码设备随着纠错能力强而变得复杂，往往以最坏的信道条件来设计纠错码，编码效率降低。</li><li>信头差错校验法（HEC）:接收端能检测错误，而且有纠错能力。纠错能力内，自行纠错，若错误很多，超出了码纠错能力，则反馈给发送端让其重新传送有错的信息。克服上两者的缺点。</li></ul><p>这里ATM使用的就是HEC。</p><div class="note info flat"><p>后续PPT内容不作要求</p></div>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 现代通信网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代通信网络-LC5-局域网</title>
      <link href="/posts/6b68dff2.html"/>
      <url>/posts/6b68dff2.html</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>本章节以局域网的视角，将物理层、数据链路层、网络层三层进行链接。前面课程虽没有涉及物理层内容，但其他课程（例如通信原理）已经打下了基础。</p><h2 id="几种路由方式"><a href="#几种路由方式" class="headerlink" title="几种路由方式"></a>几种路由方式</h2><p>寻找路由，有几种不同的方式：</p><ul><li>集中式：有一个节点对网络所有节点和拓补状态都非常了解，中心路由找出的路径是最优的。但是集中控制代价极高，而且有同步周期问题（需要不断从整个网络收集信息，需要收集耗费的时间尽可能短）</li><li>分布式：交换由每个节点完成，路由更复杂，但是鲁棒性更高</li></ul><p>对于面向连接和面向无连接，决定路由的时机也不一样。</p><ul><li>面向连接需要在通信之前就确定路由，并固定线路。</li><li>而面向无连接只有到达特定的节点后，下一条路的路由才会出现。</li></ul><h2 id="现有的4种路由模式"><a href="#现有的4种路由模式" class="headerlink" title="现有的4种路由模式"></a>现有的4种路由模式</h2><ul><li><p>Fixed：在该模式下，某一进来的包固定得被转发至一个固定的出口</p></li><li><p>Flooding</p></li><li><p>Random</p></li><li><p>Adaptive Routine：这是目前分组交换网络中大量采样的路由方式。这种路由属于需要各节点的信息，根据当前的信息进行自适应路由，但在集群规模的扩大时，收集信息会导致网络时延增加、部署成本提高，无法满足算力需求和部署要求。</p></li></ul><h1 id="物理层的视角切入局域网（基于以太网）"><a href="#物理层的视角切入局域网（基于以太网）" class="headerlink" title="物理层的视角切入局域网（基于以太网）"></a>物理层的视角切入局域网（基于以太网）</h1><h2 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h2><h3 id="纯ALOHA"><a href="#纯ALOHA" class="headerlink" title="纯ALOHA"></a>纯ALOHA</h3><ol><li>当传输点有数据需要传送的时候，它会立即向通讯频道传送，这也就是“想说就说”。</li><li>接收站通过检查帧校验序列字段来确定传入帧的正确性</li></ol><ul><li>如果正确，会给传输站点发送ACK。传输站点等待ACK的时间是2倍物理传输时长+一个小小的增量</li><li>如果接收的数据有错误，接收点会向传输点发NACK。</li><li>如果网络上的两个传输点同时向频道传输数据的时候，<strong>会发生碰撞</strong>（因此说ALOHA是一个竞争协议），这种情况下，两个站点会各自等待一段随机长度的时间后，再次尝试发送。</li></ul><p>但是，如果站到站的传播时间比帧传输时间长，那么，在一个站发射一个帧之后，需要很长时间其他站才知道它。在此期间，其他站可能会开始传输帧，这会导致所有帧损毁。</p><p>纯ALOHA非常简单，但这样也带来了缺点：随着负载的增加，碰撞次数迅速增加，通道的最大利用率仅为18%左右。</p><h3 id="slotted-ALOHA（分段ALOHA）"><a href="#slotted-ALOHA（分段ALOHA）" class="headerlink" title="slotted ALOHA（分段ALOHA）"></a>slotted ALOHA（分段ALOHA）</h3><p>为了ALOHA的利用率，将信道在时间上进行<strong>分为不同的子时段</strong>，每个传输点只能在一个<strong>子时段</strong>的<strong>开始处</strong>进行传送。每次传送的数据<strong>必须少于或者等于一个子间段</strong>。这样大大的减少了传输频道的冲突。</p><p>但是也提出了链路上时钟同步的要求。</p><p><strong>slotted ALOHA将系统的最大利用率提高到约 37%</strong></p><h2 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h2><p>就算是slotted ALOHA，利用率也还是太低了。无论是纯ALOHA还是slotted ALOHA，都缺少对信道当前状态的侦测，如果能不要“畅所欲言”，而是如果发现别人在说话，等别人说完了再发言，那么碰撞概率会进一步减小。</p><p>因此我们引入CSMA</p><p>CSMA：carrier sense multiple access，载波侦听多路访问（注意是multiple access，不是multiplex）</p><ul><li><strong>载波侦听</strong>（Carrier Sense）： 指任何连接到介质的设备在欲发送帧前，必须对介质进行侦听，当确认其空闲时，才可以发送。 </li></ul><h3 id="nonpersistent-CSMA"><a href="#nonpersistent-CSMA" class="headerlink" title="nonpersistent CSMA"></a>nonpersistent CSMA</h3><p>在该模式下：</p><ol><li>发信设备侦听信道是否空闲</li></ol><ul><li>如果空闲：则立即开始发信</li><li>如果不空闲：则随机或固定地等一段时间后再检查是否空闲</li></ul><p>nonpersistent CSMA有一个缺陷：无法确定在信道传输的信息处于什么状态，可能处于比特流的头两个字，这时候延时可能等少了。如果处于比特流最后两个字，这时候可能等多了，造成时间的浪费</p><p>因此，引入 1-persistent protocol：</p><h3 id="1-persistent-CSMA"><a href="#1-persistent-CSMA" class="headerlink" title="1-persistent CSMA"></a>1-persistent CSMA</h3><ol><li>发信设备检查信道是否空闲</li></ol><ul><li>如果空闲：立即发信</li><li>如果忙：则持续侦听，一旦忙结束，立即发信</li></ul><p>但是这样又产生了一个问题：如果信道资源很紧缺，一个忙当中，有多个发信站都在等待忙结束，在忙结束之后又立即发信，在空闲瞬间的“蜂拥而至”会导致帧碰撞。</p><p>因此，引入 is p-persistent：</p><h3 id="p-persistent-CSMA"><a href="#p-persistent-CSMA" class="headerlink" title="p-persistent CSMA"></a>p-persistent CSMA</h3><ol><li>如果信道空闲，则有概率p的可能发送，（1-p）的概率再等一个等待周期</li><li>如果信道忙，则持续侦听，等到空闲时执行 1 当中的概率发送</li></ol><p>这个方法减少了“蜂拥而至”造成的碰撞的概率。</p><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><p>在前面的CSMA机制中，纵然比AHLOHA效率更高，但是对碰撞的处理并不完善：如果两帧发生碰撞，在碰撞发生后发送端仍然会发送完该帧才截止，这加剧了碰撞占用信道的时间。</p><p>而CSMA/CD中的CD就是“Collision Detection”，碰撞检测。在CSMA/CD模式下，网络适配器会“边发送边侦听”。在CSMA/CD机制下：</p><ul><li>如果信道空闲，则直接发信</li><li>如果信道忙，则遵循CSMA的规则，侦听信道直到其不忙</li><li>如果在传输过程中任意站点检测到冲突，则发送一个人为的干扰信号（jamming signal），让所有站点都知道发生了冲突，然后停止传输。</li><li>（问题：碰撞时的jamming signal是怎么传过去的)（解答：bnh也不知道，那就是不考罢，哎……）</li><li>发送干扰信号后，等待一段随机时间（称为退避，backoff），然后尝试再次发送（回到第一步）。</li></ul><p>CSMA/CD的一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240515165805420.png" alt="image-20240515165805420" style="zoom:50%;" /></p><p>补一下：看一下中文书的这一段</p><h1 id="数据链路层的视角——拓补和交换"><a href="#数据链路层的视角——拓补和交换" class="headerlink" title="数据链路层的视角——拓补和交换"></a>数据链路层的视角——拓补和交换</h1><div class="note danger flat"><p>五星级中的五星级</p></div><h2 id="基本拓补形式"><a href="#基本拓补形式" class="headerlink" title="基本拓补形式"></a>基本拓补形式</h2><h3 id="Star拓补"><a href="#Star拓补" class="headerlink" title="Star拓补"></a>Star拓补</h3><p>Star拓补中这个中心节点有三种：Hub， switch，repeater。这三种设备工作在不同的层。工作的效果也不一样。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240515175041205.png" alt="image-20240515175041205" style="zoom:33%;" /></p><p><strong>HUB（集线器）:物理层设备</strong></p><p>HUB集线器属于纯硬件网络底层设备，基本上不具有类似于交换机的“智能记忆”能力和“学习”能力。它也不具备交换机所具有的MAC地址表，所以它发送数据时都是没有针对性的，而是采用<strong>广播方式</strong>发送。也就是说当它要向某节点发送数据时，不是直接把数据发送到目的节点，而是把数据包发送到与集线器相连的所有节点。<strong>因此，HUB下依旧需要使用CSMA/CD协议。</strong></p><h2 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h2><p>Brige是一个</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h2 id="拓补"><a href="#拓补" class="headerlink" title="拓补"></a>拓补</h2><p>（spanning Tree）</p><h2 id="MAC帧的结构（要求掌握！五星级）"><a href="#MAC帧的结构（要求掌握！五星级）" class="headerlink" title="MAC帧的结构（要求掌握！五星级）"></a>MAC帧的结构（要求掌握！五星级）</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240522165158941.png" alt="image-20240522165158941"></p><p>MAC地址用于唯一标明终端。理论上来说它不可改变，但是现在有技术可以在发送时使用虚拟的MAC地址。携带MAC地址的DPU如上图所示</p><h3 id="Address-Learning"><a href="#Address-Learning" class="headerlink" title="Address Learning"></a>Address Learning</h3><p>在MAC地址下，当机器携带MAC地址开始发送信息时，交换设备就会知道：“这个MAC地址的机器在我的某个端口上”。就会将它加入自己的路由数据库。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240522171933209.png" alt="image-20240522171933209"></p><p>但是这个有一个问题，假设B是新加入的。$\alpha$和$\beta$都没有对B的位置进行注册。此时，A朝B发送一个帧，首先$\alpha$和$\beta$都会收到并认为A在下方，假设$\alpha$先转发，$\alpha$转发的帧会被B同时被B和$\beta$收到，$\beta$就会认为A在B侧；同理，后续$\beta$转发的也会被A，此时$\alpha$会记录A在B侧。这样就出问题了，假设B要发生一个返回给A，那么此时无论是$\alpha$还是$\beta$都认为AB在同侧，都不进行转发。</p><p>在设计Spanning Tree 算法时，需要避免这样的逻辑环路。</p><h1 id="点对点协议（PPP）"><a href="#点对点协议（PPP）" class="headerlink" title="点对点协议（PPP）"></a>点对点协议（PPP）</h1><p>PPP：Point-to-point Protocol</p><h1 id="连接数据链路层与网络层的协议——Address-Resolution-Protocol-ARP"><a href="#连接数据链路层与网络层的协议——Address-Resolution-Protocol-ARP" class="headerlink" title="连接数据链路层与网络层的协议——Address Resolution Protocol (ARP)"></a>连接数据链路层与网络层的协议——Address Resolution Protocol (ARP)</h1><p>(ARP高速缓存是什么东西，要求理解)</p><p>（ARP的四个步骤 要求掌握）</p><p>这是用来处理MAC地址和IP地址关系的协议。由于IP协议使用了ARP协议，因此常常将ARP协议划归网络层。有些地方也将其划归数据链路层，因为ARP消息直接<strong>封装MAC帧内，而非IP包</strong>。ARP本质是跨接地三层和第二层的协议。</p><p>在局域网中，交换机和其对应的MAC地址工作在数据链路层（第二层），而IP工作在网络层（第三层）。</p><p>在一个网络中：(这个流程要求记住)</p><ul><li>在局域网内，Router存储有一个路由表，将各个设备的IP地址与MAC地址相映射。如果要转发的IP包的MAC地址已经在表中，则直接将其发送到对应端口上。</li><li>如果需要传输给一个已知IP地址，未知MAC地址的设备。那么路由将暂存这一帧数据，直接使用ARP在LAN上进行广播“我的IP是：xxx，硬件地址是：xxx，我想知道IP地址xxx的MAC地址”，寻找到对应IP地址的设备，让它回应自己的MAC。拿到MAC后再封包发送。</li><li>当局域网内的设备发现ARP请求的IP和自己的IP地址匹配时，则应答，应答消息包含自己的IP地址和MAC地址，单播发送给请求站点。</li><li>ARP 消息还可以简单地用于广播主机的 IP 地址和子网地址，以便让LAN上的其他设备可以获取。</li></ul><p>现在介绍的ARP和IP，都是在同一个局域网上的。那如果你身在重庆，但是要和北京的一个设备通信，那这时候又如何解决呢？ARP协议仅能在一个广播域内进行查询，而这个广播域是通过IP地址划分的（同一网段IP）。</p><ul><li>路由器在收到数据时会将目标IP与局域网IP检查一下，如果发现不为同一网段，则会请求网关IP地址的MAC</li><li>然后将这一帧数据朝网关发送，辅助网络完成下一跳。</li></ul><div class="note info flat"><p>课堂问题:</p><ol><li>交换机每个端口需要配备自己的MAC地址吗？</li></ol><p>​    不需要。因为交换机工作在第二层，只看你请求的MAC是否再它已知的端口上，如果是，则朝特定端口发送；如果不是，则朝口上广播或朝特定端口发送。</p><ol><li>路由器的每个端口需要自己的MAC地址吗？</li></ol><p>​    需要。因为路由器工作在第三层，每个端口连接不同的局域网。正如上面ARP所说，需要朝路由器的某个端口发送ARP请求，将包发给这个端口，再由这个端口根据路由协议转发至另外的路由端口。</p></div><div class="note info flat"><p>如果大家折腾一下软路由OpenWRT系统就会发现，那里面有一张路由表。这就是由ARP协议请求出来的。表上记录了每个设备的MAC、IP、端口。此时会发现，这个路由器竟然只有两个端口！</p><p>其实这是由于家用路由器的路由端口只有2个导致的，平时路由器会看到一个WAN口加数个LAN口，这些LAN口之间都工作在第二层，公用一个MAC和IP；WAN口有一个MAC和IP。我们访问路由器的后台其实就是在访问路由器LAN口的IP地址。</p></div>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 现代通信网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电信传输理论-CH5-金属传输线理论</title>
      <link href="/posts/3f7b092c.html"/>
      <url>/posts/3f7b092c.html</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><div class="note danger flat"><p>这一章的传输理论知识和实例分析都非常重要。</p></div><ul><li><p>一条传输线中，波的参考的起始点称为“The driving point”，该point非传输线的头尾两端。因为在研究传输线时，研究的不是它的头尾，而是中间这一部分的特质。头尾需要单独讨论。</p></li><li><p>我们认为传输，是在远距离尺度上的。因此需要主要关注传输线上的时间差等。同时，由于干扰，传输线频率选择性衰减等因素，发射出去的放波会失真，在时域展宽等。</p></li><li><p>只有在长线分布下，才认为线内的电容，电阻等是均匀分布的。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240604102154339.png" alt="image-20240604102154339" style="zoom:67%;" /></p><p>常见的金属传输线有上图4种，其中，平行双导线的英文是 twin-wire。本章节主要研究平行双导线，其他的简略。平行双导线随着传输的工作频率增高，其辐射损耗会急剧增加，故这种传输线只适合于1000米波至大于10米波的低频段。</p><h1 id="金属传输线（主要以双线为例）"><a href="#金属传输线（主要以双线为例）" class="headerlink" title="金属传输线（主要以双线为例）"></a>金属传输线（主要以双线为例）</h1><p>双线（twin-wire），是指的由两条传输线线构成一个完整的传输系统，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240604100252546.png" alt="image-20240604100252546" style="zoom:80%;" /></p><p>最典型的双线就是双绞线。双绞线也是金属线传播的一种典例，大部分金属线与双绞线分析方式类似。</p><p>在本课ch3中简略介绍过双绞线，在分析双绞线时，我们以微积分的概念将其切分，认为它们是平行的。在前面是对双绞线的感性认知，这一部分会更深入地学习。</p><div class="note info flat"><p>bnh科普小课堂：虽然看起来现在无线通信，光通信使用远比金属传输线广，但是AI军火商NVIDA认为，在极短距离传输下（芯片内部），金属传输先比现有的光通信更有优势。因此金属传输先仍有很大研究价值</p></div><p>1234123</p><div class="note info flat"><p>bnh科普小课堂：在金属线中让电磁波泄漏：回想一些LRC震荡电路，在理想情况下，这种电路会在线路内无限震荡。但如果在线上开一个口子，那么电磁波便会辐射出去。无线通信使用天线来开这个口子，以增强对泄露出去的电磁波的控制能力。</p></div><h2 id="长线的定义："><a href="#长线的定义：" class="headerlink" title="长线的定义："></a>长线的定义：</h2><p>当传输线的长度L比其上所传输的电磁波的最小波长$\lambda_{min}$还长，即$L\geq\frac{\lambda_{min}}{100} $时，传输线称为长线，反之则称为短线。（在英文书上这里是$L&gt;&gt;\frac{\lambda_{min}}{100}$,bnh原话：以中文书为准更好，大于等于刚好有个界限）</p><p>下图为长线模型：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240418164433479.png" alt="image-20240418164433479"></p><p>长线的电气特性它的可以用每单位长度串联电阻，串联电感，并联电容，并联电导来描述。一个理想的长线传输线，在线路上的任意一点切入，其电气特性都一样。</p><h2 id="传输线的基本特性参数"><a href="#传输线的基本特性参数" class="headerlink" title="传输线的基本特性参数"></a>传输线的基本特性参数</h2><div class="note danger flat"><p>本小节中的五星级指标: $\gamma$ 和 $Z_0$</p></div><h3 id="理想模型"><a href="#理想模型" class="headerlink" title="理想模型"></a>理想模型</h3><p>如果认为是纯纯的理想长线，没有电阻，电感，电容等，那么行波在长线中的传输可以用如下公式描述：</p><script type="math/tex; mode=display">v=Vsin\omega t</script><ul><li>V：信号振幅</li><li>$\omega$：信号频率</li></ul><h3 id="相移常数-beta-（phase-change-coefficient）"><a href="#相移常数-beta-（phase-change-coefficient）" class="headerlink" title="相移常数$\beta$ （phase change coefficient）"></a>相移常数$\beta$ （phase change coefficient）</h3><p>如果将电磁波传播速度引入传输线中，电磁波传输造成的延迟，会造成信号的相位变化。因此，引入<strong>相移常数$\beta$</strong>对此进行建模。</p><script type="math/tex; mode=display">v=Vsin(\omega t-\beta x)</script><ul><li>$\beta$：相移常数（单位：rad/m）</li><li>$x$​：距离参数（单位：m）</li></ul><p>其中$\beta$定义为：</p><script type="math/tex; mode=display">\beta=\frac{2\pi}{\lambda}</script><ul><li>$\lambda$：波长（单位：m）</li></ul><p>物理意义的理解：一个周期的相位变化是$2\pi$，而波长又是波一个周期的长度。因此$2\pi/\lambda$是单位长度上相位变化的程度。</p><p>此时，传输线模型如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240418171045657.png" alt="image-20240418171045657"></p><h3 id="相速度-v-p-（phase-velocity）"><a href="#相速度-v-p-（phase-velocity）" class="headerlink" title="相速度$v_p$ （phase velocity）"></a>相速度$v_p$ （phase velocity）</h3><p>对金属线中的行波进行连续“拍照”，会发现它的波峰随着时间在向前移动。这样的波的相位在空间中传递的速度，我们称之为<strong>相速度$v_p$</strong>。对比一下前面的相移常数，相移常数指的是在固定时刻，随着单位距离移动波的相位变化量。而相速度是指的某一点个相位点，随着单位时间变化相位的变化量。下图中红色点就是相速度。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/Wave_group.gif" alt="Wave_group"></p><p>考虑下图，在$P_1$和$P_2$点相位相同，距离为$Z_1-Z_2$</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240604104220293.png" alt="image-20240604104220293" style="zoom: 67%;" /></p><p>按照相速度的定义来说：</p><script type="math/tex; mode=display">v_p=\frac{同相位点移动的距离}{时间差}=\frac{Z_2-Z_1}{t_2-t_1}</script><p>回顾前面的建模式子：$v=Vsin(\omega t-\beta x)$,某一时刻的相位是由sin括号内的部分来表达的。对于$P_1$点，其相位为$\omega t_1 -\beta Z_1$；同理$P_2$点为$\omega t_2 -\beta Z_2$；</p><p>由于$P_1$和$P_2$相位相同，有：$\omega t_1 -\beta Z_1=\omega t_2 -\beta Z_2$，移项改写一下：</p><script type="math/tex; mode=display">\omega (t_2-t_1)=\beta(Z_2-Z_1)</script><p>因此</p><script type="math/tex; mode=display">v_p=\frac{Z_2-Z_1}{t_2-t_1}=\frac{\omega}{\beta}</script><p>因为$\omega =\frac{2\pi}{T}=2\pi f,\beta=\frac{2\pi}{\lambda}$因此$v_p$还可以写成:</p><script type="math/tex; mode=display">v_p=\frac{\omega}{\beta}=f\lambda</script><h3 id="衰减常数-alpha"><a href="#衰减常数-alpha" class="headerlink" title="衰减常数$\alpha$"></a>衰减常数$\alpha$</h3><p>随着距离延长，传输线中衰减是不可不免的。而这种衰减与距离高度相关。因此我们再加上<strong>衰减常数$\alpha$(单位：奈培/米)</strong></p><div class="note danger flat"><p>这个式子需要记住，五星级</p></div><script type="math/tex; mode=display">v=Ve^{-\alpha x}sin(\omega t-\beta x)</script><p>对于在一条线上相隔单位距离的两个电压幅度的比率，𝑉1和𝑉2有：</p><script type="math/tex; mode=display">V_1/V_2=e^{\alpha}</script><p>这就是信号振幅每单位的衰减程度，<strong>衰减系数以 奈培/单位距离 为单位</strong>。假设$\alpha=1\ neper/m$，在么每米振幅衰减的比率就是</p><script type="math/tex; mode=display">V_1/V_2=e</script><p>如果将其转化为dB的形式，也就是每米衰减8.686dB</p><script type="math/tex; mode=display">20log_{10}(V_1/V_2)=20log_{10}(e)=8.686dB</script><h3 id="特征阻抗-Z-0-（characteristic-impedance）和集肤效应（skin-effect）"><a href="#特征阻抗-Z-0-（characteristic-impedance）和集肤效应（skin-effect）" class="headerlink" title="特征阻抗$Z_0$（characteristic impedance）和集肤效应（skin effect）"></a>特征阻抗$Z_0$（characteristic impedance）和集肤效应（skin effect）</h3><p>特征阻抗（Characteristic impedance）是指在传输线（例如电缆、微带线、同轴电缆等）中传播电磁信号时，该传输线上单位长度内的阻抗。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240418164433479.png" alt="image-20240418164433479"></p><p>在这样的一节传输线中，特征阻抗的计算公式是：</p><script type="math/tex; mode=display">Z_0=\sqrt{\frac{R+j\omega L}{G+j\omega C}}\ (五星级公式)</script><p>如果是理想传输线，无电阻电导，即R，G=0， $Z_0$此时可写为</p><script type="math/tex; mode=display">Z_0=\sqrt{\frac{L}{C}}</script><p>如果满足特殊条件：$\frac{R}{L}=\frac{G}{C}$，上述式子也成立：</p><script type="math/tex; mode=display">Z_0=\sqrt{\frac{L(R/L+j\omega)}{C(G/C+j\omega)}}=\sqrt{\frac{L}{C}}</script><p>在这个式子中，L和C是独立的，与频率无关。但是R和G会收到频率的影响，这是由于集肤效应（又称趋肤效应）引起的。</p><p><strong>Skin Effect（集肤效应）</strong></p><p>当导体中有交流电或者交变电磁场时，导体内部的电流分布不均匀，电流集中在导体的“皮肤”部分。也就是说电流集中在导体外表的薄层，越靠近导体表面，电流密度越大，导体内部实际上电流较小，这减少了导体的有效面积，也就增大了电阻。这种现象随着频率的增大愈发明显，这一现象称为趋肤效应(skin effect)。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240422194126224.png" alt="image-20240422194126224" style="zoom:50%;" /></p><p>这是平行双导线不适合高频信号的原因之一。</p><h3 id="传输常数-gamma"><a href="#传输常数-gamma" class="headerlink" title="传输常数$\gamma$"></a>传输常数$\gamma$</h3><p>按照前面建立的模型，$v=Ve^{-\alpha x}sin(\omega t-\beta x)$，如果使用一个向量来表示$Vsin(\omega t-\beta x)$中随着距离衰减的部分（即，只和$\beta$相关的部分），那么有：假设向量是$a+jb$</p><p>向量的实数就是当前$\beta$造成的电压衰减值，因为在电磁波表示中sin和cos是比较通用的，因为从物理意义上来说，$\beta$在$x=0$处造成相位移动为0，因此用cos来表达。</p><script type="math/tex; mode=display">a=Vcos(-\beta x)</script><p>虚部是波存储起来的电压部分，满足$实数^2 + 虚数^2$=1，因此有</p><script type="math/tex; mode=display">b=Vsin(-\beta x)</script><p>将$a+jb$用欧拉公式表示，有：</p><script type="math/tex; mode=display">a+jb=e^{-j\beta x}</script><p>如果把这个信号自己的电压状态（也就是前面和角频率有关的振幅）记为向量$V_0$，那么传输线上某一点的电压可以表示为</p><script type="math/tex; mode=display">V_x=V_0e^{\alpha x}e^{-j\beta x}=V_0 e^{-(\alpha+j\beta)x}</script><p><strong>其中，这个$\alpha+j\beta$就被称为传输常数，记作$\gamma$</strong>，原式可以写成：</p><script type="math/tex; mode=display">\gamma=\alpha+j\beta</script><script type="math/tex; mode=display">V_x=V_0e^{-\gamma x}</script><h3 id="群速度"><a href="#群速度" class="headerlink" title="群速度"></a>群速度</h3><p>相速度是某一个相位点向前移动速度。如果说所有频率的波在同一媒介中传播的相速度都相同，那这没有问题；然而，事实情况是不同频率的波在介质中传播的相速度不同（从相速度的式子就可以看出它和频率有关），因此需要一个物理量来描述其包络的行进速度，也就是群速度。<strong>群速度$v_g$是所有的波组合起来的包络的向前移动的速度</strong>。在下图中，绿色的点就是群速度。群速度常被认为是能量或信息顺着波动传播的速度。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/Wave_group.gif" alt="Wave_group"></p><div class="note info flat"><p>因不同频率的电磁波在介质中具有不同的相速度而造成电磁信号失真的现象就被称为电磁波色散。</p></div><p>试想一下，有两个正弦波，其各项参数分别为</p><div class="table-container"><table><thead><tr><th style="text-align:center">波1</th><th style="text-align:center">波2</th></tr></thead><tbody><tr><td style="text-align:center">$\omega$</td><td style="text-align:center">$\omega +d\omega$</td></tr><tr><td style="text-align:center">$v_p$</td><td style="text-align:center">$v_p+dv_p$</td></tr><tr><td style="text-align:center">$\lambda$</td><td style="text-align:center">$\lambda+d\lambda$</td></tr><tr><td style="text-align:center">$\beta$</td><td style="text-align:center">$\beta+d\beta$</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240604121723352.png" alt="image-20240604121723352" style="zoom: 67%;" /></p><p>试想一下，现在你站在P1点随着波1移动，波2的尖峰刚好和你重合，你们形成了包络中鼓起来的最高点。同时，在P1的视角下，波2在以$dv_p$的速度向前移动。经过一段时间之后，P1处的尖峰分开，而P2前面的波2尖峰追上了P2，此时P2处形成包络最高点。此时，看起来就像是包络从P1运动到了P2。而经过的这一段时间是：</p><script type="math/tex; mode=display">t=\frac{d\lambda}{dv_p}</script><p>同时，包络的尖峰从P1移动到了P2，刚好移动了波1的波长长度$\lambda$。用包络尖峰移动的距离/移动消耗的时间，就可以得到在P1处观测时，看起来的包络的移动速度。</p><script type="math/tex; mode=display">-\lambda\div\frac{d\lambda}{dv_p}=-\lambda\frac{dv_p}{d\lambda}</script><p>因为在P1处观测的包络的速度+P1向前移动的速度，即可得到群速度</p><script type="math/tex; mode=display">v_g=v_p-\lambda\frac{dv_p}{d\lambda}</script><p>此时便写出了$v_g与v_p$的表达式，但是通常来说，希望回归到波本身，即波的角频率，相移常数等。</p><p>分别代入波1和波2的参数：$\lambda = \frac{2\pi}{\beta}, \lambda+d\lambda=\frac{2\pi}{\beta+d\beta}$，相减可以得到</p><script type="math/tex; mode=display">d\lambda= \frac{2\pi d\beta}{\beta(\beta+d\beta)}</script><p>因为$v_p=\frac{\omega}\beta{}, v_p+dv_p=\frac{\omega+d\omega}{\beta+d\beta}$，相减可以得到</p><script type="math/tex; mode=display">dv_p=\frac{\beta d\omega-\omega d\beta}{\beta(beta+d\beta)}</script><p>此时代入$v_g=v_p-\lambda\frac{dv_p}{d\lambda}$:</p><script type="math/tex; mode=display">v_g=\frac{\omega}{\beta}-\frac{2\pi}{\beta}\cdot\frac{1}{2\pi}\bigg(\omega -\beta \frac{d\omega}{d\beta}\bigg)</script><script type="math/tex; mode=display">v_g=\frac{d\omega}{d\beta}</script><p><strong>因此，最终得到群速度$v_g=\frac{d\omega}{d\beta}$</strong></p><p>如果一个脉冲要在不改变其形状的情况下传播，那么与其频谱的不同部分相关的群速度必须相同；换言之，dω/dβ必须与频率无关。如果不是这样，那么脉冲在行进时会改变其形状，通常会在接收器处产生一个随时间分散的波形：<strong>这种效应称为色散</strong>。</p><p>对于发射的无限窄脉冲（即，频域所有频率分量都有的信号），色散量通常表示为接收脉冲在半功率点之间的时间分布。如果绘制β与ω的图（如下图），则该曲线的斜率为dβ/dω，即群速度的倒数。这被称为群延迟（group delay）。如果曲线是一条穿过原点的直线，则相速度和群速度在所有点处都相同且相等。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240604133438599.png" alt="image-20240604133438599" style="zoom:67%;" /></p><h3 id="探究本质：-Z-0-gamma-beta-和-alpha-与传输线特性关联"><a href="#探究本质：-Z-0-gamma-beta-和-alpha-与传输线特性关联" class="headerlink" title="探究本质：$Z_0,\gamma, \beta $ 和 $\alpha$ 与传输线特性关联"></a>探究本质：$Z_0,\gamma, \beta $ 和 $\alpha$ 与传输线特性关联</h3><p>前面提到电压向量用传输常数表达是$V_x=V_0e^{-\gamma x}$，类似地，电流衰减向量也可以表示为$I_x=I_0e^{-\gamma x}$</p><p>考虑下图单位长度的传输线，因为基尔霍夫电压定理，环路电压为0。因此有：</p><script type="math/tex; mode=display">\delta V=-R\delta xI_x-j\omega L\delta x I_x</script><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240615111806263.png" alt="image-20240615111806263" style="zoom:67%;" /></p><p>改写一下：</p><script type="math/tex; mode=display">\frac{dV}{dx}=-(R+j\omega L)I_x</script><p>如果忽略上图左侧RL带来的微小压降，则两线间的电流可以表示为$\delta I=-G\delta xV_x -j\omega C\delta xV_x$</p><script type="math/tex; mode=display">\frac{dI}{dx}=-(G+j\omega C)V_x</script><p>如果把$V_x=V_0e^{-\gamma x}$拿来微分一下，有：</p><script type="math/tex; mode=display">\frac{dV_x }{dx}=-\gamma V_0e^{-\gamma x}=-\gamma V_x</script><p>前面$\frac{dV}{dx}=-(R+j\omega L)I_x$的物理意义上单位$x$上电压的变化率，$\frac{dV_x }{dx}$物理意义也是这个，因此，他们两个式子相等，有</p><script type="math/tex; mode=display">\gamma V_x=(R+j\omega L)I_x</script><p>同理，由电压变化率的表达式，可以得到</p><script type="math/tex; mode=display">\gamma I_x=(G+j\omega C)V_x</script><p>上面两式左右分别相除，可以得到</p><script type="math/tex; mode=display">\frac{V_x}{I_x}=\frac{R+j\omega L}{G+j\omega C}\cdot\frac{I_x}{V_x}</script><script type="math/tex; mode=display">\bigg(\frac{V_x}{I_x}\bigg)^2=\frac{R+j\omega L}{G+j\omega C}</script><p><strong>信号的特征阻抗$Z_0$是电压/电流，因此：</strong></p><div class="note danger flat"><p>$Z_0$下面两个五星级公式！</p></div><script type="math/tex; mode=display">Z_0=\frac{V_x}{I_x}=\sqrt{\frac{R+j\omega L}{G+j\omega C}}</script><p>如果对于理想的没有电阻$R$和电导$G$的导线，或者是$\frac{R}{L}=\frac{G}{C}$的导线，有：</p><script type="math/tex; mode=display">Z_0=\sqrt{\frac{L}{C}}</script><div class="note info flat"><p>$\frac{R}{L}=\frac{G}{C}$被称为无失真条件，但实际永远不会接近它，即 G/C 比 R/L 小得多。过去，一些传输长距离信号的线路加电感器，以使R/L比更接近G/C，但这种做法现在已经过时了。</p></div><p><strong>传输常数$\gamma$也可以与传输线特征关联：</strong></p><p>前面得到的$\gamma V_x=(R+j\omega L)I_x$和$\gamma I_x=(G+j\omega C)V_x$两侧各有一个$I_x$和$V_x$，那么，将这两个式子相乘就可以约掉它们，只保留$\gamma$</p><script type="math/tex; mode=display">\gamma^2V_xI_x=(R+j\omega L)(G+j\omega)I_xV_x</script><div class="note danger flat"><p>下面这个$\gamma$五星级公式！</p></div><script type="math/tex; mode=display">\gamma=\sqrt{(R+j\omega L)(G+j\omega C)}</script><p><strong>1、在理想传输线的前提下，即，R=G=0时</strong></p><script type="math/tex; mode=display">\gamma=j\omega \sqrt{LC}</script><p>有了$\gamma$之后，可以进一步推得$\beta,v_p,v_g$,</p><p>在理想传输线的前提下，即，R=G=0时，$\gamma$为纯虚数，因此$\gamma$全部由$\beta$贡献</p><script type="math/tex; mode=display">\beta = \omega\sqrt{LC}</script><script type="math/tex; mode=display">v_p=\omega/\beta =\frac{1}{\sqrt{LC}}</script><script type="math/tex; mode=display">v_g=\frac{d\omega}{d\beta}=\frac{1}{\sqrt{LC}}</script><p><strong>2、在无失真条件(distortionless condition)，即$R/L=G/C$时</strong></p><script type="math/tex; mode=display">\gamma=\sqrt{LC(R/L+j\omega)(G/C+j\omega)}=(R/L+j\omega)\sqrt{LC}</script><p>因为$\gamma=\alpha+j\beta$，拆分上式虚部和实部，可以得到$\alpha$和$\beta$的式子（$\beta$和理想状态相同)：</p><script type="math/tex; mode=display">\alpha=\frac{1}{2}\bigg[R\sqrt{C/L}+G\sqrt{L/C}\bigg]</script><p>继续推导，将$\gamma$写回$\gamma^2$:</p><script type="math/tex; mode=display">\gamma^2=(\alpha+j\beta)^2=(R+j\omega L)(G+j\omega C)</script><script type="math/tex; mode=display">\alpha^2-\beta^2+j2\alpha\beta=RG-\omega^2LC+j\omega(LG+RC)</script><p>拆分虚实部，可以得到：</p><script type="math/tex; mode=display"> \alpha ^ {2}  -  \beta ^ {2}  =RG-  \omega ^ {2}  LC</script><script type="math/tex; mode=display">2  \alpha  8=  \omega  (LG+RC)</script><p>联立求解上述二式</p><script type="math/tex; mode=display">\alpha  =\{ \frac {1}{2}  [  (R^ {2}+\omega ^ {2}L^ {2})^ {1/2}  (G^ {2}+\omega ^ {2}C^ {2})^ {1/2}  +(RG-  \omega ^ {2}  LC)]\}^{1/2}</script><script type="math/tex; mode=display">\beta  =\{ \frac {1}{2}  [  (R^ {2}+\omega ^ {2}L^ {2})^ {1/2}  (G^ {2}+\omega ^ {2}C^ {2})^ {1/2}  -(RG-  \omega ^ {2}  LC)]\}^{1/2}</script><script type="math/tex; mode=display">\gamma=\alpha+j\beta=\sqrt{RG+j\omega CR+j\omega GL-\omega^2LC}</script><p>在高频情况下，RG可以忽略，提出$(-\omega^2LC)$，上式可以写为</p><script type="math/tex; mode=display">\gamma=j\omega\sqrt{LC}(1-j\frac{CR+GL}{\omega LC})^{\frac{1}{2}}</script><p>因为这是高频情况，$\omega$很大，以此可以约等于：</p><script type="math/tex; mode=display">\gamma\approx j\omega \sqrt{LC}\bigg(1-\frac{1}{2}j\frac{CR+GL}{\omega LC}\bigg)</script><p>乘进去，并拆分虚实部，最终可以得到：</p><div class="note danger flat"><p>下面$\gamma,\alpha,\beta$五星级公式！</p></div><script type="math/tex; mode=display">\gamma   \approx   \frac {1}{2}   \frac {CR+GL}{\sqrt {LC}}  +  j\omega   \sqrt {LC}</script><script type="math/tex; mode=display">\alpha  =(  \frac {R}{2}   \sqrt {\frac {C}{L}}  +  \frac {G}{2}   \sqrt {\frac {L}{C}}  )(Np/km)</script><script type="math/tex; mode=display">\beta  =j  \omega   \sqrt {LC}  (rad/km)</script><h2 id="传输线特性参数公式总结"><a href="#传输线特性参数公式总结" class="headerlink" title="传输线特性参数公式总结"></a>传输线特性参数公式总结</h2><h3 id="相移常数"><a href="#相移常数" class="headerlink" title="相移常数"></a>相移常数</h3><ul><li>定义式：$\beta=\frac{2\pi}{\lambda}$</li><li>理想传输线，R=G=0时：$\beta = \omega\sqrt{LC}$</li><li>无无失真传输线，$R/L=G/C$，且高频下：$\beta  =j  \omega   \sqrt {LC}(rad/km)$</li></ul><h3 id="传输常数"><a href="#传输常数" class="headerlink" title="传输常数"></a>传输常数</h3><ul><li>定义式：$\gamma=\alpha+j\beta$</li><li>与传输线特征关联：$\gamma=\sqrt{(R+j\omega L)(G+j\omega C)}$</li><li>理想传输线，R=G=0时：$\gamma=j\beta=j\omega\sqrt{LC}$</li><li>无失真传输线，$R/L=G/C$，且高频下：$\gamma   \approx   \frac {1}{2}   \frac {CR+GL}{\sqrt {LC}}  +<br>  j\omega   \sqrt {LC}$</li></ul><h3 id="特征阻抗-Z-0"><a href="#特征阻抗-Z-0" class="headerlink" title="特征阻抗$Z_0$"></a>特征阻抗$Z_0$</h3><ul><li>定义式：$Z_0=\frac{V_x}{I_x}=\sqrt{\frac{R+j\omega L}{G+j\omega C}}$</li><li>无失真传输线或理想传输线下：$Z_0=\sqrt{\frac{L}{C}}$</li></ul><h3 id="衰减常数"><a href="#衰减常数" class="headerlink" title="衰减常数"></a>衰减常数</h3><ul><li>定义式：间隔单位距离的$V_1$和$V_2$, $V_1/V_2=e^{\alpha}$</li><li>无失真传输线，$R/L=G/C$，且高频下：$\alpha  =(  \frac {R}{2}   \sqrt {\frac {C}{L}}  +  \frac {G}{2}   \sqrt {\frac {L}{C}}  )(Np/km)$</li><li>理想传输线，R=G=0时：无衰减，$\alpha=0$</li></ul><h3 id="相速度"><a href="#相速度" class="headerlink" title="相速度"></a>相速度</h3><ul><li>定义式：$v_p=\frac{\omega}{\beta}=f\lambda$</li><li>理想传输线下：$v_p=\omega/\beta =\frac{1}{\sqrt{LC}}$</li></ul><h3 id="群速度-1"><a href="#群速度-1" class="headerlink" title="群速度"></a>群速度</h3><ul><li>定义式：$v_g=\frac{d\omega}{d\beta}$</li><li>理想传输线下：$v_g=\frac{d\omega}{d\beta}=\frac{1}{\sqrt{LC}}$</li></ul><h2 id="传输线的反射"><a href="#传输线的反射" class="headerlink" title="传输线的反射"></a>传输线的反射</h2><div class="note info flat"><p>BNH补充小课堂：由于接收器端无法完全消耗信号的能量，因此波会发生反射。同频反射的信号会对正向传输的信号进行干扰。因此需要进行阻抗匹配，同时，在部分短距离传输系统上还需要在接收端前加衰减器。</p></div><h3 id="两个极端-接收端开路-短路"><a href="#两个极端-接收端开路-短路" class="headerlink" title="两个极端-接收端开路/短路"></a>两个极端-接收端开路/短路</h3><p>传输线在末端可以理想考虑为短路和开路两种情况，也就是负载阻抗无穷和负载阻抗为0时。</p><ul><li>负载阻抗无穷时，反射系数为1，波正相反射，并与正向传播的波叠加幅值变为2倍。</li></ul><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240615215925946.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240615215935674.png"></center></td>    </tr></table><ul><li>负载阻抗为0时，反射系数为-1，波反相反射，消除正向传播波的幅值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240615220253501.png" alt="image-20240615220253501"></p><ul><li>负载阻抗与传输线特征阻抗匹配时，无反射发生。此时称阻抗正确匹配(correctly terminated or matched)。</li></ul><p>如果负载端阻抗大于特性阻抗但不等于无穷，则以开路去分析，幅值会叠加，但是小于2倍。</p><p>若负载端阻抗小于特性阻抗但不为0，则带入短路去分析，幅值会相消，但是不完全消除。</p><h3 id="对反射波进行建模"><a href="#对反射波进行建模" class="headerlink" title="对反射波进行建模"></a>对反射波进行建模</h3><p>若将前进波的电压电流表示为$V_i,I_i$，反射波的电压表示为$V_r,I_r$。</p><p>那么总电压是：$V_i+V_r$, 总电流是$I_i-I_r$。参考下图，此时$R_L$上的电压就是总电压，电流就是总电流，因此：</p><script type="math/tex; mode=display">\frac{V_i+V_r}{I_i-I_r}=R_L</script><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240615223551192.png" alt="image-20240615223551192"></p><p>其中，$V_r/V_i$被称为电压反射系数（voltage reflection coefficient），记为$\rho$。对于理想传输线，其呈纯阻性，因此电阻恒定，电流比值也为$\rho$。（这个地方如果是考虑单一频率，即，阻抗不变的情况，则无需理想传输线）</p><script type="math/tex; mode=display">\rho=\frac{V_r}{V_i}=\frac{I_r}{I_i}</script><p>如果以传输线的视角来看，传输线呈现的纯阻性为$R_0$，有：</p><script type="math/tex; mode=display">\frac{V_i}{I_i}=\frac{V_r}{I_r}=R_0</script><p>如果对$R_L$除以$V_i/I_i$,再在前面乘回去，可以推得其用$\rho$表示：</p><script type="math/tex; mode=display">R_L=\frac{V_i}{I_i}\cdot\frac{1+V_r/V_i}{1-I_r/I_i}=R_0\cdot\frac{1+\rho}{1-\rho}</script><p>换过来，便可以求得$\rho$与$R_0,R_L$的关系：</p><script type="math/tex; mode=display">\rho=\frac{R_L-R_0}{R_L+R_0}</script><p>举个例子，如果$R_L=\frac{1}{2}R_0$,则 $\rho=-1/3$，意为反射电压相位相反，振幅为$1/3V_i$</p><p>如果不是理想传输线，考虑单一频率的情况下，线阻恒定为$Z_0$，负载阻抗恒定为$Z_L$，$\rho$也可以表示为。在这种情况下，$V_i,V_r,I_i,I_r$是一个向量（或者复数），因为其表示的含义是波。</p><script type="math/tex; mode=display">\rho=\frac{Z_L-Z_0}{Z_L+Z_0}</script><h3 id="回波损耗-Return-loss"><a href="#回波损耗-Return-loss" class="headerlink" title="回波损耗(Return loss)"></a>回波损耗(Return loss)</h3><p>反射脉冲中的能量与入射脉冲中的能量之比称为回波损耗，由于同一线缆上电流恒定，因此可以直接由电压的比例的平方$\rho^2$得到</p><script type="math/tex; mode=display">Return\ loss=10log_{10}(\rho^2)=20\log_{10}(\rho)</script><h3 id="全驻波（total-standing-wave）"><a href="#全驻波（total-standing-wave）" class="headerlink" title="全驻波（total standing wave）"></a>全驻波（total standing wave）</h3><p>在下面的推导中，都以无衰减的理想传输线，衰减常数$\alpha=0$</p><p>假设传输线的长度为$x$，$Z_L=\infty$。此时电压会完全同相位反射。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240615231434907.png" alt="image-20240615231434907"></p><p>如果在起始点P的电压为V，那么经过$x$的距离，终点的电压$V’$就是：</p><script type="math/tex; mode=display">V'=Ve^{-j\beta x}</script><p>此时这个电压会被同相位完全反射，那以终点至起始点的反射波的视角来看，反射回起始点的电压是：</p><script type="math/tex; mode=display">V''=V'e^{-j\beta x}</script><p>将$V’=Ve^{-j\beta x}$改写为$V=V’e^{j\beta x}$。起始点的电压是正向传播电压和反射电压的和，因此：</p><script type="math/tex; mode=display">V_p=V+V''=V'e^{j\beta x}+V'e^{-j\beta x}=V'(e^{j\beta x}+e^{-j\beta x})</script><p>使用欧拉公式展开：</p><script type="math/tex; mode=display">V_p=2V'cos(2\beta x)</script><p>有相移常数定义式$\beta=2\pi/\lambda$，记$2V’=V_T$有：</p><script type="math/tex; mode=display">V_p=V_Tcos(2\pi x/\lambda)</script><p>不妨想一下，这个$V_p$可能并非是真正的信号发生点，而是人为规定的一个“起点”。也就相当于，这个式子可以是线路上任意一点的电压值，而$x$代表的是这一点距离终点的长度。观察发现：</p><ul><li>当线缆距离终点满足$2\pi x/\lambda=k\frac{\pi}{2}$ (k=1,3,5,7…)，即$4x/\lambda=k(odd), x=\frac{k\lambda}{4}$，时，电压为0；</li><li>当线缆距离终点满足$2\pi x/\lambda=k\frac{\pi}{2} (k=0,2,4,6…)$时，即$4x/\lambda=k(even),x=\frac{k\lambda}{4}$时，电压为$V_T$或$-V_T$；</li></ul><p>因此，在线缆上每隔$\lambda/4$的距离，形成一个波节(nodes)；每隔$\lambda/4$的距离，形成一个波峰（antinodes）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240615235559814.png" alt="image-20240615235559814"></p><h3 id="行驻波（partial-standing-wave）"><a href="#行驻波（partial-standing-wave）" class="headerlink" title="行驻波（partial standing wave）"></a>行驻波（partial standing wave）</h3><p>假设存在衰减，并非全部能量反射。那么波形可以被看成是一部分的正向行波和反射波对冲，形成全驻波，另一部分仍然是正向行波。传输线上的波形是这二者波形的叠加。在传输线上，电压最大值是行波电压和反射电压幅度的总和，最小值是它们的差值（不再为零）。此时传输线上最大电压和最小电压的比值被称为<strong>“电压驻波比voltage standing wave ratio (VSWR)”，记为S</strong></p><script type="math/tex; mode=display">V_{max}=V_i+V_r, V_{min}=V_i-V_r</script><script type="math/tex; mode=display">S=\frac{V_{max}}{V_{min}}=\frac{V_i+V_r}{V_i-V_r}</script><p>对S分子分母同除以$V_i$，再结合前面的反射系数$\rho$:（考虑$\rho$是有正负的，但是$S$一定是最大的比最小的，因此$\rho$需要加绝对值）</p><div class="note danger flat"><p>下面VSWR公式和其逆公式五星级</p></div><script type="math/tex; mode=display">S=\frac{1+\frac{V_r}{V_i}}{1-\frac{V_r}{V_i}}=\frac{1+|\rho|}{1-|\rho|}</script><p>反过来也可以由$S$得出$|\rho|$</p><script type="math/tex; mode=display">|\rho|=\frac{S-1}{S+1}</script>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 电信传输理论与工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电信传输理论-CH4-复用技术</title>
      <link href="/posts/8b0e91f6.html"/>
      <url>/posts/8b0e91f6.html</url>
      
        <content type="html"><![CDATA[<h2 id="统计时分复用和同步时分复用"><a href="#统计时分复用和同步时分复用" class="headerlink" title="统计时分复用和同步时分复用"></a>统计时分复用和同步时分复用</h2><h3 id="同步时分复用（Synchronous-Time-Division-Multiplexing-STDM）"><a href="#同步时分复用（Synchronous-Time-Division-Multiplexing-STDM）" class="headerlink" title="同步时分复用（Synchronous Time Division Multiplexing, STDM）"></a>同步时分复用（Synchronous Time Division Multiplexing, STDM）</h3><p>同步时分复用：这种同步在数据的帧之间插入时间信号，让调制出的信号自带同步信息。复用是将时间分割成小份，<strong>一个用户占用特定的一份</strong>实现的。如下图ABCD对应四个用户。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240616110751192.png" alt="image-20240616110751192"></p><p>同步时分复用存在问题：当某个用户暂时无数据发送时，在自己的时分复用帧（时隙）上，信道是空闲的，但是参与复用的其它用户也无法使用这个暂时空闲的线路资源，这造成了资源浪费</p><h3 id="统计时分复用（Statistical-Time-Division-Multiplexing）"><a href="#统计时分复用（Statistical-Time-Division-Multiplexing）" class="headerlink" title="统计时分复用（Statistical Time Division Multiplexing）"></a>统计时分复用（Statistical Time Division Multiplexing）</h3><p>统计时分复用：这种复用比同步时分复用更高效。同样是把时间切片，但并不是一个用户占一份时间，而是每个用户带上自己的标签（地址），“赶趟”即走。</p><p>如下图所示，虽然时间也被切片了，但是a走之后b来了，b跟着a走；b走之后b又来了，那下一个时隙又是b走。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240616111220266.png" alt="image-20240616111220266" style="zoom:67%;" /></p><h1 id="吹吹水"><a href="#吹吹水" class="headerlink" title="吹吹水"></a>吹吹水</h1><p>一开始的时候，采用的是频分复用。因为一开始的时候使用的频率较低，对频率的操作性较强，因此可以对在频域切分子信道。</p><p>后续使用时分复用时，同步是一个大问题，不良好的同步会导致滑码，丢帧等等。同步技术有两种：一种是时钟上的同步；另外一种是相互之间有时钟信号来同步。在同步发展初期，同步网络是逻辑上独立于数据网络的。</p><p>在<em>数字系统设计与可靠性工程</em>中介绍了Multiplexer和Demultiplexer, 这种电路配合其他芯片，可实现多转1，1转多，来实现通信电路的复用。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240415194310307.png" alt="image-20240415194310307"></p><div class="note info flat"><p>剩下的部分其他课都讲过好多遍了。baoninghai：“那这部分就过得快一点”</p><p>下面的新知识点是SONET/SDH，但不是重点。这个技术已经被淘汰，感兴趣自行了解即可。</p></div>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 电信传输理论与工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH340X+ISP烧录使用指南</title>
      <link href="/posts/586a8eb3.html"/>
      <url>/posts/586a8eb3.html</url>
      
        <content type="html"><![CDATA[<h1 id="CH430X使用指南"><a href="#CH430X使用指南" class="headerlink" title="CH430X使用指南"></a>CH430X使用指南</h1><h2 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240409131159622.png" alt="image-20240409131159622"></p><p>CH340X引脚如上图。其中：</p><ul><li>UD+ &amp; UD- : USB差分信号（CH340的USB收发器按USB2.0全内置设计，UD+和UD-引脚建议不要额外串接电阻）</li><li>RXD &amp; TXD: 串口接收、发送信号</li><li>V3：用于CH340内部供电电路退耦，<strong>在3.3V时时连接VCC输入外部电源，在5V时固定串联0.1uF电容后接地</strong>。</li><li>VCC：电源输入，<strong>需外接0.1uF退耦电容</strong></li><li>RTS#：（输出信号）Request To Send，用于告知接收端数据准备发送。</li><li>CTS#：（输入信号）Clear To Send，用于告知发送端 接收端已准备好接收 可以发送。</li><li>TNOW：（输出信号）串口正在发送的状态指示引脚，高电平表示正在发送。</li><li>DTR#：（输出信号）Data Terminal Ready，它用于告知接收端数据终端已经准备好进行通讯。</li></ul><p>其中，引脚6可复用为TNOW或DTR模式：</p><ol><li>如果为引脚6外接4.7KΩ下拉电阻到GND，那么将进入开源DTR增强模式，引脚6自动切换为开源驱动的DTR#，用于连接MCU的BOOT模式引脚，默认DTR#为不输出，被外部电阻保持为低电平， 但可以由应用程序设置DTR#引脚输出高电平或不输出，用于DTR#默认低电平的多模式MCU下载。 </li><li>如果在6#引脚与5#引脚之间接4.7KΩ电阻，那么将进入推挽DTR增强模式，6#引脚自动切 换为推挽驱动的DTR#用于连接MCU的控制引脚，可以由应用程序设置DTR#引脚输出高电平或低电平， 用于DTR#默认高电平的多模式MCU下载。</li><li>如果引脚6无外部下拉/上拉电阻，则工作为TNOW模式。</li></ol><p><strong>其中，DTR，RTS等MODEM通讯信号，是可以由计算机上的上位机通过软件更改其状态的。例如Windows下调用 <code>SETRTS</code> API，就可以执行Sends the RTS (request-to-send) signal</strong></p><p>因此，诸如MCUISP等软件，支持对RST和DTR引脚进行不同的操作，以引导MCU进入ISP烧录模式。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240409163227165.png" alt="image-20240409163227165" style="zoom: 50%;" /></p><h2 id="CH340X使用案例"><a href="#CH340X使用案例" class="headerlink" title="CH340X使用案例"></a>CH340X使用案例</h2><p>下图是南京沁恒给出的一个CH340 STM32自动下载电路的使用案例。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/6rGAjBbclrc6aBCFG2kPU72ix9d3Q5Ru3WdUvelS.jpeg" alt="img"></p><p><strong>对于CH340C电路来说，MCUISP需选择“DTR低电平复位，RST高电平进BootLoader”：</strong></p><ol><li>首先MCUISP会让DTR引脚写低电平，那这里DTR#（NOT DTR）就会变成高电平，使得Q1导通，RESET电平与RTS#相等。而一开始RTS是低电平（RTS#高电平），因此并没有复位。</li><li>MCUISP会将RTS引脚写高电平，此时RTS#变为低电平，RESET引脚拉低复位。同时BOOT0上方Q2导通，BOOT0被上拉至VCC，逻辑1。</li><li>延时100毫秒等待稳定。</li><li>DTR变为高电平，DTR#变为低电平，Q1关断，RESET重新被拉高，复位完成。RTS维持高电平，RST#保持低电平，使得Q2持续导通，BOOT0继续保持逻辑1。</li><li>成功进入Bootloader模式，释放BOOT0和RESET并开始进行ISP烧写。</li></ol><p><strong>对于CH340X免外围电路来说，MCUISP需选择“RTS高电平复位，DTR低电平进BootLoader”：</strong></p><ol><li>首先MCUISP使得RTS写高电平，RTS#变为低电平拉低RESET，开始复位。</li><li>将DTR置低，使DTR#为高电平，BOOT0为逻辑1。</li><li>延时100毫秒，等待稳定。</li><li>RTS变低电平，RTS#重新拉高RESET，复位完成。此时BOOT0仍然保持逻辑1。</li><li>成功进入BootLoader，释放BOOT0和RESET并开始进行ISP烧写。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 各种折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代通信网络-LC3-数据链路控制协议</title>
      <link href="/posts/acdb16ef.html"/>
      <url>/posts/acdb16ef.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>本节对应参考书CH7</p></div><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>在一次链路中的数据交换中，需要涉及以下任务：</p><ul><li>帧同步（在这门课中不重要）</li><li>流控</li><li>错误控制</li><li>寻址</li><li>控制和发送数据</li><li>链路管理</li></ul><h1 id="流控（flow-control）"><a href="#流控（flow-control）" class="headerlink" title="流控（flow control）"></a>流控（flow control）</h1><p>流控的作用是确保发送端发送的信息不会在因接收端处理速度不足而被忽略，也就是防止缓冲区溢出。</p><div class="note info flat"><p>流控可以出现在通信协议中的任意一层，只要对等层采用流控协议即可（差错控制也是一样）。这一节只介绍了两种常见的流控手段，并没有带入特定协议，后续课程会带入协议深入介绍。</p></div><h2 id="停等流控-stop-amp-wait"><a href="#停等流控-stop-amp-wait" class="headerlink" title="停等流控(stop &amp; wait)"></a>停等流控(stop &amp; wait)</h2><p>工作流程：</p><ol><li>发信端发送信息</li><li>接收端接受</li><li>接收端就绪接收后发送ACK信息</li><li>发送端传输下一帧</li></ol><p>这是最简单，但非常有效的流控形式。可靠性较好，但是效率较低。</p><p>通常情况下，发送端会将一个大数据块分解成更小的块进行传输，因为：</p><ul><li>接收端buffer大小有限</li><li>越长的数据出现错误的概率越高，若出现不可纠正错误则需要重传整个数据。分解成小块后可以独立重传小数据块，数据量小。</li><li>在共享的传输介质中，通常不允许单一通信长时间占用传输介质，因为这样会造成其他终端间的通信产生较大延迟。</li></ul><h2 id="滑窗流控-Sliding-Windows"><a href="#滑窗流控-Sliding-Windows" class="headerlink" title="滑窗流控(Sliding Windows)"></a>滑窗流控(Sliding Windows)</h2><p>考虑收发两端都与一些缓存空间，因此可以连续发送一些东西而无需应答。连续发送的这些数据，就是“窗口”。例如下图，规定数据窗口为6个数据包。那么：</p><ol><li>每一个数据帧都有一个id，下图中记为1 2 3 4 5 6 7，规定窗口大小为6帧。</li><li>发送端可以连续发送帧1 2 3 4 5 6</li><li>如果发送6时，还没有收到帧1的ACK，那么就停下</li><li>如果收到了帧1的ACK，窗口就向后滑动，可发送7</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240407151631847.png" alt="image-20240407151631847"></p><p>如此操作，就无需及时的应答，因此ACK数据包可以随其他必要的通信包一起发送，无需为了ACK单独发信一次。</p><p>这在实现还有一些细节差异：</p><ul><li>例如，可以同时通知发送段1-5都收到了，这样发送端只需要一个ACK窗口就可以直接向后滑动5位。</li><li>再例如，ACK信号可以返回“最后一次接收到的正确的帧”，例如最后一次收到的正确帧是3，那窗口会滑动到4开始继续发送，这样可以同时进行流控和差错控制。</li><li>如果发送端资源空闲，线路负荷较低时，那么为保证效率，发送端可以在接收到ACK之前反复重发窗内数据。</li></ul><h2 id="什么时候用停等，什么时候用滑窗？"><a href="#什么时候用停等，什么时候用滑窗？" class="headerlink" title="什么时候用停等，什么时候用滑窗？"></a>什么时候用停等，什么时候用滑窗？</h2><p>随着不同的载波、介质、帧长度不同，会出现下图两种不同的情况。第一种是接收端已经开始收到了发送的信号，发送端的帧还没完。情况二是帧非常短，发送端发了之后就进入空闲等待了。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240410172200501.png" alt="image-20240410172200501"></p><ul><li>对于情况1，可使用停等，因此比特流本身较长，采用滑窗机制提前发送意义不大。</li><li>对于情况2，有大量的信道资源被浪费，因此可以使用滑窗机制来提高比特流长度，减少信道空闲时间。</li></ul><p>收发机间信号临界比特长度可用如下公式计算。大于这个长度，接收端将在发送端结束发送前收到信号，是上述情况1；小于这个长度，则发送端空闲较大，是上述情况2；</p><script type="math/tex; mode=display">B=R\times \frac{d}{V}</script><p>其中：</p><ul><li>B：链路长度（单位：bit），这个链路的物理长度能容纳多长的比特流</li><li>R：数据传输速率 (单位：bps)</li><li>d：收发机间物理距离 （单位：m）</li><li>V：介质中信号传播速度（单位：m/s）</li></ul><h1 id="差错控制（五星级"><a href="#差错控制（五星级" class="headerlink" title="差错控制（五星级)"></a>差错控制（五星级)</h1><p>前面介绍的流控是为了避免接收端反应速度不够，而遗漏了发送端的消息。这里的差错控制则是避免数据传输时，由于信道衰落，干扰等因素，出现帧错误、帧丢失。但是他们的手段非常类似  ，采用的协议也高度相似。</p><h2 id="Automatic-Repeat-Request-ARQ"><a href="#Automatic-Repeat-Request-ARQ" class="headerlink" title="Automatic Repeat Request (ARQ)"></a>Automatic Repeat Request (ARQ)</h2><div class="note warning flat"><p>Automatic Repeat Request 的简写是ARQ而非ARR！</p></div><p>自动请求重发（automatic repeat request）是数据通信中在接收端进行差错检测，并自动请求发送端重发的差错控制技术，简称ARQ。在ARQ中，重发要一直延续到该码字被成功地接收为止。ARQ协议有不同的实现方式。</p><h3 id="Stop-amp-Wait-ARQ（需要掌握细节！）"><a href="#Stop-amp-Wait-ARQ（需要掌握细节！）" class="headerlink" title="Stop &amp; Wait ARQ（需要掌握细节！）"></a>Stop &amp; Wait ARQ（需要掌握细节！）</h3><p>停等ARQ与停等流控机制类似。</p><p>在数据正向传输过程中，可能出现两种错误，这两种错误都可以通过ACK机制解决：</p><ul><li>到达目的地的帧可能会损坏。接收方通过错误检测可以检测到这一点，并返回帧错误，请求重发的ACK。</li><li>还有一种可能是在发送过程中出现了问题，接收方根本没有接收到这个帧。为解决这种情况源站配有计时器，发送一个帧后，源开始计时，如果到时未收到接收方的ACK信号，则再次发送相同的帧。</li></ul><p>但是如果A发送了数据，B正确接收了数据并发送了正确接收的ACK，但是这个ACK在传回A的途中损坏了，那A又会重复发送这一帧，此时B接收了一个重复的帧。如何解决这个问题呢？</p><p><strong>帧在发送时，会被交替地标记0或1。同样的，ACK信号也分为ACK0或ACK1，源收到一个ACK0信号，代表接收端已经准备好接受label为0的帧；收到ACK1信号，代表接收端准备好接收label为1的帧。</strong>下图展示了这一过程</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240410163738106.png" alt="image-20240410163738106"></p><p>在上图中，ACK0丢失导致A发送了两次frame1, B发现两次接收到的label都是1，因此知道这是同一帧，发送ACK0表示准备好接收frame0，数据传输继续进行。</p><h3 id="Go-Back-N-ARQ"><a href="#Go-Back-N-ARQ" class="headerlink" title="Go-Back-N ARQ"></a>Go-Back-N ARQ</h3><p>Go-Back-N AQR其实就是滑窗机制+重发机制的组合。这是最常用的差错控制手段。在Go-Back-N ARQ 中，同样使用滑窗尺寸（Window size）来规定在没有收到ACK前最多一次能发多少。</p><p><strong>确定滑窗大小的注意点：</strong></p><ul><li><p>因为对数据帧的label（即，标注帧顺序的序号）是重复使用的，因此要确保ACK上一轮回的某一序号前，不会发送新轮回的序号。例如轮回1发送了帧5，那么下一次发帧5之前就必须收到这个帧5的ACK，否则无法确认ACK的是哪一次的帧5。因此，<strong>滑窗的大小必须小于帧label数量的大小</strong>。</p></li><li><p>Go-Back-N差错控制与滑窗流控基本一致。如果出现错误，则会将从错误帧开始往后的帧全部丢弃，并从错误帧开始重发。因此<strong>如果Window Size太大，会对网络资源造成较大占用</strong>。</p></li></ul><p><strong>控制流程：</strong></p><ol><li>发送端A发送一串帧给B</li><li>如果B校验全部正确，则会发送RR(Receive Ready)作为ACK；</li><li>如果B校验不正确，则会发送REJ(reject)作为ACK；</li><li>一旦A收到REJ，则必须从错误帧开始全部重发</li></ol><p>实际传输过程中，会出现如下情况：</p><ul><li><strong>A-&gt;B过程中，帧$i$损坏,但A还在持续发送</strong>：当收到$i+1$时，B发现缺失了$i$，帧顺序不对，B发送$REJ\ i$,$i$后续的帧都被丢弃了，A从$i$开始重传。</li><li><strong>A-&gt;B过程中，帧$i$损坏，但A没有后续帧要发送或必须等待收到ACK后再发送</strong>：此时B没有达到规定需要发ACK的帧个数，因此不会返回ACK信号。此时A中时钟继续计数，当超时时，A发送一个 Poll bit为1的RR帧，B会将此帧作为一个命令处理，B必须发送一个指明其需要的下一帧label的ACK。当A收到ACK后，它从该label开始重传。</li><li><strong>B-&gt;A过程中，帧$i$的RR信号损坏，后续RR信号正常抵达</strong>：因为RR信号是持续的，例如收到了RR6，表明RR5也得到了确认，因此在等待$i$的ACK计时器超时前，可以通过后续的RR对$i$进行确认。</li><li><strong>B-&gt;A过程中，$i$帧的REJ信号损坏</strong>：由于B发送了REJ，因此后续的帧都将被丢弃。A在超时未收到ACK后发送RR帧，待B ACK期望帧后继续传输。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240417170821082.png" alt="image-20240417170821082"></p><p>这种差错控制方式实现较为简单，且可以复用为滑窗流控。但是一旦出现错误，会丢弃很多帧，这对资源是一种浪费。</p><h3 id="Selective-Reject-ARQ-要求完全掌握"><a href="#Selective-Reject-ARQ-要求完全掌握" class="headerlink" title="Selective-Reject ARQ (要求完全掌握)"></a>Selective-Reject ARQ (要求完全掌握)</h3><p>相较于Go-Back-N ARQ，Selective-Reject (ARQ)流程相似，但不会丢弃错误帧之后收到的帧，提高效率。以A发送端，B为接收端：</p><ul><li><p>在SR ARQ模式下，当错误出现时，B会发送”Selective Reject （SREJ）”，并将后续收到的帧存在自己的缓存中。则是SR-ARQ与Go-Back-N的核心区别。</p></li><li><p>A收到SREJ后，立马重发SREJ指定的帧，重发之后继续发送滑窗内剩下的内容。</p></li><li>B收到更正后，会立马发送一次ACK来更新A的窗。</li><li>若ACK信号丢失，处理机制和Go-Back-N一致。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240417174743653.png" alt="image-20240417174743653"></p><p>在上图中，帧4丢失。因此B发送SREJ4，同时暂存后续的帧5和6。收到SREJ4后，立马重发4，重发后继续发送5 6后续的帧7，B收到后立马回复RR来刷新A的窗。</p><p>若B的RR丢失，A在Timer超时后，会发送RR （Poll bit = 1）来要求B发送RR，并在收到B的RR后再继续发送下面的帧。</p>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 现代通信网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32核心板设计</title>
      <link href="/posts/ce38ed7e.html"/>
      <url>/posts/ce38ed7e.html</url>
      
        <content type="html"><![CDATA[<h1 id="HSE时钟电路——皮尔斯-Pierce-震荡器"><a href="#HSE时钟电路——皮尔斯-Pierce-震荡器" class="headerlink" title="HSE时钟电路——皮尔斯(Pierce)震荡器"></a>HSE时钟电路——皮尔斯(Pierce)震荡器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单片机上常见的HSE时钟——一个无源晶振配合两个电容的时钟电路，就是使用的皮尔斯振荡电路，其完整电路如下图，由两个电容 ($C_1\&amp;C_2$) ，一个晶体振荡器 ($X_1$)，一个反馈电阻 ($R_1$) 和一个反相放大器 ($U_1$) 组成。$U_1$和$R_1$一般集成在芯片内部，因此这就是在STM32中选择HSE（外部晶体振荡器）时钟时，有两个引脚 <code>RCC_OSCIN</code> 和 <code>RCC_OSC_OUT</code> 被占用的原因。</p><h2 id="石英晶振的等效电路"><a href="#石英晶振的等效电路" class="headerlink" title="石英晶振的等效电路"></a>石英晶振的等效电路</h2><p><table><br>    <tr><br>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/8601a18b87d6277ff030a1392a381f30e924fc95"></center></td><br>          <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240407090244851.png"></center></td></p><p>在分析电路如何震荡之前，需要先了解石英的一个物理特性。</p><ul><li>压电效应：当对压电材料施以压力时，能产生电；反过来，当给压电材料通电，能产生形变；因此，在石英晶体的两端施加持续变化的交流电压，即可让石英音叉形变“震荡”起来，物理的形变又回反过来改变电压，从某种意义上来说这也是一个储能元件。在计算上可以把晶振等效为一个RLC电路，如下图所示。其中$C_0$是石英晶体两脚间产生的寄生电容（一般取3-5pF），其余部分是晶振本身的等效RLC，也称为其“运动（Motional）参数”。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/OIP-C.YHRlityi3tRfzIyrz41DjAHaFK" alt="晶振的等效电路"></p><h2 id="皮尔斯振荡器"><a href="#皮尔斯振荡器" class="headerlink" title="皮尔斯振荡器"></a>皮尔斯振荡器</h2><h3 id="如何进行选频"><a href="#如何进行选频" class="headerlink" title="如何进行选频"></a>如何进行选频</h3><p>我们知道，振荡器会在反馈电路的谐振频率上进行振荡，这本质是反馈回路是一个滤波器，而谐振频率是反馈回路中电抗最小的时候。因此会将该频率进行无限放大，最后在此频率上震荡。</p><p>从上面等效电路我们可以看到，晶振有两个谐振频率：一个是$R_1,L_1,C_1$ 三个串联谐振的频率，称之为$f_s$；另一个是$R_1,L_1,C_1$ 与 $C_0$ 并联形成的电路的谐振频率，称之为$f_p$。</p><p>$f_s$频率就是串联电路感抗和容抗抵消，即：$2\pi f_sL_1=\frac{1}{2\pi f_s C_1}$，可解得：</p><script type="math/tex; mode=display">f_s=\frac{1}{2\pi \sqrt{L_1C_1}}</script><p>$f_p$是串联电路感抗大于容抗，整个电路等效于一个电感的时候，和$C_0$发生谐振：</p><script type="math/tex; mode=display">f_p=\frac{1}{2\pi \sqrt{L_1C_1}}\times \sqrt{1+\frac{C_1}{C_0}}=f_s\times \sqrt{1+\frac{C_1}{C_0}}</script><p>可以看出，当频率小于$f_s$时，$L_1$容抗非常小，整个电路的储能由$C_1$主导，因此呈容性（电压领先电流）。在$f_s-f_d$区间内，电路储能由$L_1$主导，因此呈感性（电压滞后电流）。而在频率大于$f_d$后，由于$C_0$支路电抗变小，因此主导支路变成了$C_0$而非$R_1C_1L_1$，再次呈现感性。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240408171430933.png" alt="image-20240408171430933"></p><p>对不同频率呈现出不同的阻值，这就是一个滤波器。可以看出，这个滤波器对$f_s$附近的频率和$&gt;&gt;f_p$的频率通过性较好。</p><h3 id="如何满足相位"><a href="#如何满足相位" class="headerlink" title="如何满足相位"></a>如何满足相位</h3><p>在电子系统-振荡器一节中，我们提到，巴克豪森振荡准则是系统起振的必要不充分条件。那么皮尔斯振荡器是如何满足这个条件的呢？</p><p>观察下图，其可以被改写为另一种形式：</p><p><table><br>    <tr><br>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/8601a18b87d6277ff030a1392a381f30e924fc95"></center></td><br>          <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240408173101903.png"></center></td></p><p>其中$R_1$可以被理解为一个很小的等效电阻（当然也可以实际加一个电阻在这里）。</p><ol><li>首先，反向放大器让信号相位旋转了180°。</li><li>$R_1,C_1$让信号相位旋转了90°之间的任意一个值（取决于$R_1, C_1$的大小）。</li><li>如果晶振此时呈现感性（即，振荡频率满足$f_s<f<f_p$），那么加上电容$C_2$其会让相位旋转>90°。那么此时，总有一个频率会让相位一共旋转360°，满足巴克豪森震荡准则。</li><li>但是，如果振荡频率$f<f_s$或是$f>f_p$，晶振都将呈容性，那么相当于串联了一个电容，在加上电容$C_2$，整体相位移动会为0°。处于$f_s$时，晶振呈纯阻性，相位移动位于0-90°。</li></ol><p><strong>因此，一定有一个频率位于$f_s&lt;f&lt;f_p$之间，可让系统震荡。这也就是晶振震荡的频率。</strong></p><p>至此，我们已经讨论了它滤波选频的原理和满足巴克豪森振荡准则的原理。</p><h2 id="如何计算匹配电容"><a href="#如何计算匹配电容" class="headerlink" title="如何计算匹配电容"></a>如何计算匹配电容</h2><p>我们注意到，$C_1$和$C_2$两个电容是会影响相位的，而根据巴克豪森振荡准则，反只有相位为满足 $2n\pi$ 的信号才会起振，因此，$C_1,C_2$两个电容是会轻微影响震荡频率的（之所以是轻微影响，是因为它的影响范围在$f_s$到$f_p$之间，这个范围本就很小）。 </p><p>晶振的供应商会给一个“负载电容” $C_L$，$C_L$的值是晶振本身决定的，当晶振外部等效电容等于$C_L$时，其输出的频率最准确。因此代入皮尔斯震荡电路，可以得到如下公式：</p><script type="math/tex; mode=display">C_L=\frac{C_1\times C_2}{C_1+C_2}+C_s</script><p>其中:</p><ul><li>$C_s$为电路板杂散电容和晶振引脚间电容，经验值取3-5pF.</li></ul><p>如果让$C_1=C_2$的话：</p><script type="math/tex; mode=display">C_1=C_2=2(C_L-C_s)</script><p>至此便可计算$C_1$和$C_2$的值。</p><h1 id="Boot选择器"><a href="#Boot选择器" class="headerlink" title="Boot选择器"></a>Boot选择器</h1><h2 id="三种Boot模式"><a href="#三种Boot模式" class="headerlink" title="三种Boot模式"></a>三种Boot模式</h2><p>stm32有三种boot模式，分别使用boot0 和boot1引脚进行控制</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/20210423125742719.png" alt="img"></p><h3 id="主闪存启动"><a href="#主闪存启动" class="headerlink" title="主闪存启动"></a>主闪存启动</h3><ul><li>启动地址：0x08000000 </li><li>BOOT0: 0;  BOOT1: X</li></ul><p>这是STM32内置的Flash，一般使用JTAG或者SWD模式下载程序时，会写入到该区域内，重启后也直接从这启动程序。基本上都是采用这种模式。</p><h3 id="系统存储器启动"><a href="#系统存储器启动" class="headerlink" title="系统存储器启动"></a>系统存储器启动</h3><ul><li>启动地址：0x1FFF0000</li><li>BOOT0: 1;  BOOT1: 0</li></ul><p>系统存储器是芯片内部一块特定的区域，STM32在出厂时，由ST在这个区域内部预置了一段BootLoader。ST公司的这一段Bootloader中提供了使用串口下载程序的固件。可以通过这个BootLoader将程序下载到系统的Flash中。通过串口下载程序步骤如下：</p><p>电脑通过 USB 转串口线连接 STM32 的 USART1，并打开电脑端的上位机；</p><ul><li>接 BOOT0 为高电平，BOOT1 为低电平（选择 System Memory 启动）；</li><li>复位单片机使其进入 bootloader 模式，此时串口可读取；</li><li>接回 BOOT0 低电平，BOOT1 低电平（选择 Flash启动）；</li><li>复位单片机即可启动用户代码，正常运行；</li></ul><h3 id="SRAM启动"><a href="#SRAM启动" class="headerlink" title="SRAM启动"></a>SRAM启动</h3><ul><li>启动地址： 0x20000000</li><li>BOOT0: 1;  BOOT1: 1</li></ul><p>SRAM没有存储程序的能力，一般用于程序调试。如果程序只进行了小修改，然后完全刷入flash，这个过程非常费时。而SRAM读写速度很快，可以在调试的时候使用。</p><h2 id="Boot选择电路"><a href="#Boot选择电路" class="headerlink" title="Boot选择电路"></a>Boot选择电路</h2><h3 id="手动选择电路"><a href="#手动选择电路" class="headerlink" title="手动选择电路"></a>手动选择电路</h3><p>一般来说，我们用不到SRAM启动。因此通常BOOT1通过一个10K电阻下拉接地。</p><p>当然，也可以用跳线让用户自由选择，如正点原子的STM32战舰v3开发版。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/20210516104650598.png" alt="STM32"></p><p>这便是STM32的启动模式手动选择电路。</p><h3 id="自动下载电路"><a href="#自动下载电路" class="headerlink" title="自动下载电路"></a>自动下载电路</h3><p>STM32可使用CH340配合MCUISP进行ISP烧写，这其中的步骤是到以System Memory模式启动，烧录程序，再切换到Flash模式运行程序。通过CH340上的MODEM通讯引脚，可实现该操作。其原理请参考 <em>CH340X+ISP烧录使用指南</em>。</p><p>CH340与单片机连接如下，同时BOOT1通过一个10K电阻下拉接地。<img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/6rGAjBbclrc6aBCFG2kPU72ix9d3Q5Ru3WdUvelS.jpeg" alt="img"></p><p>配合MCUISP软件，该电路可以实现自动对Boot模式进行选择，然后通过串口下载程序。</p><p><strong>此时CH340的RX需和STM32的USART1的TX（PA9）和USART1的RX（PA10）连接</strong>。</p><h1 id="复位电路"><a href="#复位电路" class="headerlink" title="复位电路"></a>复位电路</h1><p>STM32复位引脚为<code>NRST</code>，其复位引脚低电平有效，<strong>内部集成上拉电阻，因此无需外部上拉</strong></p><p>官方推荐的复位电路如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240409191441516.png" alt="image-20240409191441516"></p><p>可以看到，外部仅连接一个手动复位的按键和上电自动复位的电容。</p><h1 id="SWD下载电路"><a href="#SWD下载电路" class="headerlink" title="SWD下载电路"></a>SWD下载电路</h1><p>通常某宝买的盗版ST-Link，就是使用的SWD烧写。这种烧写方式只需要4根接线。 分别为<strong>VCC，GND，SWCLK, SWDIO。其中，SWCLK和SWDIO分别对应STM32上PA14和PA13引脚。</strong></p><p>其中：</p><ul><li><strong>SW协议规定，对于SWDIO，必须在电路板上进行上拉（ARM建议100KΩ）</strong>（虽然大部分板子都采用10KΩ上拉）。</li><li>对于SWCLK，芯片内部集成下拉，没有规定一定需要外部下拉。但是部分开发版依旧给了10K电阻的下拉。</li></ul><p>因此，下载电路如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240409190601883.png" alt="image-20240409190601883"></p><p>其中SWDCLK的下拉电阻可有可无，因为芯片内部已集成下拉。</p><h1 id="通信电平转换电路"><a href="#通信电平转换电路" class="headerlink" title="通信电平转换电路"></a>通信电平转换电路</h1><p>由于STM32使用的是3.3V CMOS电平，需要通过UART,I2C等协议与TTL设备（5V）通信时，尝尝需要进行通信电平转换。</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动通信-Ch3-技术基础</title>
      <link href="/posts/3fa30bac.html"/>
      <url>/posts/3fa30bac.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>这一章有笔记是因为院长w来听课了，所以写笔记还容易一点→_→….</p></div><h1 id="无线信道的性质"><a href="#无线信道的性质" class="headerlink" title="无线信道的性质"></a>无线信道的性质</h1><h2 id="信道均衡准则"><a href="#信道均衡准则" class="headerlink" title="信道均衡准则"></a>信道均衡准则</h2><p>在信号经过非理想信道时，会产生</p><p>下图就展示了信道(红色)，Zero-forcing equalizer（蓝色），Minimum mean squared error (MMSE) equalizer（绿色）的频响。可以看到，大体趋势上均衡器与信道频响相反。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240407103818078.png" alt="image-20240407103818078"></p><p>均衡器通常加在接收端滤波器后，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240407103125702.png" alt="image-20240407103125702"></p><h2 id="错误控制编码"><a href="#错误控制编码" class="headerlink" title="错误控制编码"></a>错误控制编码</h2><p>错误控制编码可以大体上分为两类：</p><ul><li>Forward error-correction (FEC)：前向纠错</li><li>Automatic-repeat request (ARQ)：错误重传</li></ul><h3 id="FEC"><a href="#FEC" class="headerlink" title="FEC"></a>FEC</h3><p><strong>工作原理：</strong></p><ol><li>发送端在每段数据中添加冗余的bit, 这些比特通过某些算法与数据比特关联，称为前向纠错码</li><li>接收端根据收到的数据重新计算冗余比特</li><li>如果受到的纠错码无法匹配，则出现错误，尝试通过冗余比特逆向计算纠错。</li></ol><p>FEC还可分为 块码(block codes) 和 卷积码(convolutional codes) 。</p><p><strong>块码</strong></p><p>对于块码而言，有编码率(code rate) 一概念：</p><script type="math/tex; mode=display">code\ rate =\frac{information\ bits\ length}{encoded\ block\ length}</script><p>由此可以将信道的数据速率和信源的数据速率关联起来：</p><script type="math/tex; mode=display">R_0=\frac{R_s}{code\ rate}</script><p>其中$R_0$是信道速率，$R_s$是信源速率</p><p><strong>卷积码</strong></p><p>卷积码计算可以被视为输入序列与编码器的脉冲响应的离散时间卷积。脉冲响应的持续时间等于编码器的存储器。因此，在卷积码中，信道编码器将消息比特作为连续序列，并以更高的速率生成编码比特的连续序列</p><p>在离散时间系统中，通过延迟器抽头来进行卷积码计算。因此说系统有无存储器（Memory）是区分卷积码和块码的核心。下面是一个卷积码的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240407105915862.png" alt="image-20240407105915862"></p><h3 id="ARQ"><a href="#ARQ" class="headerlink" title="ARQ"></a>ARQ</h3><p>与FEC相反。在ARQ中，接收机尝试检测错误的存在，如果发现错误，则将请求发送回发射机以重新发送数据。因此，ARQ需要一个反馈信道。由于重传，ARQ有一定的延迟，这使得ARQ的使用不适合用于语音通信。在无线通信中，ARQ对于分组无线电网络是有用的。</p><p>最常见的ARQ技术是CRC：给定一个k比特的比特块（消息），发射机生成一个（n-k）比特序列，称为帧校验序列（FCS），这样由n个比特组成的结果帧就可以被某个预定的数整除。在接收机侧，输入的比特序列除以该数字，如果没有余数，则认为没有错误。(奇偶校验位是CRC的特殊情况)。</p><h2 id="分集-Diversity-技术"><a href="#分集-Diversity-技术" class="headerlink" title="分集(Diversity)技术"></a>分集(Diversity)技术</h2><p>分集的核心思想是：“不把鸡蛋放在同一个篮子里”。它使携带同一信息的多个信号<strong>衰落特性相互独立</strong>，并对这些信号进行特定的处理，从而减小衰落对信号影响的技术。也就是在发射机和接收机之间提供多个逻辑信道，然后在每个信道上发送部分信号。可以通俗地说是“<strong>分</strong>散传输，<strong>集</strong>中处理”。</p><h3 id="空间分集"><a href="#空间分集" class="headerlink" title="空间分集"></a>空间分集</h3><p>空间分集（space diversity）也叫天线分集（antenna diversity），是一种在发射端或（和）接收端安装多根不同位置的天线的分集技术。若这些天线的距离足够大，则电磁波受到衰落的影响就相互独立。用人话就是：用多个天线发送或接收同一个信号，然后集中处理。</p><h3 id="时间分集"><a href="#时间分集" class="headerlink" title="时间分集"></a>时间分集</h3><p>时间分集是通过对信道随时间的衰落进行平均来实现的。典型的就是交织技术。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240407114922778.png" alt="image-20240407114922778"></p><h3 id="频率分集"><a href="#频率分集" class="headerlink" title="频率分集"></a>频率分集</h3><p>频率分集的一个典型是扩频通信，让原有信号带宽分散在更大的频带上。此处可以参考文章 [扩频通信简介]</p><p>另一个例子是OFDM（Orthogonal Frequency Division Multiplexing 正交频分复用），OFDM主要思想是：将信道分成若干<strong>正交子信道</strong>，将高速数据信号转换成<strong>并行</strong>的<strong>低速子数据流</strong>，调制到在每个<strong>子信道上进行传输</strong>。正交信号可以通过在接收端采用相关技术来分开，这样可以减少子信道之间的相互干扰(ISI) 。每个子信道上的信号带宽小于信道的相关带宽，因此每个子信道上可以看成平坦性衰落，从而可以消除码间串扰，而且由于每个子信道的带宽仅仅是原信道带宽的一小部分，信道均衡变得相对容易。</p><p>它的调制和解调是分别基于IFFT和FFT来实现的，是实现复杂度最低、应用最广的一种多载波传输方案。相较于频分复用（单纯使用频率划分子信道，而不正交），它可以实现更高的频谱利用率。下图是FDM的频谱和OFDM的频谱，可以看到，OFDM更为密集。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240410104225740.png" alt="image-20240410104225740"></p><h2 id="合并技术-Combining-methods"><a href="#合并技术-Combining-methods" class="headerlink" title="合并技术(Combining methods)"></a>合并技术(Combining methods)</h2><p>分集技术是在发射段而言的，而合并技术就是将分集发射的信号重新合并在一起的技术。</p><h3 id="最大比合并-MRC-Maximum-Ratio-Combining"><a href="#最大比合并-MRC-Maximum-Ratio-Combining" class="headerlink" title="最大比合并 (MRC: Maximum Ratio Combining)"></a>最大比合并 (MRC: Maximum Ratio Combining)</h3><p>对于来自发射端的同一个信号，由于在接收端使用多天线接收，这个信号将经过多条路径（多个天线）被接收端所接收。多个路径质量同时差的几率非常小，<strong>一般总有一条路径的信号比其他信号好</strong>。在接收端使用某种算法，<strong>对各接收路径上的信号进行加权汇总，信号好的路径分配最高的权重</strong>，实现接收端的信号改善。当多条路径上信号都不太好时，通过MRC技术能够获得较好的接收信号</p><h3 id="等增益合并-EGC-Equal-Gain-Combining"><a href="#等增益合并-EGC-Equal-Gain-Combining" class="headerlink" title="等增益合并(EGC:Equal Gain Combining)"></a>等增益合并(EGC:Equal Gain Combining)</h3><p>等增益合并也称为<strong>相位均衡</strong>，仅仅对信道的<strong>相位偏移进行校正而幅度不做校正</strong>。等增益合并不是任何意义上的最佳合并方式，<strong>只有假设每一路信号的信噪比相同的情况下，在信噪比最大化的意义上，它才是最佳的</strong>。并且，由于缺少对信道幅度的了解，该技术并不适用于所有调制类型，并且其性能比MRC差。</p><h3 id="均方合并-SLC-Square-Law-Combining"><a href="#均方合并-SLC-Square-Law-Combining" class="headerlink" title="均方合并(SLC:Square Law Combining)"></a>均方合并(SLC:Square Law Combining)</h3><p>如果信道是高度时变的，并且其相位不能准确估计，那么可采用SLC合并方法。SLC简单地将接收信号的平方幅度相加，而不进行相干。此技术只能应用于正交信号的合并。</p><h3 id="切换合并-Switching-Combining"><a href="#切换合并-Switching-Combining" class="headerlink" title="切换合并(Switching Combining)"></a>切换合并(Switching Combining)</h3><p>接收机扫描所有的分集支路，<strong>并选择SNR 在特定的预设门限之上的特定分支</strong>。在该信号的SNR 降低到所设的门限值之下之前，<strong>选择该信号作为输出信号</strong>。当SNR 低于设定的门限时，接收机开始重新扫描并切换到另一个分支，该方案也称为扫描合并。这种方式降低了计算成本，甚至可能有比MRC更好的性能，因为SNR非常低的信道不仅不能准确还原信息，还贡献了很多噪声。</p><h1 id="无线通信的复用技术"><a href="#无线通信的复用技术" class="headerlink" title="无线通信的复用技术"></a>无线通信的复用技术</h1><p>分集技术是将一个一个信号分散到不同的子信道传输，来提高该信号的传输质量。而复用技术是使用不同的子信道传输不同的信号，目的是提高频谱利用效率。</p><p>复用技术主要在一下四个方向上进行复用</p><ul><li>时间 （时分复用 Time-Division Multiplexing TDM）</li><li>频率 （频分复用 Frequency-Division Multiplexing FDM）</li><li>编码 （码分复用 Code-Division Multiplexing CDM）</li><li>空间 （空分服用 Space-Division Multiplexing SDM）</li></ul><h2 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h2><p>频分复用将信道在频域上划分成不同子信道，每一个信号占用一个频率。如下图是信号k1-k6在频域上的分布图。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240410111411683.png" alt="image-20240410111411683"></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>不需要动态协调，因为一个信号固定使用一个子频，该频永远属于该信号。</li><li>数字信号和模拟信号都可使用</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>信道利用率低：不同信号之间的流量可能分布不均匀，造成部分子信道闲置，此时会浪费带宽</li><li>灵活性差：每一个信号的频率固定</li><li>频率间需要设置过渡带，不同频率需要有一个小间隔，造成资源浪费</li></ul><h2 id="时分服用"><a href="#时分服用" class="headerlink" title="时分服用"></a>时分服用</h2><p>不同时间段发不同的信号，单一信号可占用介质中所有的可用带宽。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240410111840706.png" alt="image-20240410111840706"></p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul><li>不存在频间干扰：介质中只同时存在一个频率，因此不会有FDM中频率间相互干扰的问题。</li><li>对多用户场景，它有很高的吞吐量。</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>需要非常精确的同步：需要从不同时间信道中分离出来自己的信号，因此对时间同步的要求非常高。</li></ul><h2 id="时频复用"><a href="#时频复用" class="headerlink" title="时频复用"></a>时频复用</h2><p>将时分复用和频分复用结合起来。如下图所示，下图k1-k6被成为资源块，每一个资源块可以划分给一个用户。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240410112230934.png" alt="image-20240410112230934"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>对于频率选择性干扰有一定保护效果。因为频率选择性干扰只在一个频率上持续。</li></ul><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>在时间和频率上都需要设置间隔带，会造成资源额外开销</li></ul><h2 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h2><p>码分复用使得每一个子信道有自己的一段编码，通过该编码分离子信道信号。一个例子是直序扩频。在该复用模式下，用户可在同一时间使用同一频谱。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240410112847036.png" alt="image-20240410112847036"></p><h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><ul><li>频谱利用率高</li><li>不需要动态协调</li><li>抗干扰能力强</li></ul><h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>需要在信号检测上引入更复杂的设计。</li></ul><h2 id="空分复用"><a href="#空分复用" class="headerlink" title="空分复用"></a>空分复用</h2><p>空分复用使用空间划分频谱资源，在一定区域内，用户使用的频谱可与另一不互相影响区域重合。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240410113336244.png" alt="image-20240410113336244"></p><h2 id="一些其他的概念"><a href="#一些其他的概念" class="headerlink" title="一些其他的概念"></a>一些其他的概念</h2><h3 id="多址接入"><a href="#多址接入" class="headerlink" title="多址接入"></a>多址接入</h3><p>多址是一个MAC层的概念，<strong>蜂窝系统中是以信道来区分通信对象的</strong>，一个信道只容纳一个用户进行通信，许多同时进行通信的用户，互相以信道来区分，这就是多址。它可以采用上面几种复用来实现，称为FDMA、TDMA、CDMA和SDMA（其中 MA 是Multiple Access，而不是上面的Multiplexing）</p><h3 id="双工"><a href="#双工" class="headerlink" title="双工"></a>双工</h3><p>双工（duplex）， 指二台通信设备之间，允许有双向的资料传输。也就是存在上行和下行两个信道。</p><p>上面提到的复用技术同样可用于双共，给上行和下行划分不同的子信道。分别称之为：频分双工（FDD），时分双共（TDD），码分双共（CDD），其中DD是Division Duplex的缩写。</p><h1 id="调制基础"><a href="#调制基础" class="headerlink" title="调制基础"></a>调制基础</h1><h2 id="基础的调制方式"><a href="#基础的调制方式" class="headerlink" title="基础的调制方式"></a>基础的调制方式</h2><div class="note info flat"><p>PSK，AM；ISI以及Raised-cosine pulse的频谱最窄，在通信原理已经学习，这里不再赘述。</p></div><h3 id="QAM"><a href="#QAM" class="headerlink" title="QAM"></a>QAM</h3><p>QAM(Quadrature Amplitude Modulation)：“正交振幅调制”，其幅度和相位同时变化。它将ASK和PSK汇合到一个信道。正交调幅信号有两个相同频率的载波，但是相位相差90度。QAM一般使用格雷码进行映射。</p><p>如下图是16-QAM的波形图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/download" alt="16-QAM示意图"></p><p>下图是16QAM的星座图</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240417105955875.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240417112058124.png"></center></td>    </tr></table><div class="note info flat"><p>这一部分讲的比较快，因为通信原理已经讲过</p></div><h1 id="扩频通信"><a href="#扩频通信" class="headerlink" title="扩频通信"></a>扩频通信</h1><p><strong>扩频通信的优势：</strong></p><ul><li>原本窄带信号频谱被扩宽之后，具有更好的抗窄带噪声的特性</li><li>扩频之后频谱隐藏在噪声中，难以监听</li><li>利用扩频码可以进行码分复用</li><li>良好的抗多径效应</li></ul><p><strong>凡是看到码分的，就是用了扩频技术的。例如重庆邮电大学的第一颗TD-SCDMA3G芯片</strong></p><div class="note info flat"><p>这一部分更详细的内容请参考<em>LoRa定位开发-扩频通信简介</em>中<strong>跳频扩频</strong>和<strong>直序扩频</strong>；传送门：<a href="https://www.kaysonz.top/2024/01/14/LoRa(%E9%80%9A%E4%BF%A1">扩频通信简介</a>%E5%AE%9A%E4%BD%8D/%E6%89%A9%E9%A2%91%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/)</p></div><h2 id="直序扩频"><a href="#直序扩频" class="headerlink" title="直序扩频"></a>直序扩频</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>请参考<em>LoRa定位开发-扩频通信简介</em>中<strong>直序扩频</strong>；传送门：<a href="https://www.kaysonz.top/2024/01/14/LoRa(%E9%80%9A%E4%BF%A1">扩频通信简介</a>%E5%AE%9A%E4%BD%8D/%E6%89%A9%E9%A2%91%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/)</p><h3 id="Rake接收器（还在用传统接收器？）"><a href="#Rake接收器（还在用传统接收器？）" class="headerlink" title="Rake接收器（还在用传统接收器？）"></a>Rake接收器（还在用传统接收器？）</h3><p>在前面直序扩频中介绍，DSSS抗多径效应的原理是选择信号功率最强的一个解扩，而其他路径分量相当与进行了扩频。这恰好就像是在做分集接收。Rake接收器就是将这个过程认为是分集来处理。</p><p>Rake接收机假设每个多径分量间隔一定时延，因此有多条接收之路，分别对不同时延迟的信号进行接扩，最后进行合并。理想来说，瑞刻接收机使用MRC的方式进行合并，但具体的方式需要根据特定场景优化。</p><p>下图为瑞刻接收机模型，可以看到，支路间有一定延迟。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240419104636201.png" alt="image-20240419104636201" style="zoom:50%;" /></p><h2 id="跳频扩频"><a href="#跳频扩频" class="headerlink" title="跳频扩频"></a>跳频扩频</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>请参考<em>LoRa定位开发-扩频通信简介</em>中<strong>跳频扩频</strong>；传送门：<a href="https://www.kaysonz.top/2024/01/14/LoRa(%E9%80%9A%E4%BF%A1">扩频通信简介</a>%E5%AE%9A%E4%BD%8D/%E6%89%A9%E9%A2%91%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/)</p><h1 id="多址接入-Multiple-Access"><a href="#多址接入-Multiple-Access" class="headerlink" title="多址接入(Multiple Access)"></a>多址接入(Multiple Access)</h1><p>多址接入是位于MAC层，物理层之上的一种实现点到多点的通信的技术。它可以分为竞争协议和非竞争协议，如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240419113836159.png" alt="image-20240419113836159" style="zoom:50%;" /></p><h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>网络中的节点在网络中的地位是等同的，各节点通过竞争获得信道的使用权，类似与谁喊得大谁就能发。典型的协议是Aloha。</p><h3 id="非竞争"><a href="#非竞争" class="headerlink" title="非竞争"></a>非竞争</h3><p>所有设备依据某一规则，编排发信顺序。有统一调度。这里面又可以分为</p><ul><li>Dynamic allocation（动态分配）：有一中心节点根据当前状况，动态分配信道资源。</li><li>Static allocation（静态分配）：根据某种恒定的规则发信。例如前面提到的CDMA，SDMA等。</li></ul><h2 id="SDMA"><a href="#SDMA" class="headerlink" title="SDMA"></a>SDMA</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240419115355511.png" alt="image-20240419115355511"></p><h2 id="TDMA"><a href="#TDMA" class="headerlink" title="TDMA"></a>TDMA</h2><p>时分多址允许多个用户在不同的时间片（时隙）使用相同的频率传输数据。每个用户使用他们自己的时间片</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240424103804246.png" alt="image-20240424103804246"></p><p>他的显著优势是它的共品行</p><h2 id="CDMA"><a href="#CDMA" class="headerlink" title="CDMA"></a>CDMA</h2><h2 id="DS-CDMA"><a href="#DS-CDMA" class="headerlink" title="DS-CDMA"></a>DS-CDMA</h2>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 移动通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动通信-知识汇总</title>
      <link href="/posts/3fa30bac.html"/>
      <url>/posts/3fa30bac.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>移动通信这门课<a href="https://l61012345.top/2022/04/09/学习笔记/移动通信/1.移动通信/">Mirror</a>上的笔记已经比较完善。加之由于各种各样的原因（指碳基人工智能念硅基人工智能辅助做的PPT的课程呈现方式），本课确实难以写出来笔记。这里只提供一个根据考点写的重点汇总。</p></div><div class="note info flat"><p>我是学通信工程的，这个课程是通信工程捡史（简称史）</p></div><h1 id="CH1-Overview"><a href="#CH1-Overview" class="headerlink" title="CH1-Overview"></a>CH1-Overview</h1><h2 id="三种传输波"><a href="#三种传输波" class="headerlink" title="三种传输波"></a>三种传输波</h2><h3 id="地波传播（Ground-Wave）"><a href="#地波传播（Ground-Wave）" class="headerlink" title="地波传播（Ground Wave）"></a>地波传播（Ground Wave）</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240408194113961.png" alt="image-20240408194113961"></p><p>地波指贴着地面，随着地表弧度弯曲传播的电磁波，它的传播距离可以远超视觉地平线。</p><p>地波的频率大约为<strong>2MHz</strong>。典型的地波通信是AM广播。</p><h3 id="天波传播（Sky-Wave）"><a href="#天波传播（Sky-Wave）" class="headerlink" title="天波传播（Sky Wave）"></a>天波传播（Sky Wave）</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240408194617027.png" alt="image-20240408194617027"></p><p>天波依靠电离层（ionized layer）反射传播，同样可以实现NLOS传播。天波传播用于业余无线电、CB 无线电和国际广播。</p><h3 id="Line-of-Signt-传播。"><a href="#Line-of-Signt-传播。" class="headerlink" title="Line-of-Signt 传播。"></a>Line-of-Signt 传播。</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240408195724164.png" alt="image-20240408195724164"></p><p>地面和天波传播模式不能传输超过30 MHz的电磁波 ，此时必须使用LOS传播</p><h2 id="衰落"><a href="#衰落" class="headerlink" title="衰落"></a>衰落</h2><div class="note info flat"><p>不要问我有什么区别，我也不知道，这课就是一坨屎，黑色的sh*t和黄色的sh*t我都能解释区别，这个我解释不了。我只能说我在看南邮通信原理里面记的快衰落和慢衰落是和相干时间有关的。</p></div><p>  衰落有两套区分方法：快衰落&lt;-&gt;慢衰落；大尺度衰落&lt;-&gt;小尺度衰落</p><ul><li><strong>大尺度衰落（large scale fading）：</strong>从宏观上描述大范围运动产生的平均功率衰减或路径损耗。多受发射和接收机间的主要地貌的影响</li><li><p><strong>小尺度衰落（small scale fading）</strong>：小尺度衰落，<strong>是指接收机与发射机间空间距离的小变化（如半波长）引起信号幅度和相位的急剧变化</strong>，主要由信号的多径传播（multipath effect）和收发两端的相对运动引起。</p></li><li><p><strong>慢衰落（fast fading）：</strong>信号强度受信号路径上的足够大的障碍物影响，这种现象被称为慢衰落，也叫做长期衰落（long term fading）或阴影效应（shadowing）。</p></li><li><strong>快衰落（slow fading）：</strong>信号强度在短时间或小空间范围内的快速变化。它主要由多径效应引起。快衰落在LOS下，信号功率的包络线服从莱斯分布(Rice distribution)；在NLOS下，信号功率的包络线服从瑞利(Rayleigh)分布。</li></ul><h2 id="无线网络的分类："><a href="#无线网络的分类：" class="headerlink" title="无线网络的分类："></a>无线网络的分类：</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240624155627674.png" alt="image-20240624155627674"></p><ul><li>Wireless Body Area Network：提供耳机，显示之类的连接</li><li>Wireless Personal Area Network：提供和周围的其他设备的连接</li><li>Wireless Local Area Network：提供因特网连接</li><li>Wireless Wide Area Network：提供远距离的多个主机连接</li></ul><hr><h1 id="CH2-无线信道"><a href="#CH2-无线信道" class="headerlink" title="CH2-无线信道"></a>CH2-无线信道</h1><h2 id="dB单位："><a href="#dB单位：" class="headerlink" title="dB单位："></a>dB单位：</h2><p>这一部分在通信工程的专业课中涉及太多了，详情参见<a href="https://www.kaysonz.top/posts/7cf324fe">电信传输理论-CH1-通信传输的基本概念 | 風</a>这里面的介绍</p><h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><h3 id="噪声的主要来源："><a href="#噪声的主要来源：" class="headerlink" title="噪声的主要来源："></a>噪声的主要来源：</h3><ul><li><strong>大气噪声：</strong>大气噪声主要是由大气中的闪电放电引起的，这些闪电放电通过电离层反射在世界范围内传播。全世界每秒大约有100次闪电。大气噪声功率与频率成反比。它的强度也随着一天中的时间、天气、季节和地理位置而变化。</li><li><strong>宇宙噪声：</strong>宇宙噪声是由地球大气层外的扰动引起的。宇宙噪音的主要来源是太阳和大量的“射电星（radio stars）”，这些“射电星”主要分布在银河面(银河系)。</li><li><strong>人为噪声：</strong>人为的噪声是由各种电器引起的，例如:电视接收器、点火系统、电动机及其控制装置，以及来自电力线的高频元件的不稳定辐射。传播通过电力线直接传输、辐射、感应，偶尔也通过电离层反射。</li></ul><h3 id="热噪声"><a href="#热噪声" class="headerlink" title="热噪声"></a>热噪声</h3><p>热噪声是由导电介质中电荷(通常是电子)的随机运动引起的。每一种元件和电路都会产生热噪声，它会吸收能量(由于电子在与介质晶体结构碰撞时失去动能)。热噪声具有与频率无关的恒定功率谱，并且具有平稳高斯随机过程的分布。<br>一定带宽内的热噪声功率可以被描述为:</p><script type="math/tex; mode=display">P_N=kTB\times F</script><p>其中：</p><ul><li>k：玻尔兹曼常数，$k=1.3805 * 10^{-23}J/K$</li><li>T：开尔文温度</li><li>B：信号带宽</li><li>F：噪声系数，用于修正由于非理想接收器电子器件导致的热噪声增加，理想值为1</li></ul><p>代入k，化为dBm形式有：</p><script type="math/tex; mode=display">P_N[dBm]=10log_{10}\bigg(\frac{kT}{1mW}\bigg)+10log_{10}(B)+10log_{10}(F)</script><p>室温时一般取$T=288k=15^\circ C$，因此有：</p><script type="math/tex; mode=display">P_N[dBm]=(-174+10log_{10}(B))[dBm]+NF[dB]</script><p>其中这个NF就是前面的噪声系数（noise factor）。这里出现单位混用是由于NF常常是用于描述一个系统输入与输出的关系（即，不是dBm这个以1mW为基的单位，而是$10log(\frac{P_{out}}{P_{in}})$），因此它的单位是dB。这里直接混用即可，因为dBw是个绝对单位，而dB是放大/衰减相对单位，1dBw经过2dB的放大器最后等于3dBw，就是这样。</p><h2 id="通信系统传输建模"><a href="#通信系统传输建模" class="headerlink" title="通信系统传输建模"></a>通信系统传输建模</h2><h3 id="自由空间损耗（Free-space-loss）"><a href="#自由空间损耗（Free-space-loss）" class="headerlink" title="自由空间损耗（Free space loss）"></a>自由空间损耗（Free space loss）</h3><p>这个概念和推导也涉及过很多遍了，这里只是换了个单位。推导请见：<a href="https://www.kaysonz.top/posts/9b43b6f">电信传输理论-CH3-传输介质 | 風 </a>最后一个小节。</p><script type="math/tex; mode=display">FSL[dB]=32.4+20log_{10}(d_{[km]})+20log_{10}(f_{[MHz]})</script><h3 id="各向同性辐射有效功率（Effective-isotropic-radiated-power-EIRP-）"><a href="#各向同性辐射有效功率（Effective-isotropic-radiated-power-EIRP-）" class="headerlink" title="各向同性辐射有效功率（Effective isotropic radiated power (EIRP) ）"></a>各向同性辐射有效功率（Effective isotropic radiated power (EIRP) ）</h3><script type="math/tex; mode=display">EIRP_{[dBW]}=P_T-L_T+G_T</script><ul><li>$P_T$：传输功率</li><li>$L_T$：馈线损耗（feeder loss），指连接天线的那条线造成的损耗（一般是阻抗50欧的同轴线）</li><li>$G_T$：传输天线增益</li></ul><h3 id="各项同性接收电平（Isotropic-receive-level-IRL-）"><a href="#各项同性接收电平（Isotropic-receive-level-IRL-）" class="headerlink" title="各项同性接收电平（Isotropic receive level (IRL) ）"></a>各项同性接收电平（Isotropic receive level (IRL) ）</h3><script type="math/tex; mode=display">IRL=EIRP_{[dBW]}-FSL_{[dB]}-L_g</script><ul><li>$L_g$：气体吸收损耗（gaseous absorption loss）</li></ul><h3 id="无损接收信号电平（Unfaded-receive-signal-level-RSL-）"><a href="#无损接收信号电平（Unfaded-receive-signal-level-RSL-）" class="headerlink" title="无损接收信号电平（Unfaded receive signal level (RSL) ）"></a>无损接收信号电平（Unfaded receive signal level (RSL) ）</h3><script type="math/tex; mode=display">RSL=IRL+G_R-L_R</script><ul><li>$G_R$：接收天线增益</li><li>$L_R$：接收馈线损耗</li></ul><h3 id="无损载波噪声比（Unfaded-carrier-to-noise-ratio-CNR-）"><a href="#无损载波噪声比（Unfaded-carrier-to-noise-ratio-CNR-）" class="headerlink" title="无损载波噪声比（Unfaded carrier-to-noise ratio (CNR)）"></a>无损载波噪声比（Unfaded carrier-to-noise ratio (CNR)）</h3><p>这个Unfaded 主要指没有经受噪声影响</p><script type="math/tex; mode=display">C/N_{dB}=RSL-P_N=P_T-L_T+G_T-FSL_{dB}-L_g+G_R-L_R-P_N</script><p>上面这些各个阶段对应的范围如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240623123405780.png" alt="image-20240623123405780"></p><h3 id="灵敏度（Sensitivity）"><a href="#灵敏度（Sensitivity）" class="headerlink" title="灵敏度（Sensitivity）"></a>灵敏度（Sensitivity）</h3><p>灵敏度是一个接收器参数，表示接收天线提供可靠通信所需的最小信号电平。</p><p><em>举个例子，用于数据传输的移动接收器有- 90dbm的灵敏度。假设发射功率为100mw，只考虑自由空间传播损耗，发射频率为800mhz，天线为单位增益（Gian=1），无馈线损耗，服务区域半径为多少?</em></p><p>最小接收功率为：</p><script type="math/tex; mode=display">log^{-1}(-9)=1\times10^{-9}mW</script><p>容忍损耗为：</p><script type="math/tex; mode=display">10log_{10}(\frac{10^{-9}mW}{100mW})=-110dB</script><p>即：</p><script type="math/tex; mode=display">-110dB=32.4+20log_{10}(d_{[km]})+20log_{10}(800_{[MHz]})\to d=9.4822km</script><h3 id="简化路径损耗模型（Simplified-path-loss-model）"><a href="#简化路径损耗模型（Simplified-path-loss-model）" class="headerlink" title="简化路径损耗模型（Simplified path loss model）"></a>简化路径损耗模型（Simplified path loss model）</h3><p>为了对信号的路径损耗进行建模，模型有很多，自由空间损耗是其中之一，除此之外还有Two ray–model, General ray-tracking models等等。这里介绍一个Simplified path loss model</p><script type="math/tex; mode=display">P_R(d)=P_R(d_0)\bigg(\frac{d_0}{d}\bigg)^n</script><ul><li>$P_R(d)$：接收功率的函数</li><li>$d$：实际距离</li><li>$d_0$：参考距离（$P_R(d_0)$指参考距离处测得的功率）</li><li>$n$：路径损耗指数</li></ul><p>这个模型中，损耗的部分是$(\frac{d_0}{d})^n$，写成dB形式有：</p><script type="math/tex; mode=display">L_{dB}=10nlog_{10}\bigg(\frac{d_0}{d}\bigg)</script><p>这是一个经验模型，比较适用于室内，但是不是很准确。</p><p>对于路径损耗指数$n$，通常有以下数值：</p><div class="table-container"><table><thead><tr><th style="text-align:center">环境</th><th style="text-align:center">n值</th></tr></thead><tbody><tr><td style="text-align:center">自由空间</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">公寓、住宅</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">丘陵地带</td><td style="text-align:center">3.5</td></tr><tr><td style="text-align:center">郊区</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">城市</td><td style="text-align:center">4.5</td></tr><tr><td style="text-align:center">写字楼内（同一层）</td><td style="text-align:center">1.6-3.5</td></tr><tr><td style="text-align:center">写字楼内（不同层）</td><td style="text-align:center">2-6</td></tr></tbody></table></div><h2 id="大尺度衰落模型"><a href="#大尺度衰落模型" class="headerlink" title="大尺度衰落模型"></a>大尺度衰落模型</h2><p>大尺度衰落（Large scale fading）：大尺度衰落是由于<strong>阴影效应</strong>和<strong>路径损耗</strong>造成的，因此也被称为shadow fading。</p><ul><li>路径损耗是指当无线电信号在较远的距离上通过信道传输时，波能随介质扩散。传输路径增加，导致接收信号的平均功率衰减。距离越大，衰减越大。它是发送的平均功率和接收的平均功率之间的差。</li><li>阴影效应是指是建筑物、山丘、树木（甚至树叶）会削弱甚至阻挡信号。信号只能通过反射、散射等传播到阴影区域。经验测量表明，阴影通常遵循对数正态分布。</li></ul><h3 id="简化路径损耗模型"><a href="#简化路径损耗模型" class="headerlink" title="简化路径损耗模型"></a>简化路径损耗模型</h3><p>以简化的路径损耗模型为基础，将阴影对信号强度的影响记为函数$\psi$，可得到一个路径损耗和阴影的组合模型：</p><script type="math/tex; mode=display">P_R(d)=P_R(d_0)\bigg(\frac{d_0}{d}\bigg)^n\psi</script><script type="math/tex; mode=display">P_R(d)_{dB}=P_R(d_0)_{dB}-10nlog_{10}\bigg(\frac{d}{d_0}\bigg)+\psi_{dB}=\widehat P_R(d_0)+\psi_{dB}</script><p>其中$\psi_{dB}$是一个均值为0，方差为某个特定数值的高斯分布函数</p><h3 id="掉话率（Outage-probability）"><a href="#掉话率（Outage-probability）" class="headerlink" title="掉话率（Outage probability）"></a>掉话率（Outage probability）</h3><p>由于发射机和接收机之间的路径损耗和阴影呈现随机性，因此有一定概率接收机接收到的功率会小于其灵敏度。接收到的信号功率小于接收机灵敏度的概率被定义为掉话率。</p><script type="math/tex; mode=display">P_{out}=p(P_R(d)<P_{min})=1-p(P_R(d)>P_{min})=1-(\widehat P_R(d_0)+\psi_{dB}>P_{min})</script><script type="math/tex; mode=display">=1-p(\psi_{dB}>P_{min}-\widehat P_R(d_0))</script><p>现在它被转化为了高斯分布落在其尾部的概率，尾部和前部的界定值就是$x_0=P_{min}-\widehat P_R(d_0)$。如下图。这里面Q是标准正态分布的概率分布函数（一般通过查表获得值）。由于$\psi_{dB}$是一个均值为$\mu=0$的函数，因此有下式</p><script type="math/tex; mode=display">P_{out}=1-Q(\frac{P_{min}-P_R(d_0)_{dB}+10nlog_{10}(d/d_0)}{\sigma_{\psi}})</script><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240623145101149.png" alt="image-20240623145101149" style="zoom:67%;" /></p><p>在掉话率中的这个路径损耗指数$n$是通过对采样的数据套用均方误差最小化的模型（minimum mean square error MMSE）拟合出来的。这里面均方误差（mean square error）的计算方法是：</p><script type="math/tex; mode=display">MSE=\frac{1}{m}\sum_{d=1}^{m} [\widehat P(d)-P_{measured}(d)]^2</script><p>其中m表示采样m个样本</p><p><em>举个例子，现采样到了下表，用MMSE拟合法求n</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240623152412239.png" alt="image-20240623152412239"></p><p>这里取$d_0=100m$</p><script type="math/tex; mode=display">MSE=\frac{1}{4}\sum_{d=1}^{4} [\widehat P(d)-P_{measured}(d)]^2=\frac{1}{4}\sum_{d=1}^{m} [P_R(d_0)_{dB}-10nlog_{10}\bigg(\frac{d}{d_0}\bigg)-P_{measured}(d)]^2</script><script type="math/tex; mode=display">=\frac{1}{4}[(0-0)^2+(0-3.01n+20)^2+(0-10n+35)^2+(0-14.77n+70)^2]</script><p>这是一个凸函数，因此当其斜率为0时，n有最小值</p><script type="math/tex; mode=display">\frac{d}{d_n}MSE=0\to654.306n-2887.8=0\to n=4.4</script><h2 id="小尺度衰落模型"><a href="#小尺度衰落模型" class="headerlink" title="小尺度衰落模型"></a>小尺度衰落模型</h2><p>小尺度衰落 又称 多径衰落，用于描述无线电信号在短时间或短距离内幅度的快速波动。主要是由多径效应和多普勒效应引起的。</p><ul><li><strong>多径效应：</strong>当波在传输过程中遇到各种障碍物时，会发生反射、衍射和散射，形成多条传播路径。由于路径长度不同，波到达接收机的时间也不同，导致相移。多径效应引起信号的时间色散。</li><li><strong>多普勒效应：</strong>当接收机和发射机相互相对运动时，接收到的波会发生频移。如果接收器远离源(两者都远离)，则接收频率逐渐降低。如果接收器靠近源(两者更近)，接收到的频率将逐渐增加。</li></ul><h3 id="半波长移动导致的信号相消"><a href="#半波长移动导致的信号相消" class="headerlink" title="半波长移动导致的信号相消"></a>半波长移动导致的信号相消</h3><p>当同一个信号抵达接收机时，如果其波长相差了一半，则会导致信号相互抵消。如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240623154928752.png" alt="image-20240623154928752"></p><h3 id="多普勒效应"><a href="#多普勒效应" class="headerlink" title="多普勒效应"></a>多普勒效应</h3><p>如果发射机或者接收机在移动，则会产生多普勒频移，多普勒频移会提高（靠近）或者减少（远离）载波的频率。其表达式是：</p><script type="math/tex; mode=display">f'=f\pm f_D, f_D=\frac{v}{\lambda}cos\theta</script><ul><li>靠近是+，远离是-</li><li>$v$表示发送机或者接收机移动的速度</li><li>$\lambda$表示载波波长</li><li>$\theta$表示波传播的方向和移动方向的夹角</li></ul><p><strong>Clarke model</strong></p><p>如果传输的信号是单一频率，那么多普勒效应会使得信号频谱展宽。Clarke模型就是用来描述信号受多普勒效应后频谱宽度的。在这个模型下，波从各个方向到达的概率是相等的，且服从瑞利衰落。</p><p>Clarke model的公式为：</p><script type="math/tex; mode=display">S_E(f)=\frac{1.5}{\pi f_m\sqrt{1-(\frac{f-f_c}{f_m})^2}}</script><p>其中：</p><ul><li>$S_E$是信号幅值</li><li>$f_m=max(\frac{v}{\lambda}cos\theta)=\frac{v}{\lambda}$，是多普勒频移的最大频移量</li><li>$f_c$是载波频率</li></ul><p>这个函数画出来图像长这样：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240623160908079.png" alt="image-20240623160908079" style="zoom:67%;" /></p><h2 id="信道的分类"><a href="#信道的分类" class="headerlink" title="信道的分类"></a>信道的分类</h2><h3 id="时间选择和时间平坦信道"><a href="#时间选择和时间平坦信道" class="headerlink" title="时间选择和时间平坦信道"></a>时间选择和时间平坦信道</h3><p><strong>相干时间（Coherence time）：</strong>(其中$f_m$是最大多普勒频偏，$f_m=\frac{v}{\lambda}$，v是设备移动速度。)</p><script type="math/tex; mode=display">T_{coh}=\frac{1}{f_m}</script><p>对于50%相干时间：</p><script type="math/tex; mode=display">T_{coh}\approx\frac{9}{16\pi f_m}</script><p><strong>时间平坦（慢衰落）信道（Time-flat channel）：</strong>信号的周期远远小于信道相干时间，信道在不同时刻衰落不会经历剧变</p><p><strong>时间选择（快衰落）信道（Time-selective channel）：</strong>信号周期大于等于相干时间，其不同时刻经历的衰落差异很大。</p><h3 id="频率选择和频率选择信道："><a href="#频率选择和频率选择信道：" class="headerlink" title="频率选择和频率选择信道："></a>频率选择和频率选择信道：</h3><p><strong>相干带宽（Coherence bandwidth）</strong></p><p>相干带宽是由多径传播过来的信号的功率时间差来计算的。首先需要计算平均延迟$\mu$，然后再计算由在$\mu$扩散的RMS delay $\sigma_\tau$。下式中$P_{av}$表示平均总功率，这个平均指的是信号功率平均，所以如果提供了平均功率，就直接加起来。</p><script type="math/tex; mode=display">\mu=\frac{1}{P_{av}}\sum_{\tau=0}^{\infty}\tau P(\tau)</script><script type="math/tex; mode=display">\sigma_\tau=\sqrt{\frac{1}{P_{av}}\sum_{\tau=0}^{\infty}(\tau-\mu )^2P(\tau)}</script><p>对于0.5倍相干带宽，有：</p><script type="math/tex; mode=display">B_{coh}\approx\frac{1}{5\sigma_\tau}</script><p><em>举个例子</em></p><div class="table-container"><table><thead><tr><th>Power（dB）</th><th>0</th><th>-9.7</th><th>-19.2</th><th>-22.8</th></tr></thead><tbody><tr><td>Delay (ns)</td><td>0</td><td>110</td><td>190</td><td>410</td></tr></tbody></table></div><p>先将功率换算回去，分别是：1, 0.107，0.012，0.005</p><script type="math/tex; mode=display">P_{av}=1,+0.107+0.012+0.005=1.124</script><script type="math/tex; mode=display">\mu=\frac{0\times1+110\times0.107+190\times0.012+410\times0.005}{1.124}=14.3ns</script><script type="math/tex; mode=display">\sigma_{\tau}=\sqrt{\frac{((0-14.3)^2\times1+(110-14.3)^2\times0.107+(190-14.3)^2\times0.012+(410-14.3)^2\times0.005}{1.124}}</script><script type="math/tex; mode=display">B_{coh}\approx\frac{1}{5\sigma_\tau}=4.4MHz</script><p><strong>平坦衰落信道（Frequency-flat channel）</strong>：若信道带宽小于相干带宽，不同频率所经历的衰减基本相同，称平坦衰落。</p><p><strong>频率选择信道：（Frequency-selective channel）</strong>：若信号的周期大于想干带宽，则衰落呈现频率差异性，称频率选择衰落。</p><hr><h1 id="CH3-基本技术-Part1"><a href="#CH3-基本技术-Part1" class="headerlink" title="CH3-基本技术-Part1"></a>CH3-基本技术-Part1</h1><h2 id="无线信道中使用的基本技术"><a href="#无线信道中使用的基本技术" class="headerlink" title="无线信道中使用的基本技术"></a>无线信道中使用的基本技术</h2><p>为了控制信道中由前面介绍的衰落带来的错误，发展出了信道均衡、信道编码、分集技术。其中某一种信道均衡方法一般只适用于一种波形或调制方法，但是信道编码比普适。</p><h3 id="信道均衡"><a href="#信道均衡" class="headerlink" title="信道均衡"></a>信道均衡</h3><p>由于信道的频率选择性和多径传播，这会导致不同频率的电磁波被收到的时间不同，造成电磁波色散。电信传输一课中有详细介绍：<a href="https://www.kaysonz.top/posts/3f7b092c">电信传输理论-CH5-金属传输线理论 | 風</a>。色散体现频谱上就是波形展宽，再加之信道一般是带宽有限的，会滤除掉一部分频率，这二者会导致码间干扰（inter-symbol-interferences, ISI）</p><p>信道均衡就是为了针对不同频率的进行补偿。均衡的常用方法是线性电路、横向滤波器或 FIR 滤波器。例如下面这个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240623163744876.png" alt="image-20240623163744876"></p><p>上图这个例子以均匀的时间间隔$\Delta$对信号进行采样，采样间隔通常通常为4倍或倍符号速率。然后由各个系数控制加权相加后再输出。回顾一下DSP，这其实就是一个FIR滤波器。</p><h3 id="信道编码"><a href="#信道编码" class="headerlink" title="信道编码"></a>信道编码</h3><p>信道上的差错控制编码主要有两大类：前向纠错码（Forward error-correction FEC）和 自动重传请求 （ Automatic-repeat request ARQ）</p><h4 id="FEC"><a href="#FEC" class="headerlink" title="FEC"></a>FEC</h4><p>FEC的工作原理如下:</p><ol><li>向发送的数据添加一些额外的位，这些位是纠错码，这些位和原本数据位之间有某种函数关联。</li><li>在接收端，接收端根据输入的数据位计算一个新的纠错码。如果新代码与传入代码匹配，则接收方认为该数据块中没有发生错误。</li><li>如果新的纠错码不匹配，且错误数量小于一个特定值时，接收机可以定位到错误并根据纠错码纠正它们。</li></ol><p>FEC可以分为</p><ul><li>分组码（block codes）：分组码一般写作：$(n,k)$，是指将k位数据设为一组，该组数据编码得n位编码后数据，即有$(n-k)$个冗余纠错位。实际是一组一组进行编码，每一组中的$(n-k)$位的冗余位的产生仅与k位信息位有关。其信道信息速率$R_0$，编码率（code rate）$\frac{k}{n}$，信源信息速率$R_S$的关系是:</li></ul><script type="math/tex; mode=display">R_0=\frac{n}{k}R_S</script><ul><li>卷积码（convolutional codes）：卷积码是一种有记忆的纠错码，它可以被看成是输入序列和encoder的进行离散卷积。输入序列被卷积的长度和encoder的存储大小有关（因此说，编码器内带内存的是卷积码）。由于在卷积码内输入的比特是被当做连续比特序列来进行卷积的（即，不是打包好一块走一块那种），因此卷积码可以以较高速度编码</li></ul><h4 id="ARQ"><a href="#ARQ" class="headerlink" title="ARQ"></a>ARQ</h4><p>ARQ技术和FEC想要实现的能通过加入冗余位在接收端恢复受损数据不同，它旨在让接收方仅仅检测错误的存在，发现错误存在后，再要求发送方重新发送数据（因此也称为后向纠错 backward error correction）。因此ARQ需要一个反馈信道，同时还有一定延迟。ARQ对于分组交换很有用。</p><p>ARQ用来判断数据是否出错的常见的错误检测技术之一是循环冗余校验(cyclic redundancy check CRC)：对于k位的数据块(message)，发送器生成一个(n-k)位冗余序列，称为帧校验序列(frame check sequence  FCS)。然后将其编码为由n位组成的编码后数据，这个数据被某个预定的数字完全整除。在接收端，用接收的比特除以该数字，如果没有余数，则认为没有错误。奇偶校验位是CRC的特殊情况。</p><h3 id="分集技术"><a href="#分集技术" class="headerlink" title="分集技术"></a>分集技术</h3><p><strong>为什么需要分集：</strong></p><ul><li>为了解决NLOS下Raylleigh和LOS下Ricean快衰落的问题</li><li>提高覆盖范围内的QoS</li></ul><p>分集的核心思想是：“不把鸡蛋放在同一个篮子里”。它使携带同一信息的多个信号<strong>衰落特性相互独立</strong>，并对这些信号进行特定的处理，从而减小衰落对信号影响的技术。也就是在发射机和接收机之间提供多个逻辑信道，然后在每个信道上发送部分信号。可以通俗地说是“<strong>分</strong>散传输，<strong>集</strong>中处理”。</p><p>总体来看，分集技术可以分为：</p><ul><li>空间分集</li><li>时间分集</li><li>频率分集</li></ul><h4 id="空间分集"><a href="#空间分集" class="headerlink" title="空间分集"></a>空间分集</h4><p>空间分集（space diversity）也叫天线分集（antenna diversity），是一种在发射端或（和）接收端安装多根不同位置的天线的分集技术。若这些天线的距离足够大，则电磁波受到衰落的影响就相互独立。用人话就是：用多个天线发送或接收同一个信号，然后集中处理。</p><h4 id="时间分集"><a href="#时间分集" class="headerlink" title="时间分集"></a>时间分集</h4><p>时间分集是通过对信道随时间的衰落进行平均来实现的，典型的就是交织技术（interleaving）。例如下图，假设编码有2bit的FEC纠错能力。将word1的后5个bit和word2的前5个bit交换拼接。在传输过程中拼接后的word2受到干扰错误4个bit，但是在接收逆交织后，就变成了2个bit错误，可以被更正。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240407114922778.png" alt="image-20240407114922778"></p><h4 id="频率分集"><a href="#频率分集" class="headerlink" title="频率分集"></a>频率分集</h4><p>频率分集的一个典型是扩频通信，让原有信号带宽分散在更大的频带上，然后利用Rake接收机（Rake接收机假设每个多径分量间隔一定时延，因此有多条接收之路，分别对不同时延迟的信号进行接扩，最后进行合并。）进行接收，以此达到分集目的。</p><p>另一个例子是OFDM（Orthogonal Frequency Division Multiplexing 正交频分复用），OFDM主要思想是：将信道分成若干<strong>正交子信道</strong>，将高速数据信号转换成<strong>并行</strong>的<strong>低速子数据流</strong>，调制到在每个<strong>子信道上进行传输</strong>。正交信号可以通过在接收端采用相关技术来分开，这样可以减少子信道之间的相互干扰(ISI) 。<strong>每个子信道上的信号带宽小于信道的相干带宽（Coherence Bandwidth），因此每个子信道上可以看成平坦衰落（flat fading）</strong>，从而可以消除码间串扰，而且由于每个子信道的带宽仅仅是原信道带宽的一小部分，信道均衡变得相对容易。</p><p>它的调制和解调是分别基于IFFT和FFT来实现的，是实现复杂度最低、应用最广的一种多载波传输方案。相较于频分复用（单纯使用频率划分子信道，而不正交），它可以实现更高的频谱利用率。下图是FDM的频谱和OFDM的频谱，可以看到，OFDM更为密集。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240410104225740.png" alt="image-20240410104225740"></p><h2 id="无线通信中的复用技术"><a href="#无线通信中的复用技术" class="headerlink" title="无线通信中的复用技术"></a>无线通信中的复用技术</h2><p>分集技术是将一个一个信号分散到不同的子信道传输，来提高该信号的传输质量。而复用技术是使用不同的子信道传输不同的信号，目的是提高频谱利用效率。</p><p>复用技术主要在一下四个方向上进行复用</p><ul><li>时间 （时分复用 Time-Division Multiplexing TDM）</li><li>频率 （频分复用 Frequency-Division Multiplexing FDM）</li><li>编码 （码分复用 Code-Division Multiplexing CDM）</li><li>空间 （空分服用 Space-Division Multiplexing SDM）</li></ul><h3 id="频分复用（FDM）"><a href="#频分复用（FDM）" class="headerlink" title="频分复用（FDM）"></a>频分复用（FDM）</h3><p>描述：频分复用将信道在频域上划分成不同子信道，每一个信号占用一个频率。</p><p><strong>优点：</strong></p><ol><li>不需要动态协调，因为一个信号固定使用一个子频，该频永远属于该信号。</li><li>数字信号和模拟信号都可使用</li></ol><p><strong>缺点：</strong></p><ol><li>信道利用率低：不同信号之间的流量可能分布不均匀，造成部分子信道闲置，此时会浪费带宽。</li><li>灵活性差：每一个信号的频率固定。</li><li>频率间需要设置过渡带，不同频率需要有一个小间隔，造成资源浪费</li></ol><h3 id="时分复用（TDM）"><a href="#时分复用（TDM）" class="headerlink" title="时分复用（TDM）"></a>时分复用（TDM）</h3><p>描述：不同时间段发不同的信号，单一信号可占用介质中所有的可用带宽。</p><p><strong>优点：</strong></p><ol><li>不存在频间干扰：介质中只同时存在一个频率，因此不会有FDM中频率间相互干扰的问题。</li><li>对多用户场景，它有很高的吞吐量。</li></ol><p><strong>缺点：</strong></p><ol><li>需要非常精确的同步：需要从不同时间信道中分离出来自己的信号，因此对时间同步的要求非常高。</li></ol><h3 id="时频复用-（Time-and-Frequency-Multiplex）"><a href="#时频复用-（Time-and-Frequency-Multiplex）" class="headerlink" title="时频复用 （Time and Frequency Multiplex）"></a>时频复用 （Time and Frequency Multiplex）</h3><p>描述：将时分复用和频分复用结合起来。如下图所示，下图k1-k6被成为资源块，每一个资源块可以划分给一个用户。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240410112230934.png" alt="image-20240410112230934"></p><p>优点</p><ol><li>对于频率选择性干扰有一定保护效果。因为频率选择性干扰只在一个频率上持续。</li></ol><p>缺点：</p><ol><li>在时间和频率上都需要设置间隔带，会造成资源额外开销</li></ol><h3 id="码分复用-（CDM）"><a href="#码分复用-（CDM）" class="headerlink" title="码分复用 （CDM）"></a>码分复用 （CDM）</h3><p>描述：码分复用使得每一个子信道有自己的一段编码，通过该编码分离子信道信号。一个例子是直序扩频。在该复用模式下，用户可在同一时间使用同一频谱。</p><p><strong>优点：</strong></p><ol><li>频谱利用率高</li><li>不需要动态协调</li><li>抗干扰能力强</li></ol><p><strong>缺点：</strong></p><ol><li>需要在信号检测上引入更复杂的设计。</li></ol><h3 id="空分复用-（SDM）"><a href="#空分复用-（SDM）" class="headerlink" title="空分复用 （SDM）"></a>空分复用 （SDM）</h3><p>描述：空分复用使用空间划分频谱资源，在一定区域内，用户使用的频谱可与另一不互相影响区域重合。</p><p>空分复用可以非常有效地利用频谱，因此几乎所有无线系统中都在使用。</p><h2 id="数字调制技术"><a href="#数字调制技术" class="headerlink" title="数字调制技术"></a>数字调制技术</h2><p><strong>为什么需要调制：</strong>信息无法被原样传递</p><p><strong>什么是调制</strong>：将信息包含进电磁波内</p><p><strong>如何调制</strong>：对载波的一些参数进行改变，让其承载信息</p><h3 id="ASK"><a href="#ASK" class="headerlink" title="ASK"></a>ASK</h3><p>使用振幅调制二进制序列，如下图所示。</p><p><img src="C:\Users\17997\AppData\Roaming\Typora\typora-user-images\image-20240623201850496.png" alt="image-20240623201850496"></p><h3 id="FSK"><a href="#FSK" class="headerlink" title="FSK"></a>FSK</h3><p>使用不同的频率调制二进制序列。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240623202032709.png" alt="image-20240623202032709"></p><h3 id="PSK"><a href="#PSK" class="headerlink" title="PSK"></a>PSK</h3><p>使用不同相位调制二进制序列。如下图所示。如果是BPSK，则相位差异为$\pi$，QPSK则为$\frac{\pi}{2}$</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240623202236165.png" alt="image-20240623202236165"></p><h3 id="Quadrature-Amplitude-Modulation-QAM"><a href="#Quadrature-Amplitude-Modulation-QAM" class="headerlink" title="Quadrature Amplitude Modulation QAM"></a>Quadrature Amplitude Modulation QAM</h3><p>QAM是PSK和ASK的结合。使用星座图（constellation points）来映射二进制序列。例如下图是16-QAM（4bit/symbol）。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240417105955875.png" alt="QAM"></p><hr><h1 id="CH3-基本技术-Part2"><a href="#CH3-基本技术-Part2" class="headerlink" title="CH3-基本技术-Part2"></a>CH3-基本技术-Part2</h1><h2 id="扩频通信"><a href="#扩频通信" class="headerlink" title="扩频通信"></a>扩频通信</h2><div class="note info flat"><p>如果想更深入学习，可以参考<a href="https://www.kaysonz.top/posts/76361032">扩频通信简介 | 風 (kaysonz.top)</a></p></div><h3 id="扩频通信的优势："><a href="#扩频通信的优势：" class="headerlink" title="扩频通信的优势："></a>扩频通信的优势：</h3><ul><li>符号的频谱在传输过程中经常受到窄带信号的干扰，导致接收端无法正确识别符号。原本窄带信号频谱被扩宽之后，再接收端解扩，具有更好的抗窄带噪声的特性</li><li>扩频之后频谱隐藏在噪声中，难以监听</li><li>利用扩频码可以进行码分复用</li><li>良好的抗多径效应（Rake分集接收）</li></ul><p><strong>凡是看到码分的，就是用了扩频技术的。例如重庆邮电大学的第一颗TD-SCDMA3G芯片</strong></p><h3 id="直序扩频（Direct-Sequency-Spreading-Spectrum-DSSS）"><a href="#直序扩频（Direct-Sequency-Spreading-Spectrum-DSSS）" class="headerlink" title="直序扩频（Direct Sequency Spreading Spectrum DSSS）"></a>直序扩频（Direct Sequency Spreading Spectrum DSSS）</h3><p><strong>是什么：</strong>将原始信号与频率更高的伪随机序列（pseudo-random number ）或者叫扩频序列（chipping sequence）进行异或运算，以此将信号的频宽提高。在接收端再使用同样的伪随机序列异或运算解扩。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240115000300778.png" alt="img"></p><p><strong>优势：</strong></p><ol><li>减少频率选择性干扰</li><li>使用扩频序列（chipping sequence），提供了码分复用的能力，基站可以使用同一频率</li><li>多个基站可以检测和恢复信号(软切换增益 soft handover gain)</li></ol><p><strong>劣势：</strong></p><ol><li>需要精确的功率控制，因为不同扩频码的信号必须在大约相同的功率水平进行检测。</li></ol><p><strong>DSSS中的Rake Receiver（还在用传统接收机？）</strong>：DSSS抗多径效应的原理是选择信号功率最强的一个解扩，而其他路径分量相当与进行了扩频。这恰好就像是在做分集接收。Rake接收器就是将这个过程认为是分集来处理。Rake接收机假设每个多径分量间隔一定时延，因此有多条接收之路，分别对不同时延迟的信号进行接扩，最后进行合并。理想来说，瑞刻接收机使用MRC的方式进行合并，但具体的方式需要根据特定场景优化。</p><h3 id="跳频扩频（Frequency-Hopping-Spreading-Spectrum-FHSS）"><a href="#跳频扩频（Frequency-Hopping-Spreading-Spectrum-FHSS）" class="headerlink" title="跳频扩频（Frequency Hopping Spreading Spectrum FHSS）"></a>跳频扩频（Frequency Hopping Spreading Spectrum FHSS）</h3><p>传统的无线通信系统，发射机和接收机工作在单次通信过程中，载频一般是保持不变；例如通信频率是900MHz, 那么通信将一直使用这个频率进行。跳频（Frequency Hopping)系统则在单次通信中，载频在多个频率上跳变。如901MHz, 902MHz etc.</p><p>跳频通信通过伪随机序列（pseudo random number）确定跳频图案，即信号频率跳变的规律。然后通信频率按照跳频图案变化，如下图所示。</p><p><strong>跳频可以细分为：</strong></p><ul><li><strong>快跳频（Fast Hopping）</strong>：跳频周期小于符号周期(是Ts的约数)，一个符号传输需要多个频率</li><li><strong>慢跳频（Slow Hopping）</strong>：跳频周期大于符号周期(是Ts的倍数)，一个频率传输多个符号</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114233026923.png" alt="FHSS"></p><p><strong>优势：</strong></p><ol><li>频率选择性衰落的影响在众多频率跳变中被削弱</li><li>提供频率分集（Frequency Diversity）</li><li>实现简单</li><li>任何时候都只使用一小部分频谱（即可以用不同跳频图案实现码分复用）</li><li>比起DSSS更易被探测</li></ol><p><strong>劣势：</strong></p><ol><li>鲁棒性（robust）不如DSSS</li></ol><h3 id="跳时扩频（Time-Hopping-Spreading-Spectrum）"><a href="#跳时扩频（Time-Hopping-Spreading-Spectrum）" class="headerlink" title="跳时扩频（Time-Hopping Spreading Spectrum）"></a>跳时扩频（Time-Hopping Spreading Spectrum）</h3><p>与跳频相似，是使发射信号在时间轴上跳变。首先把时间轴分成许多时片。在一帧内哪个时片发射信号由扩频码序列去进行控制，主要用于时分多址（TDMA）通信。</p><p><strong>优点：</strong>实现简单，能效好</p><p><strong>缺点：</strong>同步困难</p><h2 id="多址技术（Multiple-Access）"><a href="#多址技术（Multiple-Access）" class="headerlink" title="多址技术（Multiple Access）"></a>多址技术（Multiple Access）</h2><p>多址接入是位于MAC层，物理层之上的一种实现点到多点的通信的技术。多址和复用的区别在于，多址技术是要根据不同的“址”来区分用户；复用是要给用户一个很好的利用公共资源的方式。复用针对资源，多址针对用户。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240419113836159.png" alt="image-20240419113836159" style="zoom:50%;" /></p><p>多址可以分为竞争协议和非竞争协议，如上图。</p><p>竞争：网络中的节点在网络中的地位是等同的，各节点通过竞争获得信道的使用权，典型的协议是Aloha。</p><p>非竞争：所有设备依据某一规则，编排发信顺序。有统一调度。这里面又可以分为：</p><ul><li>Dynamic allocation（动态分配）：有一中心节点根据当前状况，动态分配信道资源。</li><li>Static allocation（静态分配）：根据某种恒定的规则发信。例如前面提到的CDMA，SDMA等。</li></ul><p>多址和复用技术本质上是用的同一个物理技术来实现，因此这里只简单列举优缺点</p><h3 id="FDMA"><a href="#FDMA" class="headerlink" title="FDMA"></a>FDMA</h3><p><strong>优点：</strong></p><ol><li>低复杂度（例如：比TDMA或CDMA更容易同步）</li><li>所需的bit开销较少（ Fewer bits needed for overhead purposes）</li></ol><p><strong>缺点：</strong></p><ol><li>未使用的信道频谱会被闲置（stay idle），浪费资源</li><li>需要比较严格的滤波来降低不同信道之间的干扰</li></ol><h3 id="TDMA"><a href="#TDMA" class="headerlink" title="TDMA"></a>TDMA</h3><p><strong>优点：</strong></p><ol><li>低功耗</li><li>无需双工器即可实现双工（rx和tx在不同时隙）</li></ol><p><strong>缺点：</strong></p><ol><li>burst+guard slots 之间需要同步（带来了复杂性和比FDMA更大的开销)</li><li>通常需要自适应均衡，因为与 FDMA 相比，传输速率通常非常高</li></ol><h3 id="CDMA"><a href="#CDMA" class="headerlink" title="CDMA"></a>CDMA</h3><p>所有终端都可以使用相同频率发送，并占用信道的整个带宽。发送和接收方都有一个唯一的扩频码（spreading code），通过扩频码来对信号进行扩频和解扩。只有当扩频码相符合时，信号的频谱才能被恢复。这个扩频码就是码反复用的“码”。</p><p>出现缘由：当服务数量从纯语音增加到语音+数据时，FDMA/TDMA模式缺乏对稀缺频谱的高效利用。</p><p><strong>DS（Direct Sequence）-CDMA优点：</strong></p><ol><li>所有终端可以使用同一个频率而无需同步</li><li>可以根据用户数量调整扩频码，最大用户数量不定。提高了资源利用率。</li><li>更简单的载波生成（无需进行相移、时分等）</li></ol><p><strong>DS（Direct Sequence）-CDMA缺点：</strong></p><ol><li>需要功率控制来保证所有信号以相同强度到达接收器，否则较远用户可能被较近用户屏蔽（blocked），这被称为 <strong>near-far problem</strong></li><li>难以获取和维持码片时序（chip timing），这导致更复杂的接收器</li><li>自拥塞（self-jamming）：不同用户的扩频序列可能不完全正交（由于多径和扩频序列不同步导致），从而导致解扩问题</li></ol><p><strong>WCDMA</strong></p><p>WCDMA是一种频宽比较宽的DS-CDMA（典型值5MHz）。UMTS（Universal Mobile Telecommunications System）就是基于WCDMA提供multiple access机制。</p><p>如今，WCDMA也指UMTS的一组物理层规范(如编码类型、双工方案、检测/解调特性等)</p><p>WCDMA的DS-CDMA使用扩频码扩频（在WCDMA内第一次扩频的叫信道化码）的基础上，还添加扰码（Scrambling codes）。</p><ol><li>Channelization Codes（也称short code）<ul><li>长度取决于Spreading Factor</li><li>用于来自单一源的信道分离。上行链路上将控制通道（control channel）和专用通道（dedicated channels）分离；下行链路将一个cell/sector内的不同用户分离</li><li>因为不同cell内的不同用户可能有同样的short code，因此需要加扰码来区分cell</li></ul></li><li>Scrambling codes （也称long code）<ul><li>非常长（38400 chips）</li><li>上行链路：用于分离不同手机</li><li>下行链路：用于分离不同cell/sectors</li></ul></li></ol><h3 id="SDMA"><a href="#SDMA" class="headerlink" title="SDMA"></a>SDMA</h3><p>旨在将空间分割为cell/sectors，形成蜂窝结构（cell structure），在一个cell/sector内，只有一个对应的终端。</p><p><strong>优点：</strong></p><ol><li>简单</li><li>增加系统容量</li></ol><p><strong>缺点：</strong></p><ol><li>不灵活，需要定向天线，而天线通常是固定的</li></ol><p>SDMA通常需要与TDMA，FDMA，CDMA一起联合使用。例如WCDMA里面的扰码+信道化码实现SDMA</p><h3 id="OFDMA"><a href="#OFDMA" class="headerlink" title="OFDMA"></a>OFDMA</h3><p>前面在频率分集里面介绍过OFDM调制。在OFDM下，可以将子信道使用正交子载波调制，从而实现正交频分复用（Orthogonal Frequency Division Multiplex）。这里同样可以用于正交频分多址（Orthogonal Frequency Division Multiplexing）</p><p><strong>导频子载波（Pilot Subcarrier）</strong></p><p>导频信号是指不携带信息，双方已知的数据的一个信号。因为所有子载波会产生一定的幅度和相位偏移，在信号中插入导频是提供参考，来做接收信号时候的信道估计+补偿。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240624103747667.png" alt="image-20240624103747667" style="zoom:50%;" /></p><h1 id="CH4-Part1-2G"><a href="#CH4-Part1-2G" class="headerlink" title="CH4-Part1-2G"></a>CH4-Part1-2G</h1><h2 id="蜂窝（Cellular）的概念"><a href="#蜂窝（Cellular）的概念" class="headerlink" title="蜂窝（Cellular）的概念"></a>蜂窝（Cellular）的概念</h2><h3 id="蜂窝的介绍"><a href="#蜂窝的介绍" class="headerlink" title="蜂窝的介绍"></a>蜂窝的介绍</h3><p><strong>什么是蜂窝：</strong>将无线电网络的功能（the functionality of radio network ）划分为几何上更小的区域，称为cells。无线电信号随着距离而衰减，因此相同的资源可以在一定区域外再次利用（resource reuse）。</p><p><strong>蜂窝的动力：</strong>有限的频谱资源（limited radio spectrum.）</p><p><strong>蜂窝的优势：</strong></p><ol><li><strong>更高的容量（Higher capacity）：</strong>可以更有效地利用资源，提高系统容量</li><li><strong>节省传输功率（Less Transmission power）：</strong>蜂窝的区域小，减少了需要覆盖尺寸。同时也减少了对基站传输放大器的要求。这同时也给移动终端带来了更好的电池寿命。</li><li><strong>被局限的干扰（Localized interface）：</strong>由于一个cell服务区域小，干扰也被局限在较小区域内</li><li><strong>鲁棒性好（Robustness）</strong>：如果一个cell坏掉了，cell的重叠保证了移动终端可以通过其他基站接入网络</li><li><strong>部署中技术难度小（Less technological challenges in deployment）：</strong>部署中遇到的主要问题是最小化系统的实施和运营开支（operational expenses）。因为技术上想要改进容量需要更小的cell面积带来更多的复用。</li></ol><p><strong>蜂窝的劣势</strong></p><ol><li><strong>需要大规模基础设施（Massive infrastructure）:</strong>如果需要更多的容量，基站的数量也会增(位置寄存器、交换机、管理服务器等)。</li><li><strong>更复杂的移动性管理（More complex mobility management）：</strong>必须提供整个网络的无缝连接，即，需要切换（Handover）。Handover的管理可能变得很复杂。</li><li><strong>资源规划和管理（Resource planning and management）：</strong>需要更严格（tight）的资源规划策略，例如对时隙（slots）和频率。</li></ol><h3 id="系统容量"><a href="#系统容量" class="headerlink" title="系统容量"></a>系统容量</h3><p>在蜂窝网络中，对每一个Cell分配一个频率，使用相同频率的cell被称为co-channel cells，使用不同频率的被称为adjacent cells。</p><p>使用不同频率的挨在一起，构成一个大的板块，这样大的板块重复出现，如下图所示。这样一个大的板块就被称为一簇（cluster）。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240624112844832.png" alt="image-20240624112844832"></p><p>使用两个相同频率的cell的距离被称作复用距离（reuse distance），记作 $D$。</p><p>一个簇的内包含几个cell被称作簇大小（cluster size），记作 $N$。</p><p>如果一个大型蜂窝网络一共有S条全双工信道，可以给一个cell分配k条信道。那么S，k和簇大小N有如下关系：</p><script type="math/tex; mode=display">S=kN</script><p>如果一个cell被重复用了M次，那么系统的总容量就是：</p><script type="math/tex; mode=display">C=MkN=MS</script><p><em>举个例子：给定总带宽为10MHz，其中每个信道占用200KHz频带，计算系统使用时每个小区可用的信道数(a) 4-cell cluster，(b) 7-cell cluster，(c) 12-cell cluster。</em></p><p>(a) $S=\frac{10M}{200K}=50$，$k=50/4\approx12$</p><p>(b)$k=50/7=7$</p><p>(c)$k=50/12=4$</p><h3 id="蜂窝网络内的SIR"><a href="#蜂窝网络内的SIR" class="headerlink" title="蜂窝网络内的SIR"></a>蜂窝网络内的SIR</h3><p>SIR是指的signal interference ratio， 其中interference指相邻信道带来的干扰。如果所有cell发送功率相等，则通信到干扰与发射功率无关，仅与cell半径R和复用距离D有关。</p><p>假设$I_j$是从第$j$个co-channel cell收到的干扰，总共有J个co-channel cell，则SIR可以记为：</p><script type="math/tex; mode=display">SIR=\frac{S}{I}=\frac{S}{\sum_{j=0}^{J}I_j}</script><p>用传输功率+衰减来表达，记本cell基站（即S对应的基站）到终端的距离为$d_0$，记干扰基站到终端距离为$d_j$，记信号强度随距离衰减指数为n，有：</p><script type="math/tex; mode=display">SIR=\frac{Pd_0^{-n}}{\sum_{j=0}^{J}Pd_j^{-n}}=\frac{d_0^{-n}}{\sum_{j=0}^{J}d_j^{-n}}</script><p>根据六边形蜂窝的距离计算公式，这个公式最终可以被化简为：<strong>(单位非dB!,dB需要转换!)</strong></p><script type="math/tex; mode=display">SIR=\frac{(\sqrt{3N})^n}{6}</script><p>其中在自由空间下$n=2$，在密集城市环境下$n=4$</p><p><em>举个例子：在路径损耗因子 n=4 的环境中，实现 SIR 高于 18 dB 的最小集群大小是多少？</em></p><script type="math/tex; mode=display">SIR=\frac{(\sqrt{3N})^4}{6}>10^{1.8}\to N=6.48=7</script><h3 id="Handover"><a href="#Handover" class="headerlink" title="Handover"></a>Handover</h3><p>Handover是指一个基站决定将用于连接至一个终端的所有无线电资源交移给另一个基站（(all radio resources of a connection are  handed to another base station）。</p><p>在蜂窝网络中，Handover是移动性（Mobility）的保证。</p><p><strong>Handover过程中，需要考虑：</strong></p><ul><li>以什么方式触发Handover（power level, quality level, other reasons）</li><li>阈值（Thresholds）是多少</li><li>Target cell如何选择</li></ul><p><strong>切换过程如下：</strong></p><ol><li>终端移动到Cell边界，呼号信号（Call signal）下降到最小阈值，此时终端通知网络（network）。</li><li>网络在相邻基站上找到一个未使用的信道，并将其信息发送给终端</li><li>终端切换到新的信道</li></ol><p>这当中可能遇到：</p><ul><li>相邻基站满载(full capacity)：连接会被中断，因为没有可用的信道提供切换</li><li>Handover期间连接可能丢失：如果在第一个基站将它交移之前相邻基站没有对通信（call）进行锁定，则会丢失。</li></ul><p><strong>软切换的概念和优点</strong></p><p>如果是先断开和原基站的连接，再建立和新基站的连接，则称为硬切换。软切换类似于硬交接，只不过第一个基站不会先断开连接，而是等第二个基站确认已经连接之后再断开。</p><p>它带来的优点有：</p><ul><li>提升cell边缘的性能</li><li>通话中掉线数量减少</li></ul><h2 id="GSM（Global-System-for-Mobile-Communication）"><a href="#GSM（Global-System-for-Mobile-Communication）" class="headerlink" title="GSM（Global System for Mobile Communication）"></a>GSM（Global System for Mobile Communication）</h2><p>GSM规定网络架构如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240624131044840.png" alt="image-20240624131044840" style="zoom:80%;" /></p><ul><li><strong>移动台/移动用户（Mobile Station MS）：</strong>用户使用的设备。包括移动设备ME和SIM卡，SIM卡存储了认证用户身份所需的所有信息以及与安全保密有关的重要信息。</li><li><strong>基站收发信机（base transceiver station BTS）:</strong>基站收发信机，负责无线信号的收发。</li><li><strong>基站控制器 (base station controller BSC)：</strong>处理所有的与无线信号有关的工作：小区的切换、无线资源管理等。</li><li><strong>转码器和速率适配单元 (transcoder and rate adaption unit TRAU)：</strong>执行转码和速率适配功能，它支持不同编解码器之间的语音通信，从而实现互操作性。</li><li><strong>移动交换中心(mobile switching center MSC)：</strong>它完成最基本的交换功能。能自动无线登记进程跟踪本系统内所有的无线用户，并能不断地监视与之相连的所有蜂窝基站的运行情况。</li><li><strong>归属位置寄存器(home location register HLR)：</strong>当用户选择一个网络运营商并购买了SIM卡之后，其相关的很多信息就被录入了HLR系统当中。HLR中记录了用户所有的原始开户信息，且不会因为用户从北京跑到了上海而将其号码和签约信息进行删除。</li><li><strong>拜访位置寄存器(visitor location register VLR)：</strong>保存用户的动态信息和状态信息，以及从HLR下载的用户的签约信息。例如当你到上海之后，手机会自动向上海的VLR发起位置更新（登记），上海的VLR会将你现在的位置报告到北京的HLR。当他人呼你时，交换机首先向HLR查询你现在所在的位置，然后就可以呼到你了。</li><li><strong>设备标识寄存器（Equipment Identity Register EIR）</strong>：手机用户发起呼叫，MSC和VLR向手机请求IMEI，并把它发送给EIR，EIR将收到的IMEI与白、黑、灰三种表进行比较，把结果发送给MSC/VLR，以便MSC/VLR决定是否允许该移动台设备进入网络。</li><li><strong>鉴权中心（Authentication Center AC）：</strong>负责用户的身份验证和加密所有无线通讯(语音、短信等)</li><li><strong>短信服务中心（Short Message Service Center）和语音邮件系统（Voice Mail System）：</strong>分别负责短信的存储和转发、语音邮件服务。</li><li><strong>公共交换电话网络(public switched telephone network PSTN)</strong>：一种以模拟技术为基础的电路交换网络，出现在GSM内是用于连接GSM网络与传统的固定电话网络。</li></ul><p>这个系统可以被分为数个子系统：</p><p><strong>RSS(radio system)</strong>：包含MS、BTS、BSC（BTS和BSC可以总称为BaseStation Subsystem，BSS）和TRAU。负责无线通信和信号处理。</p><p><strong>NSS(network and switching subsystem)：</strong>包含MSC、HLR、VLR、 AC、EIR、SMSC、VMS，负责交换、移动性管理、与其他网络的互连、系统控制等。</p><p><strong>OSS(operation subsystem)</strong>：如上图</p><hr><h1 id="CH4-Part2-3G-amp-4G"><a href="#CH4-Part2-3G-amp-4G" class="headerlink" title="CH4-Part2-3G&amp;4G"></a>CH4-Part2-3G&amp;4G</h1><h2 id="UMTS（Universal-Mobile-Telecommunications-System）"><a href="#UMTS（Universal-Mobile-Telecommunications-System）" class="headerlink" title="UMTS（Universal Mobile Telecommunications System）"></a>UMTS（Universal Mobile Telecommunications System）</h2><p>UMTS最初的规范是”Release 99”版本，下面介绍的都是”Release 99”。</p><h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><p>UMTS系统分为多个域，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240624134904234.png" alt="image-20240624134904234"></p><p><strong>用户设备域（User Equipment Domain）</strong></p><ul><li><strong>Universal Subscriber Identity Module (USIM)</strong>：模块位于移动设备SIM卡内。负责用户鉴权（authentication）和通信加密（encryption）。</li><li><strong>Mobile Equipment Domain</strong>：用于发射无线电波、建立和用户的连接。ME（Mobile Equipment）里面包含TE（Terminal Equipment）和MT（Mobile Terminal）</li></ul><p><strong>基础设施域(Infrastructure Domain)</strong></p><ul><li><p><strong>Access Network Domain（UTRAN）：</strong>提供接入网的相关功能，管理接入网资源，为用户提供访问核心网域机制。</p></li><li><p><strong>Core Network Domain：</strong>由为网络功能和电信服务提供支持的设备组成：即管理用户位置信息、控制网络功能</p><ul><li><p><strong>Serving Network Domain：</strong></p><ul><li><p>服务网络是核心网络的一部分，负责处理用户设备（UE）的连接和服务。</p></li><li><p>Represent the core network functions that are local to user’s access point, thus, their location changes when the user moves. (Dependent on user location)</p></li><li><p>Responsible for routing calls and transport user data/information from source to destination</p></li></ul></li><li><p><strong>Home Network Domain</strong>：</p><ul><li>Location and access network independent functions</li><li>The USIM is related by subscription to the home network domain</li><li>Home network domain contains permanently user specific data and is responsible for management of subscription information</li><li>May also handle some services, potentially not offered by the serving network domain.</li></ul></li><li><p><strong>Transit Network Domain</strong>：</p><ul><li>Domain between Serving Network and remote party</li><li>If, for a given call, the remote party is located inside the same network as the originating User Equipment (UE), then no particular instance of the transit domain is activate</li></ul></li></ul></li></ul><h3 id="UTRAN"><a href="#UTRAN" class="headerlink" title="UTRAN"></a>UTRAN</h3><p>在3G网络中，接入网部分叫做UTRAN（UMTS Terrestrial Radio Access Network，UMTS陆地无线接入网）</p><ol><li><strong>接纳控制（Admission Control）</strong>：用于有选择地将呼叫接入系统，以最小化呼叫丢失和呼叫阻塞。</li><li><strong>拥塞控制（Congestion Control）</strong>：如果某个拥塞阈值被长时间超过，将标记单元为拥塞状态。</li><li><strong>系统信息广播（System Information Broadcasting）</strong>：用于维护用户设备（UE）与UTRAN之间的无线连接，并控制UTRAN。</li><li><strong>无线信道加密（Radio Channel Encryption）</strong>：例如，用于保护用户流量和敏感信令数据免受窃听。</li><li><strong>切换（Handover）</strong>：将用户连接从一个无线信道转移到另一个信道。</li><li><strong>服务无线网络子系统（SRNS）的移动/重定位</strong>：从服务无线网络子系统（SRNS）控制权转移到另一个无线网络子系统（RNS）。</li><li><strong>无线网络配置/规划</strong></li><li><strong>信道质量测量</strong>：用于Handover</li><li><strong>宏多样性（Macro diversity）</strong>：指的是多个无线链路同时处于活动状态，例如软切换（soft handover）。</li><li><strong>无线资源控制（Radio Resource Control，RRC）</strong>：执行连接建立和释放、系统信息广播、无线承载建立/重配置和释放、RRC连接移动过程、寻呼通知和释放、外环功率控制等功能。</li><li><strong>无线接口上的数据传输</strong></li><li><strong>外环功率控制（FDD和TDD）</strong>：UE（用户设备）能够将其输出功率设置为特定值。在UE接入网络时，用于设置初始上行和下行传输功率。</li><li><strong>内环功率控制（也称为快速闭环功率控制）</strong>：在上行链路中，UE发射机根据接收到的一个或多个下行传输功率控制命令来调整其输出功率，以保持所需的上行信号干扰比（SIR）。</li><li><strong>信道编码</strong>：提供减轻由无线信道传播引起的错误的机制。</li><li><strong>接入控制</strong>：提供medium access control scheme</li></ol><h3 id="UMTS信道"><a href="#UMTS信道" class="headerlink" title="UMTS信道"></a>UMTS信道</h3><p>UMTS将信道定义为三种类型：</p><ul><li><strong>逻辑信道(Logical channel)：</strong>定义所传输数据的类型。（控制信息，业务信息）</li><li>传输信道（Transport Channel）：定义物理层用何种方式传输数据 以及传输哪些数据</li><li>物理信道(Physical channel)：真正的射频信道，具有射频物理特征</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240624151516163.png" alt="image-20240624151516163" style="zoom:50%;" /></p><h3 id="UMTS的三种切换类型"><a href="#UMTS的三种切换类型" class="headerlink" title="UMTS的三种切换类型"></a>UMTS的三种切换类型</h3><ol><li><strong>Intra RNC 软切换：</strong>不同RNC下提供软切换。如下图1，SRNC(Service RNC) 是当前服务.DRNC(Drift RNC) 是候选RNC，是即将切换过去的</li><li><strong>intra Node B 软切换：</strong>在同一个RNC控制下，在不同基站间交移提供软切换</li><li><strong>硬切换：</strong>在不同核心网之间的切换，是硬切换。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240624145401847.png" alt="image-20240624145401847" style="zoom:67%;" /></p><h3 id="HSDPA"><a href="#HSDPA" class="headerlink" title="HSDPA"></a>HSDPA</h3><p>HSDPA（高速下行分组接入，High-Speed Downlink Packet Access）旨在增强第三代（3G）移动网络的数据传输能力。</p><p><strong>它的主要特点是：</strong></p><ol><li>自适应信道编码（Adaptive Modulation and Coding），有QPSK和16QAM</li><li>混合自动重复请求(Hybrid Automatic Repeat Request HARQ)</li><li>基站（Node B）快速分组调度(Fast packet scheduling)</li><li>短帧大小（Short frame size）</li></ol><p><strong>优点：</strong></p><ol><li>更高的处理效率</li><li>由更快的纠错带来的更低延迟</li><li>更高效的资源管理</li><li>对环境有自适应能力</li><li>Handover失败率更低</li></ol><h2 id="LTE（long-term-evolution）"><a href="#LTE（long-term-evolution）" class="headerlink" title="LTE（long term evolution）"></a>LTE（long term evolution）</h2><p>LTE 是电信中用于手机及数据终端的高速无线通信标准.</p><ul><li>它在下行链路中使用OFDM</li><li>在上行链路中使用SC-FDMA（Single Carrier FDMA），利用单载波调制和正交频分复用，在发射机中使用 DFT 扩频，在接收机中使用频域均衡</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 移动通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电信传输理论-CH3-传输介质</title>
      <link href="/posts/9b43b6f.html"/>
      <url>/posts/9b43b6f.html</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>（听 Baoninghai 讲讲故事的小节）</p><ul><li>如同Overview中介绍，用于信息传输的介质可以分为引导式(guided)和非引导式(unguided, 通常其实就是无线)。</li><li>双绞线一直是传统通信的主力，但是双绞线对长距离高频信号的传递不行。同轴线可以弥补这个缺点，但是造价较为高昂。现在价格更低又对大容量长距离传输更友好的光纤占据了很大的市场，曾经广泛使用的双绞线和同轴线逐渐被光纤取代了。现在的趋势是将光纤向用户侧衍伸。</li><li>光纤因为自己材质是二氧化硅，因此对外部保护要求较高，且不能大幅度弯曲。现在有了新的材料，类似于“塑料”，解决了这个问题。因此现在光线入户得到了进一步推进。</li><li>光纤还有一些独特的优势，一是成本低；二是要窃听光纤内的内容，必须要在光纤接头处作出特殊处理，无法直接并联一根线进行窃听。</li></ul><h1 id="频段和其缩写"><a href="#频段和其缩写" class="headerlink" title="频段和其缩写"></a>频段和其缩写</h1><div class="note info flat"><p>这一页不作具体的要求，只需要大家熟悉</p></div><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240321172556582.png" alt="image-20240321172556582" style="zoom: 50%;" /></p><p>其中，几个比较重要的是：</p><ul><li>语音通信的频带范围：300-3KHz</li><li>双绞线传输范围: 小于$10^8Hz$，这也就是为什么说双绞线对高频信号传输不友好</li><li>光纤和可见光都在$10^{14}%$至$10^{15}$，可见光通信（例如日光灯）现在也有很多人研究，数据下行较为容易实现，但是数据上行困难。</li></ul><h1 id="传输介质的分类"><a href="#传输介质的分类" class="headerlink" title="传输介质的分类"></a>传输介质的分类</h1><p>引导式传输介质一般都指有线传输信道，非引导式一般是无线传输信道。一般来说：</p><ul><li>有线传输信道各项参数不会发生较大变化，因此认为有限传输是<strong>恒参信道</strong>。</li><li>而无线传输会受到环境，路径等影响，因此是<strong>非恒参信道</strong></li></ul><h1 id="引导式-有线-传输介质"><a href="#引导式-有线-传输介质" class="headerlink" title="引导式(有线)传输介质"></a>引导式(有线)传输介质</h1><div class="table-container"><table><thead><tr><th></th><th>频率范围</th><th>衰落率典型值</th><th>延迟典型值</th><th>理论传输最远距离</th></tr></thead><tbody><tr><td>双绞线</td><td>0-3.5Khz</td><td>0.2dB/Km@1Khz</td><td>50us/km</td><td>5km</td></tr><tr><td>双绞线（多条）</td><td>0-1Mhz</td><td>0.7dB/Km@1Khz</td><td>5us/km</td><td>5km</td></tr><tr><td>同轴线</td><td>0-500Mhz</td><td>7dB/Km@10Mhz</td><td>4us/km</td><td>1~9km</td></tr><tr><td>光纤</td><td>186-370Thz</td><td>0.2~0.5dB/Km</td><td>5us/km</td><td>40km</td></tr></tbody></table></div><p><em>双绞线对语音通信传输距离，标准的上限是5Km。PPT上的表格写的是2km，这里与国内实际情况有出入。</em></p><h2 id="双绞线-（Twisted-pair）"><a href="#双绞线-（Twisted-pair）" class="headerlink" title="双绞线 （Twisted pair）"></a>双绞线 （Twisted pair）</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240321174201447.png" alt="image-20240321174201447"></p><p><strong>双绞线</strong>：双绞线由两条铜线拧在一起。一条双绞线（两条铜线）构成一个完整的通信回路。两条线拧在一起是为了让内部传输的信号尽可能正交（完全正交就没法向前延伸了），<strong>来减少互相的串扰</strong>。因此绕在一起的“斜率”其实是经过特别计算的。</p><p><strong>串扰产生的原因</strong>：两条相邻的并行的线产生了互相电磁干扰其实就是串扰产生的原因。最初的时候，语音信号是模拟信号，因此产生传绕时你可以听到别人说话的声音。</p><p><strong>用户环路（subscriber loop）:</strong>在局部电话系统中（例如政府），会有一个内部的交换机，内部电话通过双绞线连接至内部交换机，这些线路被称为“用户环路”。（现在也用不太上了，可以不用记）</p><p><strong>双绞线的优缺点：</strong></p><ul><li>优：便宜</li><li>优：可弯折性好</li><li>缺：距离上受到限制</li><li>缺：对干扰特别敏感（举个例子，家庭网络布双绞线时，强电和弱电需要分开布线，以此减少干扰）</li><li>缺：频率受到限制（主要的限制）</li></ul><p>从下图可以看出，在几种典型的线传输介质中，双绞线的衰减随频率增加严重。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240325193250533.png" alt="image-20240325193250533" style="zoom: 80%;" /></p><p><em>在后续研究双绞线时，会认为双绞线是两条平直，线距一致的线。因为研究传输线基于微积分，当把双绞线切分成无数个小段之后，每一小段近似与平行。</em></p><p><strong>不同规格的双绞线</strong></p><p><em>（看看就可以，了解）</em></p><p>双绞线可以分为屏蔽（shielded twisted pair, STP）的和非屏蔽(unshielded twisted pair, UTP)的，屏蔽线的抗电磁干扰能力较好，但成本较高；因此日常使用的都是非屏蔽线。</p><p>双绞线依据其最高传输带宽，被分为了几类（以下只列举了典型两类）：</p><ul><li>3类线：最高传输带宽16Mhz的UTP线缆</li><li>5类线：最高传输带宽100Mhz的UTP线缆</li></ul><p>三类线和五类线的核心区别是双绞线的绕合率</p><h2 id="同轴线（coaxial-cable）"><a href="#同轴线（coaxial-cable）" class="headerlink" title="同轴线（coaxial cable）"></a>同轴线（coaxial cable）</h2><p><strong>同轴线的构成</strong>：类似于双绞线有两条线，同轴线也有两条线，这是其也被称之为双导体的原因。如下图所示，有Inner conductor 和 Outer conductor，两层导线轴心相同。</p><p>目前，同轴线广泛运用于射频信号的传播。</p><p><strong>双导体和单导体</strong>：双导体构成回路，可双向传输直流信号（恒电磁波），而单导体内信号是以电磁波的形式在传播</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240321174407017.png" alt="image-20240321174407017"></p><p><strong>同轴线的传输特征：</strong>同轴线能传输高频的信号，如下图所示。与双绞线相比，同轴电缆可以用于更长的距离，并支持线路上接入更多站点</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240325193250533.png" alt="image-20240325193250533" style="zoom:50%;" /></p><h2 id="光纤（optical-fiber）"><a href="#光纤（optical-fiber）" class="headerlink" title="光纤（optical fiber）"></a>光纤（optical fiber）</h2><p>光纤的结构如下图所示，其由三层基本结构组成：纤芯（core），包层（cladding），涂敷层(外护套)（coating）。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240325202232756.png" alt="image-20240325202232756"></p><p>一般来说，有两种光纤：支持的多种传播路径或横向模式的光纤被称为多模光纤(multi-mode)，而支持单一模式的被称为单模光纤（single-mode）。</p><ul><li>单模光纤主要用来承载具有长波长的激光束，单模只传输一种模式。和多模光纤相比，他的<strong>色散要少</strong>。由于使用更小的玻璃芯和单模光源，所以单模光纤支持很长的距离，传输距离可达10km甚至几十km。</li><li>多模光纤主要使用短波激光，具有50nm或者62.5nm的玻璃芯以及125nm的覆盖层。多模允许传输同时多个模式，覆盖层的反射限制了玻璃芯中的光，使他不会泄漏。短波长的激光束由那些从缆芯中以不同角度反射出来的光模所组成。<strong>由于不同模式的波速度，性质有差异，在接收端可能出现波形展宽，也就是色散。这种色散效果</strong>降低了可以恢复的原始信号的最长距离。</li></ul><p>其中，多模光纤又分为阶跃折射率和渐变折射率，其区别是线芯的折射率是阶跃变化还是渐进变化，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240325203205788.png" alt="image-20240325203205788"></p><p>下图由上至下展示：多模阶跃光纤，多模渐进光纤，单模光纤，内光信号的传播路径。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240325202924107.png" alt="image-20240325202924107" style="zoom:67%;" /></p><p>一般来说，多模的光纤线径大于单模</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240325202348684.png" alt="image-20240325202348684"></p><div class="note danger flat"><p>下面3个窗口五星级</p></div><p><strong>光纤通信中的发光器件：</strong> 光纤通信的复用方式是波分复用。光纤有3个衰减比较小的“透射窗口”，<strong>分别是850nm, 1310nm 1550nm</strong>。最初使用的是850nm的波长，如今许多本地通信使用的是850nm LED光源，这种方案比较便宜，但通常只适用于100Mbps以下的数据速率和几公里的距离；更高速率和距离需要1310nm的LED或是激光光源；下图展示了3个波长窗口，注意，图中单位为um（位于中文书102页）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/C4BA64DB26654D81E9EDF1C5319B175E.jpg" alt="C4BA64DB26654D81E9EDF1C5319B175E" style="zoom: 33%;" /></p><p>上面这个图不好看，这个图清晰一点：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240606031856814.png" alt="image-20240606031856814" style="zoom: 80%;" /></p><h1 id="非引导（无线）通信（五星级！）"><a href="#非引导（无线）通信（五星级！）" class="headerlink" title="非引导（无线）通信（五星级！）"></a>非引导（无线）通信（五星级！）</h1><div class="note info flat"><p>bnh的小知识：微波是电磁波的一个分支，特指频率很高波长很短的电磁波，其频率在300MHz-300GHz。</p></div><h2 id="天线"><a href="#天线" class="headerlink" title="天线"></a>天线</h2><p>（这一段在吹水）</p><p>通常我们在讨论天线时，主要关注快衰落和慢衰落（详见移动通信）。</p><p>在讨论天线时，多径效应影响明显（属于快衰落）。为了解决这个问题，有一种较为传统有效的方法，是分级接收：一个发送端和两个接收端，两个接收数据合并处理后再使用；这种技术要求两个天线水平摆放或是垂直摆放，通常来说垂直摆放效果更好。另一种方法是使用均衡技术，对衰落进行补偿。</p><p>在这门课中，主要讨论抛物面天线。</p><p>常见的微波天线是抛物面“碟形”。典型的尺寸约为直径3米，天线为刚性天线，有一个焦点，适用于窄波束LOS传输。微波天线通常位于地面以上相当高的位置，以扩大天线覆盖范围并避开障碍物。为了实现远距离传输，使用了一系列微波中继塔，点对点微波链路在所需距离上串在一起。</p><p>微波的另一个日益普遍的用途是用于建筑物之间的短点对点链路。这可以用于闭路电视或作为局域网之间的数据链路。短程微波也可以用于旁路应用。企业可以绕过当地电信公司，建立与同一城市远程电信设施的微波链路。</p><h3 id="天线的增益（五星级）"><a href="#天线的增益（五星级）" class="headerlink" title="天线的增益（五星级）"></a>天线的增益（五星级）</h3><div class="note danger flat"><p>天线增益五星级公式</p></div><p>天线的增益是它在接收某一方向信号时，该方向信号的功率和天线接收出的功率的比值。在天线传输理论一课中对下面这个公式已经进行过了推导。天线的增益可以用如下公式描述：</p><script type="math/tex; mode=display">G=\frac{4\pi A_e}{\lambda^2}=\frac{4\pi f^2A_e}{c^2}</script><p>其中：</p><ul><li>G: 天线增益</li><li>$A_e$: 天线有效面积</li><li>$f$: 载波频率</li><li>c: 真空中光速</li><li>$\lambda$: 载波波长</li></ul><p>抛物面天线有效面积的公式是：(其中A指圆面积，例如半径为r就是$2\pi r^2$)</p><script type="math/tex; mode=display">A_e=0.56A</script><p>理想全向增益为1的天线有效面积是：</p><script type="math/tex; mode=display">A_e=\frac{\lambda^2}{4\pi}</script><p>由于$4\pi\times0.57\approx7$, 因此抛物面天线的增益公式可以简化：</p><script type="math/tex; mode=display">G_{抛物面}=\frac{7A}{\lambda^2}</script><p><em>举个例子，一个抛物面天线直径为2m, 工作频率为12GHz, 天线的有效面积是多少？增益是多少？</em></p><script type="math/tex; mode=display">A=\pi r^2=\pi, A_e=0.56\pi</script><script type="math/tex; mode=display">\lambda=c/f=((3\times10^8)/(12\times10^9))=0.025m</script><script type="math/tex; mode=display">G=(7A)/\lambda^2=35186=45.46dB</script><h2 id="地表微波通信"><a href="#地表微波通信" class="headerlink" title="地表微波通信"></a>地表微波通信</h2><h2 id="卫星微波通信"><a href="#卫星微波通信" class="headerlink" title="卫星微波通信"></a>卫星微波通信</h2><p><strong>卫星通信核心问题：</strong>卫星通信最核心的问题是功耗问题，卫星一般都是携带电池，并通过太阳能电池板进行补能，电能非常有限。</p><p><strong>上下行的频段划分：</strong>在基站和手机的通信中，因为手机对功耗较为敏感，发射功率有限，因此在与基站的通信中终端上行数据会采用较低频率，以减少衰减。在卫星通信中，卫星是功耗敏感方，因此卫星通信的下行会采用较低频率。</p><p>在这门课中，还认为是使用微波进行卫星通信。但是其实现在非常多的学者已经在研究激光卫星/星间通信。激光对波的束缚能力要显著好于微波。但也正是因此，要对准发射端和接收端较难。</p><h2 id="无线通信电磁波的传播"><a href="#无线通信电磁波的传播" class="headerlink" title="无线通信电磁波的传播"></a>无线通信电磁波的传播</h2><h3 id="地波传播（Ground-Wave）（了解）"><a href="#地波传播（Ground-Wave）（了解）" class="headerlink" title="地波传播（Ground Wave）（了解）"></a>地波传播（Ground Wave）（了解）</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240408194113961.png" alt="image-20240408194113961"></p><p>地波指贴着地面，随着地表弧度弯曲传播的电磁波，它的传播距离可以远超视觉地平线。地波的频率大约为2MHz，属于长波通信，有很强的绕射能力。它会沿着地面传播的原因，是受地表感应电流影响，导致其波前（wavefont）向下倾斜，从而遵循地球的曲率。</p><p>典型的地波通信是AM广播。</p><h3 id="天波传播（Sky-Wave）（了解）"><a href="#天波传播（Sky-Wave）（了解）" class="headerlink" title="天波传播（Sky Wave）（了解）"></a>天波传播（Sky Wave）（了解）</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240408194617027.png" alt="image-20240408194617027"></p><p>天波依靠电离层反射传播，同样可以实现NLOS传播，但由于其经过反射，因此能量衰减巨大。其频率范围是2-30MHz</p><h3 id="Line-of-Signt-传播（重点）"><a href="#Line-of-Signt-传播（重点）" class="headerlink" title="Line-of-Signt 传播（重点）"></a>Line-of-Signt 传播（重点）</h3><div class="note danger flat"><p>五星级知识点！</p></div><p>对于高于30MHz的波，地波和天波就不管用了，需要视线传播。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240408195724164.png" alt="image-20240408195724164"></p><p>视线传播中，发射和接受端需要在“有效”的视线范围内，这个“有效的视线范围”其实不是完完全全一条直线，因为大气中空气密度不同而折射率不同，所以其实它是略微弯曲的，由于这种弯曲，微波其实能传到比视线略远的地方。</p><p>在没有空气散射的情况下,高度为h的天线，LOS传播的最大距离是</p><script type="math/tex; mode=display">d=3.57\sqrt{h}</script><p>有了空气散射之后需要加一个修正K，K的经验值是$4/3$</p><script type="math/tex; mode=display">d=3.57\sqrt{Kh}</script><p>假设天线1高$h_1$，天线2高$h_2$，那么传播距离是：</p><script type="math/tex; mode=display">d=3.57(\sqrt{Kh_1}+\sqrt{Kh_2})</script><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240408200057096.png" alt="image-20240408200057096"></p><p><strong>自由空间(Free space) 损耗</strong></p><div class="note danger flat"><p>五星级知识点！</p></div><p>对于任何类型的无线通信，信号都会随距离而分散，而接收面积恒定，因此，即使没有其他衰减或损伤，信号也会随着距离增加，传播范围越来越大，单位平均功率越来越少，产生衰减。这样的衰减被成为自由空间损耗。</p><p>理论来说，无线通信的最大中继距离是10-100km，但是在实际应用中，一般50km内就需要进行信号中继。</p><p>假设在各向同性天线下，天线的辐射是一个标准的球，考虑纯理想信道无衰减，只有能量分散带来的损耗。假设发射机发送功率为$P_t$。那么距离为d处球的单位面积接收的能量$S_{av}$就是：</p><script type="math/tex; mode=display">S_{av}=\frac{P_t}{4\pi d^2}</script><p>使用增益为1的各向同性天线接收，这样的天线$A_e=\frac{\lambda^2}{4\pi}$，在距离为d处，接收到的功率$P_r$为：</p><script type="math/tex; mode=display">P_r=S_{av}\cdot A_e=(\frac{\lambda}{4\pi d})^2P_t</script><p>对于各向同性天线，自由空间损耗为：</p><script type="math/tex; mode=display">\frac{P_t}{P_r}=\frac{(4\pi d)^2}{\lambda^2}=\frac{(4\pi fd)^2}{c^2}</script><p>其中：</p><ul><li>$P_t$: 发送端功率</li><li>$P_r$: 接收端功率</li><li>$\lambda$：载波波长</li><li>$d$: 距离（m）</li><li>$c$: 光速（m）= $3\times10^8m/s$</li></ul><p>如果以dB形式改写，这个公式为:</p><script type="math/tex; mode=display">L_{dB}=10log\bigg(\frac{P_t}{P_r}\bigg)=10log\bigg(\frac{(4\pi fd)^2}{c^2}\bigg)=10log\bigg(\frac{(4\pi d)^2}{\lambda^2}\bigg)</script><script type="math/tex; mode=display">=-20log(\lambda (m))+20log(d(m))+21.98dB</script><script type="math/tex; mode=display">=20log\bigg(\frac{4\pi f d}{c}\bigg)=20log(f{(Hz)})+20log(d{(m)})-147.56dB</script><p><em>例子：考虑一个电离层传播信号，频率4GHz，发送接收间距为35863km, 求其损耗</em></p><script type="math/tex; mode=display">\lambda=(3\times10^8)/(4\times 10^9)=0.075m</script><script type="math/tex; mode=display">L_{dB}=-20log(0.075)+20log(35.853\times10^6)+21.98=195.6dB</script><p>如果发送天线和接收天线增益不为1：</p><script type="math/tex; mode=display">P_r=S_{av}\cdot A_eG_rG_t=(\frac{\lambda}{4\pi d})^2G_rG_tP_t</script><script type="math/tex; mode=display">L_{dB}=10log\bigg(\frac{(4\pi d)^2}{G_rG_t\lambda^2}\bigg)=10log\frac{(cd)^2}{f^2A_rA_t}</script><script type="math/tex; mode=display">=−20log(𝑓(Hz))−10log(𝐴_r𝐴_𝑡)+20log(𝑑(m))+169.54</script>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 电信传输理论与工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代通信网络-LC2-基本通信协议及其应用</title>
      <link href="/posts/2f9f2f75.html"/>
      <url>/posts/2f9f2f75.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>本节对应参考书章节CH2</p></div><h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h1><h2 id="通信协议的功能和结构"><a href="#通信协议的功能和结构" class="headerlink" title="通信协议的功能和结构"></a>通信协议的功能和结构</h2><h3 id="通信协议的多层级化"><a href="#通信协议的多层级化" class="headerlink" title="通信协议的多层级化"></a>通信协议的多层级化</h3><p>通信协议倾向于分为很多层，每层分管不同功能。这样每次需要升级时，<strong>只需要在单独的层上做改变</strong>，保证层对外暴露的接口不变即可。我们把这样很多层的协议系统称为”纵向栈(vertical stack)”。</p><h3 id="通信协议的定义"><a href="#通信协议的定义" class="headerlink" title="通信协议的定义"></a>通信协议的定义</h3><p><strong>什么是通信协议(Protocol)？</strong>协议是允许<strong>对等层（peer layer）进行通信的一组规则或约定。</strong></p><p>如何理解这个对等层呢？例如我们通过QQ互相发送消息，那人与人就是对等层，QQ与QQ就是对等层。我发送消息你看到消息是人与人这个对等层的通信。我们通过软件界面与QQ交互，QQ拿到要发送的消息并显示接收到的消息，这是QQ这一对等层。</p><p><strong>协议必须包含（重点！）</strong>：</p><div class="note danger flat"><p>五星级</p></div><ul><li>语法（Syntax） - 即，数据块由哪些组成，由什么开始，由什么结束，有效载荷如何解析等等。</li><li>语义（Semantics）- 即，数据帧内的控制信息，纠错Header等。包含</li><li>时序（Timing） - 即，事件<strong>顺序</strong>的详细说明</li></ul><div class="note info flat"><p>其中这个Timing 单独强调一下：</p><p>在<strong>电信传输理论与工程</strong>一课中，在中继时提到了“retiming”, 这里的timing<strong>强调时间上“同步”</strong>，要在接收信号的允许抖动范围内进行采样，否则会产生滑码。<strong>而本课程（现代通信网络）中</strong>，这里的timing强调的是事件的<strong>先后顺序</strong>。</p></div><p>通常来说，一个协议规定的一帧数据由如下结构组成：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Header</th><th style="text-align:center">Payload</th><th style="text-align:center">Trailer(footer)</th></tr></thead><tbody><tr><td style="text-align:center">通常包含控制信息、地址信息等</td><td style="text-align:center">有效数据载荷</td><td style="text-align:center">对于精简的协议来说，可以省去Trailer。包含校验信息，纠错信息等</td></tr></tbody></table></div><h2 id="层"><a href="#层" class="headerlink" title="层"></a>层</h2><p>前面提到，通信协议倾向于分为很多层，总体而言，通信这个动作可以被<strong>大体</strong>抽象为以下三个相互独立的层（划分为3层是非常粗糙的）：</p><ul><li><p><strong>网络接入层（Network access layer）</strong>：专注于数据的交换：其提供目的地地址；特定服务，例如优先级；使网络中的终端互通并路由其数据；连接到同一网络的两个终端系统跨网络访问和路由数据</p></li><li><p><strong>传输层（Transport layer）</strong>: 物理路径上的传输：这一层级只负责把收到的比特一个一个发出去，通过握手，流控，校验等，控制其传输可靠性，并不需要理解其中意义。</p></li><li><p><strong>应用层（Application layer）</strong>：对交由应用程序理解信息意义，并呈现的层。例如QQ显示消息，或者网页浏览器将收到的HMTL文件数据以HTML格式解析后显示成网页。</p></li></ul><p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240322151503019.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240322151601874.png"></center></td>    </tr></table><br>上面两张图很好的阐释了这三个抽象的层，首先<strong>应用层</strong>想要发送数据“data”，<strong>传输层</strong>收到信息并将其打包，添加上来自哪里，去往哪里的信息等信息的“头”，并携带data本身，<strong>传给网络接入层</strong>。网络接入层再根据自己的网络协议，添加上路由，链接等信息的“头”，从网络上发出去。</p><h3 id="层间寻址（Addressing）"><a href="#层间寻址（Addressing）" class="headerlink" title="层间寻址（Addressing）"></a>层间寻址（Addressing）</h3><p>在网络上的每一个终端设备，都应当有一个唯一的网络地址</p><p>同时，终端上的每一个应用又有一个它自己的唯一地址</p><p><strong>↑用人话解释就是：不同层之间可以有自己的地址。</strong>这也就是说，不同层可以有自己的地址信息，他们以套娃的形式包裹在一次。在接收时一层协议一层协议解析时，一层一层解读出最终地址。</p><p>如何理解这个呢？你的电脑上同时装了QQ，你的QQ和微信都收到了一条消息，那么会先根据你的终端唯一网络地址，送到你的电脑上（这是传输层），然后再在你的电脑上分捡，QQ的消息QQ显示，微信的消息微信显示（这是应用层）。</p><div class="note info flat"><p>举个例子：我们是重庆|邮电大学|国际学院|通信工程|3409210x班|的学生Z*，你的6级考了329分，那么你的成绩单会先分到重庆，忽略后续的地址，然后下一层交换再分给虫游，忽略后续；以此类推，最后给到Z同学手机里面，手机分析出这个是要交给浏览器的，最后通过浏览器显示在屏幕上。这由粗到细的分拣就对应不同层间的数据传输。（理解到了，让我们说谢谢Z同学）</p></div><h3 id="协议数据单元（Protocol-Data-Unit-PDU）"><a href="#协议数据单元（Protocol-Data-Unit-PDU）" class="headerlink" title="协议数据单元（Protocol Data Unit, PDU）"></a>协议数据单元（Protocol Data Unit, PDU）</h3><p>通信协议中的不同“层”之间是服务与被服务的关系。在发送时，本层协议服务其上层协议，将上层协议传入的内容加上自己的header，传入下层，同时本层的下层协议服务本层协议。在接收时，<strong>对应层的header被对应层解析</strong>，<strong>并将其内含的data传给上一层</strong>，上一层又剥离出上一层的header，解析后传入给上二层。因此在逻辑层面而言，通信是层与层之间对等的。</p><p>协议数据单元PDU（Protocol Data Unit）就是指<strong>对等层</strong>之间传递的<strong>数据单位</strong>，通常包含：控制讯息，地址讯息，或者数据。其中，header部分通常包括：源端口、目标端口、序列号和错误检测代码。这些控制信息将会由接受端的对等协议层理解解析。</p><p><em>用信封的例子来解释这个套娃关系：</em></p><p><em>不同层各有一个信封，信封上写得有不同的内容，在传递给下一层封装时，会把上一层的信封塞到下一层内，并在下一层的信封上贴上这一层所需信息。</em></p><p><em>因此，每一层包好的这一封信，就是这一层的PDU。这一层会抱着这个信封发送，接受时打开这一层信封，并将该信封内套娃的信封交给它的上层。</em></p><h3 id="服务数据单元（Service-Data-Unit-SDU）"><a href="#服务数据单元（Service-Data-Unit-SDU）" class="headerlink" title="服务数据单元（Service Data Unit, SDU）"></a>服务数据单元（Service Data Unit, SDU）</h3><p>PDU是拿到要传输的数据再套上本层信息之后的数据单元。SDU就是指的一坨传输数据。传送到接收方的时候同一协议层时数据没有发生变化。在N层和N-1层间传递的数据单元，记为(N)SDU。</p><h1 id="TCP-IP-协议栈"><a href="#TCP-IP-协议栈" class="headerlink" title="TCP/IP 协议栈"></a>TCP/IP 协议栈</h1><h2 id="TCP-IP-五层协议栈"><a href="#TCP-IP-五层协议栈" class="headerlink" title="TCP/IP 五层协议栈"></a>TCP/IP 五层协议栈</h2><p>通常TCP/IP模型有以下五层，但也有部分参考文献将网络接入层和物理层和在一起，说其为4层。TCP/IP只是一个笼统的协议栈，还可以细分出很多的协议，TCP/IP是利用 IP 进行通信时所必须用到的协议群的统称，其主要是<strong>传输层使用TCP协议</strong>，<strong>网络层使用IP协议</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240327164014287.png" alt="image-20240327164014287" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240607112112849.png" alt="image-20240607112112849"></p><h3 id="不同层的功能"><a href="#不同层的功能" class="headerlink" title="不同层的功能"></a>不同层的功能</h3><p><em>这些层的功能不需要死记硬背，结合后面实际的协议进行理解即可。</em></p><div class="table-container"><table><thead><tr><th><strong>物理层(Physical)</strong></th><th><strong>负责信号的调制，编码方式（例如高电平还是低电平表达1），传输速率，物理接头，带宽指定等与电磁波在物理介质中传播相关的部分。该层只管比特的透明传输，负责保证二进制比特的正确传输。</strong></th></tr></thead><tbody><tr><td><strong>数据链路层（Network Access）</strong></td><td><strong>负责规定比特流的格式，头部通常带有地址及纠错信息。（MAC层属于该层的子层，有部分文献会用MAC层代替该层）（注：这一层的一个数据单位通常被成为“帧”，也被说成MAC帧）</strong></td></tr><tr><td><strong>网络层（Internet）</strong></td><td><strong>负责为两个网络中的节点选择一条传输通路。这一层可提供路由，网络接入，Qos控制（优先级控制）等服务。在数据链路层，数据开始有格式有地址了，而网络层让信息能送到指定的地址去。</strong></td></tr><tr><td><strong>传输层（Transport）</strong></td><td><strong>负责两个节点间数据的传输，确保数据正确地传递。提供流控，错误控制等功能。在一层中，最常用的是协议是Transmission Control Protocol(TCP)</strong></td></tr><tr><td><strong>应用层（Application）</strong></td><td><strong>负责最后应用程序层面，打开信封看里面的信纸，解析其信息的含义的操作</strong></td></tr></tbody></table></div><p>每一层都有自己层对应的控制信息，也就是每一层自己的header，如下图所示。每一层负责解读自己的header，并将灰色部分传给其上层。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240403162847291.png" alt="image-20240403162847291" style="zoom: 67%;" /></p><p>上图中，对某一层而言，某一层的一整条数据（灰的加白的）就是前面介绍的PDU，而灰色部分就是SDU。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="在协议栈中扮演的角色"><a href="#在协议栈中扮演的角色" class="headerlink" title="在协议栈中扮演的角色"></a>在协议栈中扮演的角色</h3><p>TCP是一种面向连接的协议，适合可靠性要求高，长时间连续的通信业务。TCP协议在通信协议中的位置如下图所示，<strong>是位于传输层的协议</strong>。</p><div class="note info flat"><p>在这里涉及传输层有点抽象，但是这门课没有成体系的教案，知识都是这样零零散散的。个人建议最后再来看这里，把网络层看完之后。（这里也不是很重要</p></div><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240327174640187.png" alt="image-20240327174640187" style="zoom:67%;" /></p><h3 id="TCP-Header"><a href="#TCP-Header" class="headerlink" title="TCP Header"></a>TCP Header</h3><p>TCP协议规定的Header如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240403163850086.png" alt="image-20240403163850086" style="zoom:67%;" /></p><p><em>上图中，octets表示8bit。</em></p><ul><li><p>Source Port：16bit源端口号</p></li><li><p>Destination Port: 16位接收方端口号</p></li><li><p>Sequence Number：帧的序列号，用于数据包重新组装。在接收端，根据这个序列号将拆分的数据重新组装在一起。</p></li><li><p>Acknowledgement Number：应答序列号。</p></li><li><p>Header Length：TCP Header的长度</p></li><li><p>Reserved：保留位，不使用</p></li><li><p>Flags：标志位，用于通信双方维护一些控制信息，例如是否启用Acknowledgement Number，是否为连接请求报文等等。有URG、ACK、PSH、RST、SYN、FI六种。详细功能就不介绍了。</p></li><li><p>Windows：接收机窗口大小，参见滑窗流控。</p></li><li><p>Checksum：校验和，差错控制使用</p></li><li><p>Urgent Pointer：紧急指针，是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号</p></li><li><p>Options+Padding：可变长可选信息的预留位。总共有7种kind，内涵不同的控制信息，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/QQ_1724116993221.png" alt="QQ_1724116993221"></p></li></ul><div class="note info flat"><p><strong>为什么用octet不用byte?</strong></p><p>Octet 总是表达8个bit ，当我们在谈论网络通信上的问题时，更喜欢使用这个词而不是Byte。</p><p>Byte 通常情况下也表示8个bit，但是准确的说，Byte表示的是<strong>CPU可以独立的寻址的最小内存单位</strong>（不过通过移位和逻辑运算，CPU也可以寻址到某一个单独的bit）。曾几何时，有些电脑的寻址单位不是8Bit的。而现在，大多数情况下byte可以和octet等价。<strong>但是如果你想要强调准确的8bit时，你就应该使用octet而不是byte。</strong></p></div><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p><strong>例子：理解TCP面向连接——握手过程</strong></p><p><em>有A和B两军在打仗，A占领了两边的山峰，想要明天早上6点两边同时下去把B干掉。因此排出一个传信员，左边将这个消息告诉右边，也就就是路径1。但是传信员存在穿越B时被噶掉的风险，因此右边的A收到后，让传信员再返回左边的A去告诉左边的司令管他们收到了，这也就是路径2。但是此次穿越B还有被噶掉的风险，如果传信员此时被噶掉，右A收并不能确定左A是否收到了“右A已收到”的消息，因此当传信员成功回到左A时，左A的司令管让它再回到右A去告诉：“我们收到了‘你们收到我们的消息’的消息了”，这也就是路径3</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240327180456586.png" alt="image-20240327180456586"></p><p>在TCP中也是一样，假设有A和B两台机器，A先朝B发送数据请求建立连接。B再朝A发送ACK进行回应。A收到B的回应时，A知道它与B之间收发数据均可达，A再朝B发送一次回应，此时B知道它和A之间的收发也是正常的。</p><p><strong><em>说TCP是面向连接的，就是因为它规定了三次这样的握手过程。</em></strong></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP是面向无连接的协议，也就是管发但不管收没收到那种，适用于“突然来一下”的通信，简短，即时性高的通信。</p><h3 id="UDP-Header"><a href="#UDP-Header" class="headerlink" title="UDP Header"></a>UDP Header</h3><p>UDP协议的头如下图所示，可见，其相对于TCP简短很多。只包含了发送站端口号，接收机端口号，帧长度，和校验和。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240403164844234.png" alt="image-20240403164844234"></p><h1 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h1><p>OSI的全称是：Open System Interconnection (开放系统互联模型)。OSI定义了网络互连的七层模型（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/v2-794aa7d2b0da939f8559f29ae28136c7_r.jpg" alt="img" style="zoom:50%;" /></p><h2 id="不同层的功能-1"><a href="#不同层的功能-1" class="headerlink" title="不同层的功能"></a>不同层的功能</h2><div class="table-container"><table><thead><tr><th style="text-align:center">层</th><th style="text-align:center">关键词</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">应用层</td><td style="text-align:center">被应用程序调用</td><td style="text-align:left">为应用程序提供网络服务接口。与TCP/IP五层协议中同义。</td></tr><tr><td style="text-align:center">表示层</td><td style="text-align:center">数据编码、格式转换、数据加密。</td><td style="text-align:left">提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一</td></tr><tr><td style="text-align:center">会话层</td><td style="text-align:center">创建、管理和维护会话</td><td style="text-align:left">接收来自传输层的数据，负责建立、管理和终止表示层实体之间的通信会话，支持它们之间的数据交换。</td></tr><tr><td style="text-align:center">传输层</td><td style="text-align:center">传输数据</td><td style="text-align:left">提供可靠的数据传输，流控等。与TCP/IP五层协议中同义。</td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:center">路由、寻址</td><td style="text-align:left">负责终端之间建立，保持，挂断通信。</td></tr><tr><td style="text-align:center">数据链路层</td><td style="text-align:center">封装为待发送“帧”</td><td style="text-align:left">将网络层的数据帧，拆装为位流形式的数据转发到物理层；负责建立和管理节点间的链路，通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</td></tr><tr><td style="text-align:center">物理层</td><td style="text-align:center">电磁波发送</td><td style="text-align:left">传输介质为数据链路层提供物理连接，实现比特流的透明传输。与TCP/IP五层协议中同义。</td></tr></tbody></table></div><p>其中，在真正的协议中，很少有协议会单独定义<strong>会话层</strong>和<strong>表示层</strong>的，其功能多并入上层和下层。<strong>因此这两层独立存在情况极少</strong>。</p><p>（其实没有协议会完整地遵照OSI这个模型去设计，经常都是几层协议和在一起或者一层协议剥开几层。TCP/IP更好理解一些。）</p><h3 id="与TCP-IP比较"><a href="#与TCP-IP比较" class="headerlink" title="与TCP/IP比较"></a>与TCP/IP比较</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/OIP-C.aqECjESRywFaKW0siDxWGQHaFj" alt="网络OSI七层模型及各层作用"></p>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 现代通信网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电信传输理论-CH2-Data Transmission</title>
      <link href="/posts/5b823d72.html"/>
      <url>/posts/5b823d72.html</url>
      
        <content type="html"><![CDATA[<h1 id="传输技术简介"><a href="#传输技术简介" class="headerlink" title="传输技术简介"></a>传输技术简介</h1><p>数据传输是以电磁波为数据载体，在发射器和接收器之间通过传播介质进行传播。这种传播可以被分为:</p><ul><li>有引导（guided wave）：将波束引导至一个特定的物理路径</li><li>无引导（unguided wave）：波束自由传播</li></ul><p>能够将电磁波导向的传播介质称为 guided media, 例如双绞线，同轴线，光纤等，波导（Wave guide）等。在讨论传输的时候，会有一个名词叫“介质波导”，它通常是指的有别于导体的波导介质，如光纤。</p><p>无法对电磁波进行导向的传播介质成为unguided media, 也称为 wireless（无线）, 例如空气，真空，海水等。</p><div class="note info flat"><p>下面的介绍还包含：频率，频谱和带宽; 模拟信号和数字信号;</p><p>频谱和频率是什么（一般取大于半功率点的部分作为主频分量）;</p><p>数据速率(Data Rate)和带宽(Bandwidth) 的关系（这个关系其实就是通信原理里面那些，这里简单说了一下，特别强调了一下数字信号带宽和波形的影响（参考通信原理讲耐奎斯特带宽那节）；</p><p>$\uarr$ 这些内容都属于基础必备知识，前面的课程都已经涉及太多太多遍了，这里就不写了。要是有不记得的去百度一下$\uarr$</p></div><div class="note info flat"><p>signaling: 这个单词可以 1.表达物理层面的传播; 2. 表示发送一个信令（部分文献写作signalling来强调信令）; <strong>在这门课程中，它表示物理上的电磁波传播</strong></p></div><h1 id="数据和信号"><a href="#数据和信号" class="headerlink" title="数据和信号"></a>数据和信号</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p><strong>模拟数据：</strong> 模拟数据是由数据源产生的，在某个区间内连续的值。例如语音，温度，压力等。</p><p><strong>数字数据</strong>：数据数据时离散值，例如文本或是字符串（离散二进制编码如ASCII，部分编码还包含校验码）。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>在通信系统中，数据通过信号进行传输</p><h3 id="模拟信号"><a href="#模拟信号" class="headerlink" title="模拟信号:"></a>模拟信号:</h3><p>模拟信号是连续的可以通过各种介质传播的变化的电磁波。例如光纤内传播的信号，无线信号等。</p><ul><li>典型：语音信号的标准频谱范围：300-3400Hz。这是在保真和带宽成本间取的平衡值（原始语音频谱大约在300-7kHz）。</li></ul><h3 id="数字信号："><a href="#数字信号：" class="headerlink" title="数字信号："></a>数字信号：</h3><p>数字信号是通过线缆传播的一串电压脉冲(Voltage Pulses)。例如用低电平表示0，高电平表示1。理想的方波脉冲FT之后是Sa函数，因此占有无限的频宽；在带限信道中传输之后，会失真。</p><ul><li><p>一个数字信号失真的例子</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240314165920255.png" alt="image-20240314165920255" style="zoom:50%;" /></p></li></ul><h3 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h3><p>上面提及的模拟数据，数字数据，模拟信号，数字信号之间是可以相互装换的。模拟信号可以承载模拟数据，也可以承载数字数据；同样地，数字信号也可以承载模拟数据或数字数据。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240314170833680.png" alt="image-20240314170833680" style="zoom: 33%;" /></p><p><em>一个拓展：modem（调制解调器）</em></p><p><em>以前会去运营商办我网络会接一个电modem，现在普遍时光modem，又称光猫。其作用就是为光信号做调制解调</em></p><h3 id="模拟和数字传输"><a href="#模拟和数字传输" class="headerlink" title="模拟和数字传输"></a>模拟和数字传输</h3><p>模拟传输是将模拟数据调制成想要的形式的信号（如AM）后发射，其可以在guided media或unguided media上传输。信号模拟信号在长途传输过程中需要引入放大器来解决衰减。但放大器会连噪声一起放大。</p><p>数字传输是高点电压方波脉冲，其在未经调制成模拟信号前，只能在guided media内传输。<strong>而数字传输则可使用repeater将通信信息解码后重新调制无损发出，因此模拟传输相较于数字传输，有“不适配再生”的劣势。</strong>且传输成本比模拟信号更加便宜。但其主要缺点是数字信号传输比模拟信号传输更容易受到衰减的影响。</p><h1 id="传输损伤-五星级"><a href="#传输损伤-五星级" class="headerlink" title="传输损伤(五星级)"></a>传输损伤(五星级)</h1><div class="note danger flat"><p>下面这段五星级，但是私以为这一段的PPT就是百度百科的英文版，可以搜索“传输损伤”的百度百科看看…</p><p>传送门: <a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E6%8D%9F%E4%BC%A4/6118208#3">百度百科</a></p></div><p>对于任何通信系统，由于各种传输损伤，所接收的信号可能与所发送的信号不同。对于模拟信号，这些损伤会降低信号质量。对于数字信号，可以引入比特误差，使得二进制1被转换为二进制0，反之亦然。</p><p>最显著的三个损伤：</p><ul><li>衰减(Attenuation)和衰减失真(Attenuation distortion)</li><li>延迟失真(Delay distortion)</li><li>噪声(Noise)</li></ul><h2 id="衰减-Attenuation"><a href="#衰减-Attenuation" class="headerlink" title="衰减(Attenuation)"></a>衰减(Attenuation)</h2><p>在任何传输介质上，信号的强度都会随着距离的推移而下降。对于guided media，这种衰减通常是指数级的，因此通常表示为每单位距离的恒定分贝数。对于unguided media，衰减更大</p><p>衰减的损伤会作用于三个层面：</p><ul><li>信号的强度</li><li>信噪比降低</li><li>非线性失真(不同频段衰减程度不一样，attenuation various with frequency)</li></ul><p>强度的衰减和信噪比问题都可以通过放大器或中继器( amplifiers or repeaters)来解决。<strong>而非线性失真需要用均衡器来解决（equalizing），均衡器可以给不同的频段给予不同强度的补偿</strong>，这也就是音乐发烧友常说的”调eq”。</p><h2 id="延迟失真-Delay-distortion"><a href="#延迟失真-Delay-distortion" class="headerlink" title="延迟失真(Delay distortion)"></a>延迟失真(Delay distortion)</h2><div class="note info flat"><p>在通信系统中，有两种延迟：delay和latency ; latency强调是一个信号输入一个系统，系统处理造成的延迟。delay则是下文介绍的</p></div><p>时延失真的产生是由于在导向媒体上信号传播速度随频率的不同而改变。对频带有限的信号来说，在靠近中心频率的地方其传播速度趋于最快，而越靠近频带的两侧，传播速度越慢。因此，信号的不同频率成分到达接收器的时间也不同，从而导致了不同频率之间的相移。</p><p>也就是说，时延失真是接收到的信号因其频率成分延迟的不同而产生了失真。时延失真对数字信号尤为严重。不管用的是模拟信号还是数字信号来传输一个比特串，由于延迟失真的存在，某个比特的一些频率成分会溢出到其他比特上，因此会产生<strong>码间串扰</strong>。它是传输信道上最高比特速率受限的一个主要因素。</p><h2 id="噪声-Noise"><a href="#噪声-Noise" class="headerlink" title="噪声(Noise)"></a>噪声(Noise)</h2><p>噪声主要可分为：</p><ul><li>热噪声（Thermal noise）:</li><li>互调噪声（Intermodulation noise）</li><li>串扰（Crosstalk）</li><li>冲激噪声（Impulse noise）</li></ul><h3 id="热噪声"><a href="#热噪声" class="headerlink" title="热噪声"></a>热噪声</h3><p><strong>热噪声（thermal noise）</strong>是由电子的热运动造成的。热噪声存在于所有的电子设备和传输媒体中，并且是温度的函数。热噪声均匀地分布在通信系统常用的频率范围内，因此它通常称为<strong>白噪声</strong>。热噪声是无法消除的，这就为通信系统的性能带来一个上限。由于卫星地面接收到的信号本来就很弱，因此热噪声对卫星通信的影响最为严重。</p><p>在任何设备和导体中，1Hz带宽内存在的热噪声的值都是：</p><script type="math/tex; mode=display">N_0=kT(W/Hz)</script><p>其中：</p><p>$N_0$ =每1Hz的噪声功率密度</p><p>k=玻尔兹曼常数$1.38\times 10^{-23}J/k$</p><p>T =开氏温度</p><p><em>举个例子</em></p><p><em>在17摄氏度（290K）的房间内，每1Hz噪声功率密度是：</em></p><script type="math/tex; mode=display">N_0=(1.38\times 10^{-23}\times 290=4\times10^{-21}W/Hz</script><p>有了单位密度，乘上带宽即可得到频带内的白噪声功率$N$</p><script type="math/tex; mode=display">N=kTB</script><p>写成dB形式就是（单位:dBW）</p><script type="math/tex; mode=display">N=10logK+10logT+10logB</script><p><em>举个例子：</em></p><p><em>温度为294K, 带宽为10Mhz时，接收器热噪声为：</em></p><script type="math/tex; mode=display">N=-228.6dBW+10log(294)+10log(10^7)</script><h3 id="互调噪声（intermodulation-noise）"><a href="#互调噪声（intermodulation-noise）" class="headerlink" title="互调噪声（intermodulation noise）"></a>互调噪声（intermodulation noise）</h3><p>当不同频率的信号共享同一传输媒体时，可能会产生<strong>互调噪声（intermodulation noise）</strong>。互调噪声带来的影响是产生了额外的信号，其频率为两个原频率之和或差，也可能是若干倍的原频率。例如，将频率分别为f1和f2的信号混合在一起，就有可能产生频率为f1+f2的能量。这一生成信号有可能会干扰频率为f1+f2的正常信号</p><p>互调噪声的产生由于在发送器、接收器中存在非线性因素，或者是传输系统受到干扰。理想情况下，这些系统组成器件以线性系统方式工作，就是说，输出等于输入的常倍数。然而在任何实际系统中，输出是输入的较复杂函数。过度非线性的产生可能是由于元器件发生了故障或加载的信号过强。也正是在这些情况下会出现频率相加或相减的情况。</p><p><strong>串扰（crosstalk）</strong></p><p>如果你曾经在打电话时听到过别人的对话，那么你对<strong>串扰（crosstalk）</strong>已经有过亲身经历。它是我们不希望看到的信号通道之间的耦合现象。它的产生是由于载有多路信号的相邻双绞线之间发生电耦合，有时在同轴电缆之间也会发生，不过很少见。当微波天线收到不需要的信号时也可能发生串扰现象。</p><p><strong>冲激噪声（impulse noise）</strong></p><p>以上讨论的所有类型的噪声都是可预测的，并有着比较固定的强度。因此在设计传输系统时有可能妥善处理这些问题。然而是非连续的，由不规则的脉冲或持续时间短而振幅大的噪声尖峰组成。它的产生有多种原因，包括外部电磁波干扰（如雷电）以及通信系统本身的故障和缺陷。</p><p>通常对模拟数据来说，冲激噪声引起的麻烦并不大。例如，话音传输可能被短暂的咔嚓声打扰，但并不影响对话音的理解。然而，在数字数据通信中，冲激噪声是差错的主要原因。例如，一个持续时间为0.01s的能量尖峰不会破坏任何话音数据，但有可能会毁掉560bits的以56kbps速率传输的数字数据。</p><h1 id="信道容量-五星级，但是不是难点"><a href="#信道容量-五星级，但是不是难点" class="headerlink" title="信道容量(五星级，但是不是难点)"></a>信道容量(五星级，但是不是难点)</h1><div class="note danger flat"><p>五星级小节！</p></div><p>信道容量的定义：道能无错误传送的最大信息率。对于只有一个信源和一个信宿的单用户信道，它是一个数，单位是比特每秒或比特每符号。</p><p>信道容量与：1.数据速率；2.带宽; 3.噪声 4. 误码率 有关</p><h2 id="耐奎斯特带宽："><a href="#耐奎斯特带宽：" class="headerlink" title="耐奎斯特带宽："></a>耐奎斯特带宽：</h2><p>奈氏准则指出在带宽有限下，<strong>码元传输</strong>的速率是受限的（<strong>不考虑噪声</strong>）。详见通信原理，就是理论最大符号率2B</p><p>（注意！这里不是信息传输速率，而是码元，可以通过增加调制的电平数量，也就是每个码元包含的比特数量来提高信息传输速率）</p><p><em>举个例子：</em></p><p><em>假设一个经过modem调制的数字语音信号，带宽为3100Hz, 那么耐奎斯特信道容量就是2B=6200Baud，假设使用M=8的调制（M同通信原理数字信号频带调制部分，例如QPSK M=4, 8PSK M=8）那么信道最大比特速率就是18600bps</em></p><h2 id="香农信道容量公式"><a href="#香农信道容量公式" class="headerlink" title="香农信道容量公式"></a>香农信道容量公式</h2><p>香农公式带宽受限且<strong>有高斯白噪声干扰</strong>的信道极限、无差错的<strong>信息传输速率</strong>。公式为：</p><script type="math/tex; mode=display">C=B\times log_2(1+SNR)</script><p>从这门课的角度来看，香农公式考虑的噪声主要是热噪声，而缺失了串扰，冲击噪声等。因此香浓噪声其实也是一个较为理想的上限容量（在考虑香农公式时，耐奎斯带宽是纯纯的理想容量）。</p><p><em>举个例子：</em></p><p><em>假设信道始于3MHz止于4Mhz, SNR=24dB(二进制信道，M=2)</em></p><script type="math/tex; mode=display">带宽B=4-3=1MHz,SNR=10^{2.4}=251</script><p><em>香农容量下：</em></p><script type="math/tex; mode=display">C=10^6 \times log_2(1+251)=10^6\times 8=8Mbps</script><p><em>这个是该噪声环境下的极限容量，耐奎斯特带宽指出了一定带宽下无噪声的码元速率，那么一个码元需要包含多少比特才能达到香农公式指出的极限比特速率呢？</em></p><script type="math/tex; mode=display">C=2Blog_2M=8\times10^6</script><p><em>算出M=16。也就是需要16电位等级的调制，来达到香农传输带宽上限。</em></p><h2 id="和误码率的强相关项：-E-b-N-0"><a href="#和误码率的强相关项：-E-b-N-0" class="headerlink" title="和误码率的强相关项：$E_b/N_0$"></a>和误码率的强相关项：$E_b/N_0$</h2><p>在$E_b/N_0$这个式子中，<strong>$E_b$代表每个bit蕴含的能量，而$N_0$代表每Hz的噪声能量密度</strong></p><p>假设数据的bit传输速率为$R(bit/s)$，则单bit持续时间为$T_b=1/R$</p><p>若信号的功率密度为$S(W)$，那么，每个bit蕴含的能量就是：$E_b=S\times T_b=S/R$</p><p>前面提到过，在热噪声模型下，单位Hz噪声密度$N_0=kT$，其中 玻尔兹曼常数$k=1.38\times 10^{-23}J/k$</p><p><strong>1.那么$E_b/N_0$可以阐释为和信号功率S相关的表达式：</strong></p><script type="math/tex; mode=display">\frac{E_b}{N_0}=\frac{S/R}{N_0}=\frac{S}{kTR}</script><p>以dB形式可以写成：</p><script type="math/tex; mode=display">\bigg(\frac{E_b}{N_0}\bigg)_{dB}=S_{dBW}-10log(R)-10log(k)-10logT</script><script type="math/tex; mode=display">=S_{dBW}-10log(R)+228.6dBW-10logT</script><p>因为$E_b/N_0$和误码率存在某种函数关系，假设在已知误码率为n时对应$E_b/N_0=m$，根据上述信号功率S相关的表达式，即可算出接收信号的强度$S_{dBW}$。</p><p><em>举个例子：</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240616150256068.png" alt="image-20240616150256068"></p><p><strong>2.这个式子还可变成和频谱效率(spectral efficiency)相关的表达式：</strong></p><p>因为信道噪声$N=N_0B$ (B是带宽)</p><script type="math/tex; mode=display">\frac{E_b}{N_0}=\frac{S/R}{N_0}=\frac{S}{N}\cdot\frac{B}{R}</script><p>上式中$S/N$恰好就是信噪比。将香农公式$C=B\times log_2(1+SNR)$逆推出来：</p><script type="math/tex; mode=display">SNR=2^{C/B}-1</script><p>香农公式这中的C代表信道最高传输bit速率，恰好就是这里的R。因此，$\frac{E_b}{N_0}$可以写成：</p><script type="math/tex; mode=display">\frac{E_b}{N_0}=(2^{C/B}-1)\cdot\frac{B}{C}</script><p>这个$C/B$，意为单位带宽的比特传输速率，恰好就是频谱效率(spectral efficiency)</p><p><em>例题：Suppose we want to find the minimum $E_b/N_0$ required to achieve a spectral efficiency of 6 bps/Hz</em></p><script type="math/tex; mode=display">E_b/N_0=(2^6-1)\cdot\frac{1}{6}=10.5</script><p>化为dB形式：</p><script type="math/tex; mode=display">10log(10.5)=10.212dB</script>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 电信传输理论与工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拉普拉斯变换</title>
      <link href="/posts/cc687296.html"/>
      <url>/posts/cc687296.html</url>
      
        <content type="html"><![CDATA[<h1 id="引入——为什么有拉普拉斯变换"><a href="#引入——为什么有拉普拉斯变换" class="headerlink" title="引入——为什么有拉普拉斯变换"></a>引入——为什么有拉普拉斯变换</h1><p>傅里叶变换将时域信号转化到了频域，傅里叶逆变换又实现了频域到时域的过程。根据傅里叶变换的性质，我们发现，使用傅里叶来处理微分方程时，可以消除其中的微分项（时域微分性质）。那如果我们将一个信号从时域变换到频域，在频域处理完后再逆变换回去，那便可以跳过微分项的计算，从而简化计算过程。</p><p>然而，要对一串信号作用傅里叶变换，它就必须要遵循狄利克雷收敛条件。这个条件不利于我们处理一些信号。为了使得更多的信号绝对可积，在傅里叶变换的变换对的基础上给信号施加一个<strong>衰减因子</strong>，又不影响其可以跳过微分的性质，那么我们便可以更轻易地处理系统函数了和求解微分方程。因此，产生了拉普拉斯变换</p><p>因此，我们定义了一个$e^{-\sigma t}$ 做为衰减因子，作用于傅里叶变换的基础上，成为拉氏变换。</p><h1 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="双边拉普拉斯变换"><a href="#双边拉普拉斯变换" class="headerlink" title="双边拉普拉斯变换"></a>双边拉普拉斯变换</h3><p>拉普拉斯变换对的定义如下（双边）</p><ul><li><strong>正变换</strong></li></ul><script type="math/tex; mode=display">F(s)=L[f(t)]=\int_{-\infty}^{\infty}f(t)e^{-st}dt, s=\sigma+j\omega</script><ul><li><strong>逆变换</strong></li></ul><script type="math/tex; mode=display">f(t)=L^{-1}[F(s)]=\frac{1}{2\pi j}\int_{\sigma -j\infty}^{\sigma+j\infty} F(s)e^{st}ds</script><p>正如引入中所介绍，傅里叶变换的定义式是：</p><script type="math/tex; mode=display">F(\omega)=F[f(t)]=\int_{-\infty}^{\infty}f(t)e^{-j\omega t}dt</script><p>如果将傅里叶变换定义中的$e^{-j\omega t}$ 乘上衰减因子$e^{-\sigma t}$，它就变成了$e^{-j\omega t}\times e^{-\sigma t}=e^{-(j\omega+\sigma)t}$， 记复数$j\omega + \sigma =s$，就可以写成$e^{-st}$，这就变成了拉普拉斯变换</p><p>这个衰减因子的 $\sigma$ 是做为常数存在的，也就是可以通过控制 $\sigma$ 来控制衰减的大小。</p><h3 id="单边拉普拉斯变换"><a href="#单边拉普拉斯变换" class="headerlink" title="单边拉普拉斯变换"></a>单边拉普拉斯变换</h3><p>双边拉普拉斯变换中，把 $t&lt;0$ 的范围也算进去了。在现实中，可以将信号开始产生的时刻记为 $t = 0$, 那么$t&lt;0$时没有信号因此$f(t)= 0, t&lt;0$。因此，只需要对$[0, +\infty]$ 区间内的信号进行处理即可。这也就成了单边拉普拉斯变换。(这个$0^-$表示从左侧无限趋近于0开始，从工程的角度解释，就是包含了电感电容等储能元件在 t=0 时的初始条件)</p><ul><li><strong>正变换</strong></li></ul><script type="math/tex; mode=display">F(s)=L[f(t)]=\int_{0^-}^{\infty}f(t)e^{-st}dt, s=\sigma+j\omega</script><p>（逆变换同双边变换，因为逆变换的积分是作用于 s 上的，所以不受 t 的影响）</p><p><strong>在分析实际的系统时，一般都使用单边拉普拉斯变换，因为实际系统具有信号开始产生的 t=0 时刻，t&lt;0 时信号为0，下方所有的讨论也都是适用于单边拉普拉斯变换的</strong></p><h2 id="收敛域（Range-of-Convergence-ROC）"><a href="#收敛域（Range-of-Convergence-ROC）" class="headerlink" title="收敛域（Range of Convergence ROC）"></a>收敛域（Range of Convergence ROC）</h2><p>纵然乘上了个$e^{-\sigma t}$，也只是增加了$f(t)$收敛的可能性，仍不能保证其收敛。因此拉普拉斯变换存在收敛范围，仅在收敛范围内时，$F(s)$ 存在</p><p>那么对于一个施加了衰减因素的信号 $f(t)e^{-\sigma t}$, 其收敛就是当 $t \rightarrow \infty$ 时，$\lim_{t\rightarrow\infty}f(t)e^{-\sigma t}=0$ </p><p>假设存在一个$\sigma_0$, 当$\sigma &gt; \sigma_0$时（也就是衰减速度比$\sigma_0$控制的衰减速度更大时），$\lim_{t\rightarrow\infty}f(t)e^{-\sigma t}=0$ ；  $\sigma &gt; \sigma_0$这个区间便被称为拉普拉斯变换的收敛域，记作$Rs[s] = \sigma &gt; \sigma_0$</p><p><em>举个例子</em></p><p><em>$f(t)=e^{-2t}, t&gt;0$ 求收敛域</em></p><script type="math/tex; mode=display">f(t)e^{-\sigma t}= e^{-2t}e^{-\sigma t}=e^{-(2+\sigma)t}</script><script type="math/tex; mode=display">\lim_{t\rarr\infty}e^{-(2+\sigma)t}=0</script><p><em>故$(2+\sigma) &gt; 0$</em>，<em>因此拉氏变换敛域是$\sigma &gt; -2$</em></p><h2 id="典型信号的拉普拉斯变换"><a href="#典型信号的拉普拉斯变换" class="headerlink" title="典型信号的拉普拉斯变换"></a>典型信号的拉普拉斯变换</h2><div class="note danger flat"><p>下面这些都是五星级的，拉普拉斯变换的计算通常使用变换对，下面这些都是常用的变换对</p></div><h3 id="单位阶跃信号（step-signal）"><a href="#单位阶跃信号（step-signal）" class="headerlink" title="单位阶跃信号（step signal）"></a>单位阶跃信号（step signal）</h3><p>信号$f(t) = u(t)$</p><p>因为单边拉式变换从0开始，单位阶跃信号 u(t) 在 $[0,+\infty]$ 范围内都是1，所以下式直接带1</p><script type="math/tex; mode=display">\int_{0}^{\infty}1\times e^{-st}dt=-\frac{1}{s}e^{-st}\bigg|_{0}^{\infty} =\frac{1}{s}</script><h3 id="指数信号-exponential-signal"><a href="#指数信号-exponential-signal" class="headerlink" title="指数信号 (exponential signal)"></a>指数信号 (exponential signal)</h3><p>信号$f(t) = e^{-(\alpha+j\beta)t}$</p><script type="math/tex; mode=display">\int_{0}^{\infty}e^{-(\alpha+j\beta)t}\times e^{-st}dt=\frac{e^{-(s+\alpha+j\beta)t}}{-(s+\alpha+j\beta)}\bigg|^{\infty}_{0}= \frac{1}{(s+\alpha+j\beta)}</script><p>如果$\beta= 0 $，即这是一个实数指数：</p><script type="math/tex; mode=display">F(s)=\frac{1}{(s+\alpha)}, (\sigma > \alpha)</script><p>其中$(\sigma &gt; \alpha )$ 是其收敛域</p><h3 id="单位冲击信号（unit-sample-signal）"><a href="#单位冲击信号（unit-sample-signal）" class="headerlink" title="单位冲击信号（unit sample signal）"></a>单位冲击信号（unit sample signal）</h3><p>信号$f(t) = \delta (t)$</p><script type="math/tex; mode=display">\int_{0^-}^{\infty}\delta(t)\times e^{-st}dt= 1</script><p>如果有时移时：</p><script type="math/tex; mode=display">\int_{0^-}^{\infty}\delta(t-t_0)\times e^{-st}dt= e^{-st_0}</script><h3 id="斜坡信号-ramp-signal"><a href="#斜坡信号-ramp-signal" class="headerlink" title="斜坡信号 (ramp signal)"></a>斜坡信号 (ramp signal)</h3><p>$f(t)= r(t)=t\times u(t)$，在$t&gt;0$时可写成$f(t)=t$</p><p>(下面用了分部积分)</p><script type="math/tex; mode=display">\int_{0^-}^{\infty} t \times e^{-st}dt= -\frac{1}{s}\int_{0}^{\infty}t\ d{e^{-st}}= -\frac{1}{s}\bigg[ t\cdot e^{-st}\bigg|^{\infty}_{0}- \int_{0}^{\infty}e^{-st}dt \bigg]=\frac{1}{s^2}</script><h2 id="拉普拉斯变换的性质"><a href="#拉普拉斯变换的性质" class="headerlink" title="拉普拉斯变换的性质"></a>拉普拉斯变换的性质</h2><div class="note danger flat"><p>下面这些都是五星级的，证明请参考Dr. Ruiheng Wu 的 PPT 或是百度，方法千奇百怪的，这里不再赘述。</p></div><h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><p>若：</p><script type="math/tex; mode=display">L[f_1(t)]=F_1(s), L[f_2(t)]=F_2(s)</script><p>有：</p><script type="math/tex; mode=display">L[k_1f_1(t)+k_2f_2(t)]=k_1F_1(s)+k_2F_2(s)</script><h3 id="时移"><a href="#时移" class="headerlink" title="时移"></a>时移</h3><p>若：</p><script type="math/tex; mode=display">L[f(t)]=F(s)</script><p>有：</p><script type="math/tex; mode=display">L[f(t-t_0)]=F(s)e^{-st_0}</script><h3 id="频移"><a href="#频移" class="headerlink" title="频移"></a>频移</h3><p>若：</p><script type="math/tex; mode=display">L[f(t)]=F(s)</script><p>有：</p><script type="math/tex; mode=display">L[f(t)e^{-\alpha t}]=F(s+\alpha)</script><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>若：</p><script type="math/tex; mode=display">L[f(t)]=F(s)</script><p>有：</p><script type="math/tex; mode=display">L[f(at)]=\frac{1}{a}F(\frac{s}{a}), a>0</script><p><em>如果同时时移和缩放：</em></p><script type="math/tex; mode=display">L[f(at-b)u(at-b)]=\frac{1}{a}F(\frac{s}{a})e^{-s\frac{b}{a}}</script><h3 id="时域微分（一重和二重必记）"><a href="#时域微分（一重和二重必记）" class="headerlink" title="时域微分（一重和二重必记）"></a>时域微分（一重和二重必记）</h3><p>一重</p><script type="math/tex; mode=display">L\bigg[\frac{df(t)}{dt}\bigg]=sF(s)-f(0_-)</script><p>二重</p><script type="math/tex; mode=display">L\bigg[\frac{df^2(t)}{dt}\bigg]=s^2F(s)-sf(0_-)-sf^{'}(0_-)</script><p>通式</p><script type="math/tex; mode=display">L\bigg[\frac{df^n(t)}{dt}\bigg]=s^nF(s)-\sum ^{n-1}_{r=0}s^{n-r-1}f^{r}(0_-)</script><h3 id="初值定理（时域趋近于0时的s域）"><a href="#初值定理（时域趋近于0时的s域）" class="headerlink" title="初值定理（时域趋近于0时的s域）"></a>初值定理（时域趋近于0时的s域）</h3><script type="math/tex; mode=display">\lim_{t\rarr0^+}f(t)=f(0_+)=\lim_{s\rarr\infty}sF(s)</script><h3 id="终值定理（时域趋近于无穷时的s域）"><a href="#终值定理（时域趋近于无穷时的s域）" class="headerlink" title="终值定理（时域趋近于无穷时的s域）"></a>终值定理（时域趋近于无穷时的s域）</h3><script type="math/tex; mode=display">\lim_{t\rarr \infty}f(t)=\lim_{s\rarr0}sF(s)</script><h3 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h3><script type="math/tex; mode=display">L[f_1(t)*f_2(t)]=F_1(s)\cdot F_2(s)</script><h3 id="s域微分"><a href="#s域微分" class="headerlink" title="s域微分"></a>s域微分</h3><script type="math/tex; mode=display">L[t^nf(t)]=(-1)^n\frac{d^nF(s)}{ds^n}</script><h3 id="s域积分"><a href="#s域积分" class="headerlink" title="s域积分"></a>s域积分</h3><script type="math/tex; mode=display">L\bigg[\frac{f(t)}{t}\bigg]=\int_{s}^{\infty}F(s)ds</script><h1 id="拉普拉斯反变换"><a href="#拉普拉斯反变换" class="headerlink" title="拉普拉斯反变换"></a>拉普拉斯反变换</h1><h2 id="变换的两种方法"><a href="#变换的两种方法" class="headerlink" title="变换的两种方法"></a>变换的两种方法</h2><p>要从F(s)变回f(t)，通常来说有两种方法：</p><ul><li>部分分式展开法</li><li>留数定理计算：留数定理指出，如果一个函数在某个点处有一个孤立奇点（例如拉普拉斯变换里面的极点），那么该函数在该点的留数就是拉普拉斯反变换的系数。因此，通过计算其所有极点的留数，即可求得拉普拉斯反变换表达式。</li></ul><p>正如前面提及，拉普拉斯变换常用变换对进行计算，将f(t)或F(s)往变换对上凑，以此来简便计算实现变换。而部分分式展开法就是为此而设计的，该课程仅介绍该方法。</p><p>下面是常用的拉普拉斯变换对：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/3695f24fdd864ef5a57ac31601b2168b.png" alt="img"></p><h2 id="部分分式展开法"><a href="#部分分式展开法" class="headerlink" title="部分分式展开法"></a>部分分式展开法</h2><p>对于任意一个式子，都可以写成分数的形式，无论是真分数还是假分数，总之它是可以的。也就是说，我们可以把F(s)拆分成分母和分子两部分</p><script type="math/tex; mode=display">F(s)=\frac{A(s)}{B(s)}=\frac{a_ms^m+a_{m-1}s^{m-1}+...+a_{1}s+a_0}{b_ns^n+b_{n-1}s^{n-1}+...+b_{1}s+b_0}</script><h3 id="F-s-为真分式"><a href="#F-s-为真分式" class="headerlink" title="F(s)为真分式"></a>F(s)为真分式</h3><p>若F(s)为真分式，即，其分子的次数低于分母的次数，那么可作如下处理：</p><p>$B(s)$ 这一组多项式可以被因式分解<em>（因式分解就是：多项式$3x^2-2x-1 = (3x+1)(x-1)$）</em></p><p>因此F(s)可以被写成：</p><script type="math/tex; mode=display">F(s)=\frac{A(s)}{(s-p_1)(s-p_2)...(s-p_n)}</script>]]></content>
      
      
      <categories>
          
          <category> 大二下 </category>
          
          <category> 信号与系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟信号分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅思常用短语</title>
      <link href="/posts/fea3ad7c.html"/>
      <url>/posts/fea3ad7c.html</url>
      
        <content type="html"><![CDATA[<h1 id="锻炼身体"><a href="#锻炼身体" class="headerlink" title="锻炼身体"></a>锻炼身体</h1><ul><li>Intense exercise 剧烈的运动</li></ul><h1 id="传统文化"><a href="#传统文化" class="headerlink" title="传统文化"></a>传统文化</h1><h1 id="节假日和聚会"><a href="#节假日和聚会" class="headerlink" title="节假日和聚会"></a>节假日和聚会</h1><h1 id="自然环境"><a href="#自然环境" class="headerlink" title="自然环境"></a>自然环境</h1><ul><li>an oasis of calm in the midst of urban chaos 城市中的平静绿洲   (midst /mɪdst/ 在……当中 n.)；（chaos /ˈkeɪɒs/ 混乱 n.）；</li><li>Hustle and bustle 熙熙攘攘，城市的喧嚣</li><li>provide visual appeal 提供视觉吸引力（常用于描述观赏性植物）</li><li>symphony of birdsong 鸟鸣的交响曲 （symphony /ˈsɪmfəni/ 交响曲 n.）</li><li>become one with nature 融入为自然的一员</li><li>planting flowers = gardening </li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 雅思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代通信网络-LC1-Overview</title>
      <link href="/posts/cfa858d3.html"/>
      <url>/posts/cfa858d3.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>本节对应参考书章节CH1</p></div><h1 id="三个时代"><a href="#三个时代" class="headerlink" title="三个时代"></a>三个时代</h1><h2 id="三个时代-1"><a href="#三个时代-1" class="headerlink" title="三个时代"></a>三个时代</h2><p>（这一部分讲了2个星期 -&gt; _ -&gt;）</p><h3 id="横向对比"><a href="#横向对比" class="headerlink" title="横向对比"></a>横向对比</h3><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">Generation-1</th><th style="text-align:center">Generation-2</th><th style="text-align:center">Generation-3</th></tr></thead><tbody><tr><td>描述</td><td style="text-align:center">仅又很少的终端，能够接入网络的用户有限。采用模拟信号，Qos不太好</td><td style="text-align:center">终端的价格开始逐渐下降（经历了一段时间才降下来），用户可以承担。但服务的费用很高，用户安装了终端却不舍得用。开始采用数字信号。在技术层面遇到了频率容量(capacity) 和 交移 (handover) 问题</td><td style="text-align:center">传统电信业务的资费下降，用户可以承受。要继续扩大市场就需要发展更多的服务。</td></tr><tr><td>关注的技术</td><td style="text-align:center">Transmission</td><td style="text-align:center">Switching</td><td style="text-align:center">Soft-switch</td></tr><tr><td>关键词</td><td style="text-align:center">Reachability</td><td style="text-align:center">Accessibility</td><td style="text-align:center">Realizability</td></tr><tr><td>拓补结构</td><td style="text-align:center">mesh</td><td style="text-align:center">star</td><td style="text-align:center">hybrid (mesh + star)</td></tr></tbody></table></div><h3 id="第二时代存在的两个问题的解释"><a href="#第二时代存在的两个问题的解释" class="headerlink" title="第二时代存在的两个问题的解释"></a>第二时代存在的两个问题的解释</h3><ul><li>Handover:</li></ul><p>当你处于两个基站的覆盖交界地带时，在基站与基站间的切换存在问题。这个在2G的网络网络技术基础上无法解决。</p><ul><li>Capacity</li></ul><p>相同频率间存在干扰，可使用的频段容量不足，一旦遇到人员密集区域，网络会直接被拖崩溃，这是第二阶段衍生至第三阶段的关键原因。为解决这个问题，产生了SDMA (Space Division Multiple Access, 空分复用) 技术</p><h3 id="第三时代的网络拓补"><a href="#第三时代的网络拓补" class="headerlink" title="第三时代的网络拓补"></a>第三时代的网络拓补</h3><p>正如第三个阶段中 hybrid 这个拓补结构所言，在第三个时代中传输网络被分为了接入网（Access Network, AN）和骨干网（Core Network, CN）。</p><h3 id="通信发展——性能和经济的平衡"><a href="#通信发展——性能和经济的平衡" class="headerlink" title="通信发展——性能和经济的平衡"></a>通信发展——性能和经济的平衡</h3><ul><li>在第一个时代，节点之间的交换能力不强，为了保证可达性，采用mesh拓补提高性能。纵然mesh部署成本高，最开始的用户有点，并未产生很大问题。</li><li>在第二个时代，用户数量开始增长，mesh拓补的成本升高。为了提高可接入性，网络主要使用star拓补。</li><li>第三个时代，业务多样化发展，通信用户众多。为了保证用户可接入性，用户链接使用star拓补，其余网络使用可靠性更高的其他混合拓补方式。</li></ul><h1 id="广域网（Wide-Area-Networks-WAN）"><a href="#广域网（Wide-Area-Networks-WAN）" class="headerlink" title="广域网（Wide Area Networks WAN）"></a>广域网（Wide Area Networks WAN）</h1><h2 id="基本交换技术（理论）"><a href="#基本交换技术（理论）" class="headerlink" title="基本交换技术（理论）"></a>基本交换技术（理论）</h2><p>交换技术有很多种，但是基本都基于<strong>电路交换</strong>和<strong>分组交换</strong>这两种。</p><h3 id="电路交换（circuit-switching）"><a href="#电路交换（circuit-switching）" class="headerlink" title="电路交换（circuit switching）"></a>电路交换（circuit switching）</h3><p>电路交换(circuit switching)是指使用专用物理通信路径连接通信终端的交换技术。连接建立开始时，通信系统分配给它的资源（通道、带宽、时隙、码字等等），通信活动的整个过程中，这个连接将始终占用着。电路交换总体可以分为这三步：</p><ol><li><strong>建立连接：</strong>分配通信资源。即在使用电路交换打电话前，必须先拨号请求<strong>建立连接</strong>。当被叫用户听到电话交换机送来的拨号音并摘机后，从主叫端建立连接，即一条<strong>专用的物理通路</strong>。线路一旦被分配，在未释放之前，其他站点将无法使用，即使某一时刻线路上并没有数据传输。</li><li><strong>通话：</strong>一直占用通信资源。</li><li><strong>释放连接：</strong>归还通信资源</li></ol><p>在要求数据按先后顺序且以恒定速率快速传输的情况下，使用电路交换是较为理想的选择。因此，当传输实时数据时，诸如音频和视频；或当服务质量（QOS）要求较高时，通常使用电路交换网络。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240315145652897.png" alt="image-20240315145652897"></p><p>那么这个物理线路在实际电话通信上是如何体现的呢？以TDM举例，就是分配一个 Ts 给你。例如上图电话①被分配了Ts1,那么在这个通信结束之前，Ts1永远属于它。</p><p>物理通路将不同的终端连接，这个物理通路又被分为Ts0-Ts31个逻辑信道，每个终端只从物理信道传输的信号中提取中属于自己的逻辑信道的东西。例如下图电话①提取Ts1，电话②提取Ts31，这就是”Logical channel dedicated on each link”的意思</p><p><strong>这种交换方式数据接收到的顺序和实时性都能保证</strong></p><p>我们成这样的交换”立即损失制”，意为无法发起一次服务，就无法通信</p><p><em>电路交换最常见的例子是电话网络，但时至今日，电话通信背后的交换技术已经更新了。</em></p><h3 id="分组交换（packet-switching）"><a href="#分组交换（packet-switching）" class="headerlink" title="分组交换（packet switching）"></a>分组交换（packet switching）</h3><p>分组交换（packet switching）是将数据打包成分组（Packets）进行传输、交换。数据包包含标头(Header)，和负载(Payload)。标头包含分组的基本信息，例如地址信息，管理信息等，类似于快递面单上  “收货地址：重庆邮电大学”（地址） 和 “买家要求保密发货”（控制信息等） ；负载即是数据，也就是包裹内”保密发货”的东西。</p><p>分组通过最优路径（取决于 路由算法）路由到目标。两个主机之间传送的分组不一定要沿着相同的路径传送，即，你的巨型手办可能头发一个包裹，身体发一个包裹，腿又是一个包裹，三个包裹沿着不同路径送过来。๑乛◡乛๑</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240315151346721.png" alt="image-20240315151346721"></p><p>在这样的交换技术下物理通路上的不同设备共享该通路上的资源，且仅当有通信发生时，才占用资源。</p><p>分组交换又可以拓展两种网络：虚电路(Virtual Ciruit)和数据报（Datagram）</p><p><em>这两种网络后续会结合协议讲路由时深入阐述，这里看个概念即可。</em></p><ul><li><strong>虚电路（VC）</strong>:属于一条虚电路的分组将在它的首部携带一个 VC 号。因为一条虚电路在每条链路上可能具有不同的VC号，所以每台中间路由器必须用一个新的VC号替代每个传输分组的VC号。 这个新的 VC 号从转发表中获得。VC连接下，会确保信息已经送达。</li><li><strong>数据报（Datagram）</strong>:在数据报网络中，每当一个端系统要发送分组时，它就为该分组加上目的地端系统的地址，然后将该分组推进网络中。数据报网络没有虚电路的概念，分组从源向目的地传输通过一系列路由器。路由器中的每个都使用该分组的目的地址来转发该分组。路由器有一个将目的地址映射到链路接口的转发表，当分组到达路由器时，该路由器使 用该分组的目的地址在该转发表中查找适当的输出链路接口。然后，路由器有意识地将该分 组向该输出链路接口转发。数据报连接下，数据是否送达不会被确认。</li></ul><p><strong>这种交换方式可以更高效地利用资源</strong></p><h3 id="电路交换和分组交换的对比"><a href="#电路交换和分组交换的对比" class="headerlink" title="电路交换和分组交换的对比"></a>电路交换和分组交换的对比</h3><ul><li>电路交换：一个连接双方的恒定的物理上的管道已经存在，只需要朝这个塞数据即可传达给对方。</li><li>分组交换：每一个数据包都需要检查它需要去哪里，该朝哪里转发，并为其选择路径。</li></ul><p><em>这也就是之前的电话都是按分钟计费（资源一直分配给你），但是网络却是按流量计费（有包才占用资源）的的原因</em></p><h2 id="典型的交换技术（实际）-了解"><a href="#典型的交换技术（实际）-了解" class="headerlink" title="典型的交换技术（实际）(了解)"></a>典型的交换技术（实际）(了解)</h2><h3 id="帧中继（frame-relay）"><a href="#帧中继（frame-relay）" class="headerlink" title="帧中继（frame relay）"></a>帧中继（frame relay）</h3><p>帧中继（frame relay）采用的是分组交换（Packet Switching），它将数据放在可变大小的“帧”内。帧除分组交换必须的地址外，还包含一些纠错信息。网络在传送过程中对帧结构、传送差错等情况进行检查，同时，通过对帧中地址段（DLCI）识别，实现用户信息的统计复用。</p><ul><li>其可以在在一对一或者一对多的应用中快速而低廉的传输数位信息。</li><li>它可以使用于语音、数据通信。既可用于局域网（LAN）也可用于广域网（WAN）的通信（这个技术现在已经淘汰了）</li></ul><h3 id="异步传输模式（-Asynchronous-Transfer-Mode-ATM）"><a href="#异步传输模式（-Asynchronous-Transfer-Mode-ATM）" class="headerlink" title="异步传输模式（ Asynchronous Transfer Mode, ATM）"></a>异步传输模式（ Asynchronous Transfer Mode, ATM）</h3><div class="note warning flat"><p>ATM这里是重点，将在后面章节里面详细介绍。这里只需要知道有这个存在就行。</p></div><p>异步传输模式（ATM）是指一种采用异步时分复用，是<strong>电路交换和分组交换</strong>的融合，以<strong>信元</strong>（cell）为单位的通信方式，信元在这里就对应分组交换中的packet. </p><p>这个技术目前只在部分私有部署网络中使用。（而且使用原因是重新部署需要成本）</p><h2 id="面向连接和面向无连接"><a href="#面向连接和面向无连接" class="headerlink" title="面向连接和面向无连接"></a>面向连接和面向无连接</h2><p>在后续的学习中，还会看到面向连接和面向无连接两种类型的协议。面向连接和面向无连接的核心区别是发送数据之前是否需要建立连接（也就是和对方打个招呼先，对方会话了再继续通话），现在听起来似乎有点抽象，不妨在学习到了TCP/UDP的时候再回过头来看看它。比较严格地定义来说，它们的区别在于：</p><ul><li>面向连接（connection-oriented）：在发送之前需要先建立连接（知道对方存在并准备好接收），再进行传输。在通信完成时，需要断开连接。</li><li>面向无连接（connectionless）：不需要和对方建立连接（无需知道对方是否存在），直接在网络上传输数据。网络尽最大可能保证数据到达。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三下 </category>
          
          <category> 现代通信网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1-Filter</title>
      <link href="/posts/a7a0e2d0.html"/>
      <url>/posts/a7a0e2d0.html</url>
      
        <content type="html"><![CDATA[<h1 id="滤波器基本参数"><a href="#滤波器基本参数" class="headerlink" title="滤波器基本参数"></a>滤波器基本参数</h1><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226174510849.png" alt="image-20240226174510849"></p><p>上图展示了滤波器通带、阻带、过渡带。</p><h3 id="特征角频率和特征频率-f-0-f-n-pole-frequency-nature-frequency"><a href="#特征角频率和特征频率-f-0-f-n-pole-frequency-nature-frequency" class="headerlink" title="特征角频率和特征频率($f_0/f_n$) pole frequency/ nature frequency"></a>特征角频率和特征频率($f_0/f_n$) pole frequency/ nature frequency</h3><p>它只与滤波用的电阻和电容元件的参数有关，通常对于带通(带阻）滤波器，称为带通(带阻）滤波器的中心角频率或中心频率$f_0$，是通带(阻带）内电压增益最大(最小）点的频率。<br>滤波器的截止频率（$f_c$）cut-off frequency</p><h3 id="滤波器的截止频率（-f-c-）cut-off-frequency"><a href="#滤波器的截止频率（-f-c-）cut-off-frequency" class="headerlink" title="滤波器的截止频率（$f_c$）cut-off frequency"></a>滤波器的截止频率（$f_c$）cut-off frequency</h3><p>一般地是指幅度响应比通带低3 dB时的频率。无论是什么样的滤波器，截止频率一般都是指-3db的位置，也就是说从滤波器的通带的增益算起，下降-3db的位置。</p><p><strong>Chenqiao原话：但是一些文献里面认为$f_0$就是截止频率$ f_c $，截止频率不一定需要在-3dB point。这里需要根据实际情况讨论。</strong></p><hr><h1 id="无源滤波器-Passive-Filter"><a href="#无源滤波器-Passive-Filter" class="headerlink" title="无源滤波器(Passive Filter)"></a>无源滤波器(Passive Filter)</h1><p>电容、电抗和阻抗的关系：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226174753964.png" alt="image-20240226174753964"></p><p>所有滤波器的公式都是将电容和电抗表现成阻抗的形式，代入电路得出的。</p><h2 id="一阶无源滤波器"><a href="#一阶无源滤波器" class="headerlink" title="一阶无源滤波器"></a>一阶无源滤波器</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226174630689.png" alt="image-20240226174630689"></p><h3 id="低通"><a href="#低通" class="headerlink" title="低通:"></a>低通:</h3><p>一阶低通滤波器：输出的电压等于夸在电容两端的电压，输出信号的相位</p><script type="math/tex; mode=display">\psi=\phi_0-arctan⁡(R/X_C )=\phi_0-arctan⁡(2πfRC)。</script><p><strong>因此，当到达截止频率$X_C=R$时，相位移动为-45°</strong></p><h3 id="高通："><a href="#高通：" class="headerlink" title="高通："></a>高通：</h3><p>输出的电压等于夸在电阻两端的电压，相位：</p><script type="math/tex; mode=display">\psi=\phi_0+π/2-arctan⁡(2πfRC)</script><p><strong>因此，当到达截止频率$X_C=R$时，相位移动为+45°</strong></p><h2 id="二阶滤波器"><a href="#二阶滤波器" class="headerlink" title="二阶滤波器"></a>二阶滤波器</h2><p>对于高阶滤波器，可以看成多个一阶串联，因此相位移动是叠加的。例如二阶高通滤波器截止频率的相位移动就是+90°</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175143051.png" alt="image-20240226175143051"></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175159970.png" alt="image-20240226175159970"></p><h3 id="增益下降slope比较"><a href="#增益下降slope比较" class="headerlink" title="增益下降slope比较"></a>增益下降slope比较</h3><p>二阶滤波器可以看做两个一阶滤波器串联。因此假设对于某一频率，一个二阶滤波器由两个同样的一阶滤波器串联而成。一阶滤波器的slope=-20dB/Decade, 那么二阶滤波器slope就是一阶滤波器的平方也就是-40dB/ Decade. (Decade=f/fc(3dB))</p><p>对于二阶带通滤波器而言，两端的slope是两个独立的一阶滤波器，因此还是-20dB/ Decade.</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175308020.png" alt="image-20240226175308020"></p><hr><h1 id="有源滤波器-Active-Filter"><a href="#有源滤波器-Active-Filter" class="headerlink" title="有源滤波器(Active Filter)"></a>有源滤波器(Active Filter)</h1><p>有源滤波器带有运放，因此可以实现增益大于1（0dB）。且提供更好的输入输出阻抗。</p><h2 id="有源低通滤波器"><a href="#有源低通滤波器" class="headerlink" title="有源低通滤波器"></a>有源低通滤波器</h2><table>    <tr>        <td><center><img src= "https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175432892.png"></center></td>            <td><center><img src= "https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175447274.png"></center></td></table><p>其截止频率$f=1/2πRC$, </p><p>增益$DC Gain=(1+R_2/R_1 )$,</p><p>如果把低通滤波器的电阻放在反馈电阻上，同样能通过影响不同频率的放大倍数进行滤波。这样可以得到更好的输入阻抗。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175650304.png" alt="image-20240226175650304"></p><p>一阶有源HPF只需要把电容更换位置，放在信号输入端即可（也就是R1前面）。</p><h2 id="有源高通滤波器-二阶"><a href="#有源高通滤波器-二阶" class="headerlink" title="有源高通滤波器(二阶)"></a><strong>有源高通滤波器(二阶)</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175821801.png" alt="image-20240226175821801"></p><p>同无源滤波器分析的一样，有源一阶滤波器的slope斜率为-20dB/Decade, 二阶为-40dB/Decade.</p><h2 id="有源带通滤波器-二阶"><a href="#有源带通滤波器-二阶" class="headerlink" title="有源带通滤波器(二阶)"></a><strong>有源带通滤波器(二阶)</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175903538.png" alt="image-20240226175903538"></p><h2 id="有源带阻滤波器"><a href="#有源带阻滤波器" class="headerlink" title="有源带阻滤波器"></a><strong>有源带阻滤波器</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175930196.png" alt="image-20240226175930196"></p><p>相当于是一个有源加法器，输入信号为一个高通的输出和一个低通的输出。增益-频率响应为高通和低通的叠加。<br>有源的二阶带通和带阻中心频率计算公式都是</p><script type="math/tex; mode=display">f_0=\sqrt{(f_L⋅f_H)}</script><p>陷波滤波器(Notch Filter) 是带阻滤波器的一种，只不过阻带很窄。（好像不是重点，没考过）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226180019446.png" alt="image-20240226180019446"></p><hr><h1 id="Sallen-Key-滤波器（五星级）"><a href="#Sallen-Key-滤波器（五星级）" class="headerlink" title="Sallen-Key 滤波器（五星级）"></a>Sallen-Key 滤波器（五星级）</h1><p>Sallen-key是设计有源滤波器设计的一种拓扑结构，VCVS（Voltage-controlled voltage-source）滤波器的变种，由麻省理工学院林肯实验室的R. P. Sallen and E. L. Key 在1955所提出。</p><h2 id="Q-Factor"><a href="#Q-Factor" class="headerlink" title="Q Factor"></a>Q Factor</h2><p>用频率定义Q：电路发生谐振的频率 ω0 称为谐振频率谐振峰两边 I ＝ （1/2） Im 处的频率值ω2j 和 ω1j 之间宽度定义为通频带宽度 BW，衡量一个谐振器在电路中性能的好坏。常用品质因数 Q ＝ ω0/ω2j －ω1j 来描述，Q 的物理意义是在谐振频率ω0 附近将具有更强的频率响应；对于偏离 ω0 较远的频率，则响应很弱或不响</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226180243570.png" alt="image-20240226180243570"></p><p>对低通和高通滤波器而言,<strong>Q值等于滤波器电路电压增益（截止频率对应处的增益）模$|A_u |$与通带增益的模之比 $|A_{up}|$；对带通(带阻）滤波器而言，Q值等于中心角频率与通带(阻带）宽度bw之比。</strong></p><h2 id="S-K滤波器的整体模型"><a href="#S-K滤波器的整体模型" class="headerlink" title="S-K滤波器的整体模型"></a>S-K滤波器的整体模型</h2><p>图中电阻根据低通、带通、高通不同要求替换成电容。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226180316035.png" alt="image-20240226180316035"></p><p>计算通式为：</p><script type="math/tex; mode=display">\frac{V_{out}}{V_{in}}=\frac{Z_3\times Z_4}{Z_1\times Z_2 + Z_2\times Z_3 +Z_3 \times Z_4 +Z_1 \times Z_3}</script><h2 id="S-K低通-amp-高通滤波器"><a href="#S-K低通-amp-高通滤波器" class="headerlink" title="S-K低通&amp;高通滤波器"></a>S-K低通&amp;高通滤波器</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226180514237.png" alt="image-20240226180514237"></p><p>以低通滤波器为例：</p><script type="math/tex; mode=display">Z_1=R_1,Z_2=R_2,Z_3=\frac{1}{(sC_1 )},Z_4=\frac{1}{(sC_2 )}, 其中 s=jω</script><script type="math/tex; mode=display">A=\frac{\frac{1}{sC_1}\times \frac{1}{sC_2}}{R_1R_2+R_2\frac{1}{sC_1}+\frac{1}{sC_1}\times \frac{1}{sC_2}+R_1\frac{1}{sC_1}}</script><script type="math/tex; mode=display">=  \frac {1}{R_ {1}R_ {2}C_ {1}C_ {2}s^ {2}+R_ {2}C_ {2}s+1+R_ {1}C_ {2}s}</script><script type="math/tex; mode=display">=  \frac {1}{R_ {1}R_ {2}C_ {1}C_ {2}s^ {2}+C_ {2}s(R_ {1}+R_ {2})+1}</script><h3 id="特征频率"><a href="#特征频率" class="headerlink" title="特征频率:"></a>特征频率:</h3><p>（有时候认为$f_n=f_c$，$f_c$不在-3dB点，所以截止频率也是这个，具体要看题目）</p><script type="math/tex; mode=display">f_n=\frac{1}{(2\pi\sqrt{(R_1 R_2 C_1 C_2 )}}</script><h3 id="品质因子Q："><a href="#品质因子Q：" class="headerlink" title="品质因子Q："></a>品质因子Q：</h3><script type="math/tex; mode=display">Q=\frac{1}{R_1+R_2}(\sqrt{R_1 R_2 \frac{C_1}{C_2} })</script><p>当$R_1=R_2, C_1=C_2$ 时，Q 有：</p><script type="math/tex; mode=display">Q=\frac{1}{3-A}</script><p>其中A为放大电路的放大倍数。</p><h2 id="设计S-K滤波器的例题"><a href="#设计S-K滤波器的例题" class="headerlink" title="设计S-K滤波器的例题"></a>设计S-K滤波器的例题</h2><p>设计一个具有以下特性的二阶高通Sallen-Key滤波器电路：$f_C=200Hz，Q=3$。</p><p>解：</p><p>为简化计算，认为$R_1=R_2,C_1=C_2$</p><p>$f_c=1/2πRC=200Hz$, 选择c=100nF继续计算， R=7957Ω。（这道题认为$f_c=f_0$，PPT上举例原题）</p><script type="math/tex; mode=display">Q=3=\frac{1}{3-A},A=\frac{3Q-1}{Q}=2.667</script><p>所以放大电阻分别取10K和6K</p><h2 id="设计S-K滤波器生成类型的判定："><a href="#设计S-K滤波器生成类型的判定：" class="headerlink" title="设计S-K滤波器生成类型的判定："></a>设计S-K滤波器生成类型的判定：</h2><p>滤波器的类型是看 $\omega_0$ 处有没有bump来判定的，因此使用品质因素Q来判定</p><p>巴特沃夫滤波器没有bump,因此Q<1贝塞尔滤波器Q≈1切比雪夫滤波器Q>1</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226181523677.png" alt="image-20240226181523677"></p>]]></content>
      
      
      <categories>
          
          <category> 大三上 </category>
          
          <category> 电子系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1-CH4-数字的表达和算数电路</title>
      <link href="/posts/202924f0.html"/>
      <url>/posts/202924f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h1><h2 id="半加法器"><a href="#半加法器" class="headerlink" title="半加法器"></a>半加法器</h2><p>半加法器接受两个输入：$x_1,x_2$ 并产生本位和进位两个输出。半加法器的真值表和实现电路如下图所示</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209031411970.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209031506622.png"></center></td>    </tr></table><h2 id="全加法器"><a href="#全加法器" class="headerlink" title="全加法器"></a>全加法器</h2><p>全加法器：输入$x_1,x_2,c$,三位（其中c表示上一位到这一位的进位）计算三位相加产生本位和进位。真值表和电路如下</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209031737291.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209031755498.png"></center></td>    </tr></table><h2 id="串行进位全加法器（Ripple-carry-Adder）"><a href="#串行进位全加法器（Ripple-carry-Adder）" class="headerlink" title="串行进位全加法器（Ripple-carry Adder）"></a>串行进位全加法器（Ripple-carry Adder）</h2><p>讲上述全加法器进行串联，前一个的进位输出连接至下一个的进位输入。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/clip_image002.gif" alt="图表, 箱线图  描述已自动生成" style="zoom:150%;" /></p><div class="note info simple"><p>原码（True form）反码(1’s complement ) 补码(2’s complement) 在 计算机组成与接口 中有更详细的介绍，此处略去。</p></div><h1 id="加法（减法）单元"><a href="#加法（减法）单元" class="headerlink" title="加法（减法）单元"></a>加法（减法）单元</h1><p>在计算机中，设计专门的减法电路划不来，因此使用补码+加法电路来计算减法。补码的求法是原码取反加一，因此设计如下的计算模块</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209032156159.png" alt="image-20240209032156159"></p><ul><li>当Add/Sub control 为0时，$y_i=y_i\oplus0=y_i$, 同时输入的基础进位$c_0$等于0。此时是正常调用全加法器计算加法。</li><li>当Add/Sub control为1时，$y_i=y_i\oplus1=\overline y_i$,同时$c_0=1$。相当于把序列$y$取反后加1（这个加一就是基础进位$c_0$加上来的）算成了补码的形式。故调用全加法器计算减法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三上 </category>
          
          <category> 数字电路设计与可靠性工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1-CH5-组合电路-构建快</title>
      <link href="/posts/5cb49984.html"/>
      <url>/posts/5cb49984.html</url>
      
        <content type="html"><![CDATA[<h1 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h1><p>多路复用器可以使用逻辑门制造，也可以使用Transition Gate 制造。一个多路复用器具有n个输入，那么就需要$log_{2}{n}$路选择信号。考试中最多出现4 to 1多路复用器。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209032918533.png" alt="image-20240209032918533"></p><p>例题：2x2交叉选择器</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209032958296.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209033003100.png"></center></td>    </tr></table><h2 id="使用多路复用器构建逻辑函数-五星级中的五星级"><a href="#使用多路复用器构建逻辑函数-五星级中的五星级" class="headerlink" title="使用多路复用器构建逻辑函数 五星级中的五星级"></a>使用多路复用器构建逻辑函数 <em>五星级中的五星级</em></h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209033354986.png" alt="image-20240209033354986"></p><p>如上图这个情况，使用$w_1,w_2$做为选择信号，可以把输出分为4个case：</p><ul><li>Case 0: $w_1=0,w_2=0$, 输出为0</li><li>Case 1: $w_1=0,w_2=1$, 输出等于$w_3$</li><li>Case 3: $w_1=1,w_2=0$,输出等于$w_3$</li><li>Case 4: $w_1=1,w_2=1$,输出等于1</li></ul><p>这样就实现了用多路复用器来实现基础的逻辑组合。除了简单的电路外，还可以使用逻辑门的输出和多路复用器进行组合，实现更复杂的电路。</p><p><strong>香农拓展定理（Shannon’s Expansion Theorem）</strong></p><p>香农拓展定理的核心理念是：对于一个Boolean function, 可以把它写为分解为$w_1 (…)+ \overline w_1 (…)$，也就是$w_1$和$\overline w_1$下的两种情况。这里的$w_1$为称为辅因子(cofactor). 那么对于一个有$w_n$项的布尔函数，把$w_1$作为辅因子，可以写成如下表达式：</p><script type="math/tex; mode=display">f(  w_ {1}  ,  w_ {2}  ,  \cdots  ,  w_ {n}  )=  \overline {w}_ {1}   \cdot  f(0,  w_ {2}  ,  \cdots  ,  w_ {n}  )+  w_ {1}   \cdot  f(1,  w_ {2}  ,  \cdots  ,  w_ {n}  )</script><p>几个分解的例题：</p><ul><li><strong>例1：</strong></li></ul><script type="math/tex; mode=display">f(  w_ {1}  ,  w_ {2}  ,  w_ {3}  )=  w_ {1}   w_ {2}  +  w_ {1}   w_ {3}  +  w_ {2}   w_ {3}</script><p>可分解为：</p><script type="math/tex; mode=display">f=  w_ {1}   w_ {2}  +  w_ {1}   w_ {3}  +(  w_ {1}  +  \overline {w_ {1}}  )  w_ {2}   w_ {3}  =  w_ {1}  (  w_ {2}  +  w_ {3}  +  w_ {2}   w_ {3}  )+  \overline {w_ {1}}  (  w_ {2}   w_ {3}  )=  w_ {1}  (  w_ {2}  +  w_ {3}  )+  \overline {w_ {1}}  (  w_ {2}   w_ {3}  )</script><ul><li><strong>例2</strong></li></ul><script type="math/tex; mode=display">f=  w_ {1}   \oplus   w_ {2}   \oplus   w_ {3}</script><p>可分解为：</p><script type="math/tex; mode=display">f=\overline w_1(w_ {2}   \oplus   w_ {3}  )+  w_ {1}  (  w_ {2}   \oplus   w_ {3}  )</script><ul><li>例3</li></ul><script type="math/tex; mode=display">f=  \overline {w}_ {1}   \overline {w}_ {3}  +  w_ {1}   w_ {2}  +  w_ {1}   w_ {3}</script><p>使用$w_1$作cofactor：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209034518973.png" alt="image-20240209034518973"></p><p>使用$w_1w_2$做cofactor：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209034545314.png" alt="image-20240209034545314"></p><hr><h1 id="解码器（decoders）"><a href="#解码器（decoders）" class="headerlink" title="解码器（decoders）"></a>解码器（decoders）</h1><p>解码器电路接受$n$个输入，产生$2^n$个输出。其作用是将收到的数据映射到对应的线路上去。举个例子，假设一个2bit decoder受到的数据是11，对应十进制是3（第四个数，从0开始数），那么它会把输出的第4条线置高电平。下面是一个2bit解码器的例子</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209034839045.png" alt="image-20240209034839045"></p><p>使用多路复用器的思路，也可以用两个2 to 4 decoder 合成一个 3 to 8 decoder</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209034926916.png" alt="image-20240209034926916"></p><p>解码器最重要的应用之一是用于存储信息的存储块寻址：</p><p>输入想要访问的存储单元的地址，解码器即可将那一行使能（此处可以b站了解一下NAND闪存或者固态硬盘工作原理）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209035138132.png" alt="image-20240209035138132"></p><hr><h1 id="多路分解器（Demultiplexer）"><a href="#多路分解器（Demultiplexer）" class="headerlink" title="多路分解器（Demultiplexer）"></a>多路分解器（Demultiplexer）</h1><p>Multiplexer使用不同switch输入组合选择输出不同的单条线路。Demultiplexer使用不同的Switch输入组合将单条线路输出到在多个不同的数据输出上。</p><p>Demultiplexer 可以用 Decoder实现，下图就是个例子。右图$w_1 w_2$被用作Switch 信号，En被用作输入信号。$w_1 w_2$控制En信号在那条路上被输出。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209035039471.png" alt="image-20240209035039471"></p><hr><h1 id="编码器-（Encoder）"><a href="#编码器-（Encoder）" class="headerlink" title="编码器 （Encoder）"></a>编码器 （Encoder）</h1><p>编码器是Decoder的逆过程，它接受$2^n$条输入，产生n个输出。n个输出呈现二进制数，用于表示是哪一条输入。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209035340281.png" alt="image-20240209035340281"></p><hr><h1 id="译码器（Code-Converter）"><a href="#译码器（Code-Converter）" class="headerlink" title="译码器（Code Converter）"></a>译码器（Code Converter）</h1><p>把输入翻译成特定的输出。例如用来点亮7为数码管的code converter, 会把二进制数字输入转化成对应的pattern输出。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/clip_image002.jpg" alt="img"></p><hr><h1 id="算术比较电路"><a href="#算术比较电路" class="headerlink" title="算术比较电路"></a>算术比较电路</h1><p>算术比较电路接受两个二进制数输入，记为A和B，比较A和B大小后输出A&gt;B,A=B,A&lt;B三个输出。</p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209035554476.png" alt="image-20240209035554476"></p><p>在这个例子中，定义一个中间信号$i_k=\overline {a_k\oplus b_k}$</p><p>则：A=B可表示为：$AeqB=i_3i_2i_1i_0$，A&gt;B可表示为$AgtB= a_ {3}   \overline {b}_ {3}  +  i_ {3}   a_ {2}   \overline {b}_ {2}  +  i_ {3}   i_ {2}   a_ {1}   \overline {b}_ {1}  +  i_ {3}   i_ {2}   i_ {1}   a_ {0}   \overline {b}_ {0}$ ， A&lt;B可表示为：$AltB=\overline {AeqB+AgtB}$</p><p>算术比较电路也可被分为两类：有符号的，无符号的。</p><ul><li>有符号的：认为输入的数据是以补码的形式输入的，第一位为符号位，这类算术比较电路通常使用加法电路来比较大小</li><li>无符号的：认为输入数据都是原码格式，没有符号位，这类算术比较电路通常直接比较，上图就是无符号的例子</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大三上 </category>
          
          <category> 数字电路设计与可靠性工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32的UART通信(Register)</title>
      <link href="/posts/7c92a281.html"/>
      <url>/posts/7c92a281.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本工作原理-F4系列"><a href="#基本工作原理-F4系列" class="headerlink" title="基本工作原理(F4系列)"></a>基本工作原理(F4系列)</h1><p>F4的USART模块支持可编程字长、自定义波特率、单线半双工模式（RX，TX使用一条线，半双工收发）、唤醒MCU、可编程的停止位长度、可启用/禁用/设置模式的就校验位。其硬件模块如下</p><p>F4系列的USART模块还支持IRDA和LIN，这里不会详细介绍</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240205011104190.png" alt="image-20240205011104190"  /></p><p>USART硬件系统可以被拆分成如下几个重要部分：</p><p>控制初始化工作部分</p><ul><li>使能USART：由CR1寄存器UE位(bit13)进行控制，使能后USART模块才会开始工作，不用时失能减少功耗；</li><li>设置数据字长：F4系列支持8bit和9bit两种长度，通过对CR1寄存器M位(bit12)配置进行控制；</li><li>设置波特率：波特率生成器负责生成控制发送速率的时钟，由USART_BRR寄存器控制。</li><li>设置停止位长度：由CR2寄存器中bit[12:13]控制，支持0.5 / 1 / 1.5 / 2四种停止位长度</li><li>设置奇偶校验：CR1寄存器PCE位（bit10）控制。</li></ul><p>控制收发工作部分</p><ul><li>DR(数据寄存器)：用于寄存要发送的数据或者收到的数据。发送时，该寄存器内的值会被逐个读取至TDR，并通过移位寄存器逐个bit发送；接受时，RDR寄存器内的数值会逐个写入该寄存器。TDR和RDR寄存器用户不可交互，仅可以操作DR。</li><li>开始发送：当CR1寄存器中发送使能位（bit4）控制。当置 1 时，发送移位寄存器中的数据在 TX 引脚输出</li><li>在发送开始后，TDR寄存器内的数据会被传输到发送移位寄存器，开始自动传输。</li><li>在发送数据开始时，SCLK会产生时钟脉冲，以兼容同步通信。</li></ul><p>状态指示器部分</p><ul><li>TC(Transmission Complete)：当发送完成，且无新的数据被写入待发送时(即，TXE位为1，且没有新数据写入DR使得TXE置0)，TC位将会被置1表示发送完成；否则由硬件置0。该位可以CR1寄存器配置中断</li><li>TXE：DR寄存器和TDR寄存器均已完成数据交接，现数据在发送移位寄存起内准备发送；DR寄存器支持写入新的数据；<strong>TXE寄存器由硬件置位，超DR寄存器写入来清零</strong>。该位可由CR1寄存器配置中断。</li><li>RXNE：类似于TXE，用于指示接收输入已经传到RDR，接收移位寄存器可以接收下一帧数据。</li></ul><p>中断控制器部分</p><ul><li>中断使能分布在CR寄存器中，可在完成单次接收、完成单次发送、完成传输、出现错误、侦测到空闲等时候触发中断</li></ul><p>硬件流控部分</p><ul><li>nRTS：如果使能 RTS 流控制 (RTSE=1)，只要 USART 接收器准备好接收新数据，便会将 nRTS 变  为有效（输出低电平）。当接收寄存器已满时，会将 nRTS 变为无效（高电平）。</li><li>nCTS：如果使能 CTS 流控制 (CTSE=1)，则发送器会在发送下一帧前检查nCTS。如果 nCTS 有效（收到低电平），则会发送下一数据（假设数据已准备好发送，即 TXE=0）；否则不会进行发送。如果在发送过程中 nCTS 变为无效，则当前发送完成之后，发送器停止。</li></ul><h1 id="UART（F4系列）"><a href="#UART（F4系列）" class="headerlink" title="UART（F4系列）"></a>UART（F4系列）</h1><h2 id="计算波特率和波特率寄存器"><a href="#计算波特率和波特率寄存器" class="headerlink" title="计算波特率和波特率寄存器"></a>计算波特率和波特率寄存器</h2><p>在工作原理图的下方发送器时钟框图部分可以看出，串口时钟信号$f_{ck}$首先经过USARTDIV分频，然后再经过$8\times(2-OVER8)$分频产生，因此波特率计算公式如下：</p><script type="math/tex; mode=display">Baud=\frac{f_{ck}}{8\times(2-OVER8)\times USARTDIV}</script><p>其中USARTDIV这个常数是通过USART_BRR寄存器配置得到的，计算公式在左下角，这里面的OVER8是超采样的配置（通过USART_CR1寄存器配置，后续介绍），F1系列没有(F1系列默认16倍)。OVER8: “1”=8倍过采样； “0”=16倍过采样。</p><script type="math/tex; mode=display">USARTDIV=DIV\_Mantissa+(DIV\_Fraction/8\times(2-OVER8))</script><p>因此，在已知Baud时，可以算出USARTDIV，又可以根据USARTDIV算出配置USART_BRR寄存器的DIV_Mantissa和DIV_Fraction (整数和小数)部分的值。USART_BRR寄存器结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240205175018208.png" alt="image-20240205175018208"></p><p><strong>它本身有32位，但仅使用16位，高16位保持复位值（全0）。USART的整数部分写入15-4位，小数部分写入3-0位。当过采样设置为8倍（i.e., OVER8=1）时，小数仅使用2-0位，DIV_Fraction3 必须保持为0</strong></p><p>举个例子：要设置波特率为115200，OVER8=0, 串口总线频率$f_{ck}=72MHz$</p><script type="math/tex; mode=display">USARTDIV=\frac{72M}{16\times115200}=39.0625</script><script type="math/tex; mode=display">DIV\_Mantissa=39 (直接取整数部分即可)</script><script type="math/tex; mode=display">DIV\_Fraction=(USARTDIV-DIV\_Mantissa)\times16=0.625\times16=10</script><p>在计算DIV_Fraction部分时，计算出的结果不一定全部是整数，因此需要进行四舍五入。因为是以整形数据进行存储，所以计算出的结果会进行直接去小数操作。因此直接在DIV_Fraction计算值后面+0.5来进行四舍五入。</p><p>设置代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fck=72000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Baud=115200</span></span><br><span class="line"><span class="type">uint16_t</span> mantissa;</span><br><span class="line"><span class="type">uint16_t</span> fraction;</span><br><span class="line">mantissa=fck/(<span class="number">16</span>*Baud);</span><br><span class="line">fraction=(fck%(<span class="number">16</span>*Baud))*<span class="number">16</span>+<span class="number">0.5</span>;</span><br><span class="line">USART-&gt;BRR=(mantissa&lt;&lt;<span class="number">4</span>)+fraction;</span><br></pre></td></tr></table></figure><p>不难看出，因为小数部分进行了舍入操作，所以部分波特率会有误差。典型$f_{ck}$下设置波特率的误差在不同芯片的芯片手册中有详细介绍</p><h2 id="F4系列UART常用功能"><a href="#F4系列UART常用功能" class="headerlink" title="F4系列UART常用功能"></a>F4系列UART常用功能</h2><h3 id="奇偶校验控制"><a href="#奇偶校验控制" class="headerlink" title="奇偶校验控制"></a>奇偶校验控制</h3><p>通过配置CR1寄存器PCE和PS位，可控制奇偶校验使能和模式。启用奇偶校验后，会占用一个数据位填入奇偶校验位。假设数据字长设置为8bit，那么现在7bit是数据位，1bit是奇偶校验位。假设数据字长为9bit，那么8bit是数据位，1bit是就校验位。奇偶校验位填充在原MSB的位置。</p><h3 id="硬件流控制"><a href="#硬件流控制" class="headerlink" title="硬件流控制"></a>硬件流控制</h3><p>分别向 USART_CR3 寄存器中的 RTSE 位和 CTSE 位写入 1，可以分别使能 RTS 和 CTS 流  控制。</p><p>CTS：如果在发送数据时使  nCTS 输入无效，会在停止之前完成发送。如果使 nCTS 有效时数据已写入数据寄存器，则将延迟发送，直到 nCTS 有效。</p><p>RTS：只要 USART 接收器准备好接收新数据，便会将 nRTS 变  为有效（连接到低电平）。当接收寄存器已满时，会将 nRTS 变为无效，表明发送过程会在当前帧结束后停止。</p><h3 id="USART支持的中断事件"><a href="#USART支持的中断事件" class="headerlink" title="USART支持的中断事件"></a>USART支持的中断事件</h3><p>通过配置对应的使能寄存器，在以下事件产生时，可以触发USART中断。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206232412336.png" alt="image-20240206232412336"></p><h2 id="UART（不含USART-LIDAR-LIN）关键寄存器"><a href="#UART（不含USART-LIDAR-LIN）关键寄存器" class="headerlink" title="UART（不含USART,LIDAR,LIN）关键寄存器"></a>UART（不含USART,LIDAR,LIN）关键寄存器</h2><h3 id="状态寄存器（USART-SR）指示的状态"><a href="#状态寄存器（USART-SR）指示的状态" class="headerlink" title="状态寄存器（USART_SR）指示的状态"></a>状态寄存器（USART_SR）指示的状态</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206220951514.png" alt="image-20240206220951514"></p><ul><li><p><strong>位 9 CTS</strong>：CTS 标志 (CTS flag) </p><p>​    如果 CTSE 位置 1，当 nCTS 输入变换时，此位由硬件置 1。0：nCTS 状态线上未发生变化  1：nCTS 状态线上发生变化</p><p>​    通过软件将该位清零（通过向 该位中写入 0）。</p><p>​    如果 USART_CR3 寄存器中 CTSIE=1，则会生成中断。  （<em>注：F4系列UART4、5不适用</em>）</p></li><li><p><strong>位 7 TXE：</strong>发送数据寄存器为空 (Transmit data register empty) </p><p>​    当 TDR 寄存器的内容已传输到移位寄存器时，该位由硬件置 1。0：数据未传输到移位寄存器 1：数据传输到移位寄存器</p><p>​    如果 USART_CR1 寄存器  中 TXEIE 位 = 1，则会生成中断。</p><p>​    通过对 USART_DR 寄存器执行写入操作将该位清零。 </p></li><li><p><strong>位 6 TC</strong>：发送完成 (Transmission complete) </p><p>​    如果已完成对包含数据的帧的发送并且 TXE 置 1，则该位由硬件置 1。 0：传送未完成 1：传送已完成</p><p>​    如果 USART_CR1 寄存  器中 TCIE = 1，则会生成中断。</p><p>​    该位由软件序列清零（读取 USART_SR 寄存器，然后写入  USART_DR 寄存器）。TC 位也可以通过向该位写入‘0’来清零。建议仅在多缓冲区通信  时使用此清零序列。</p></li><li><p><strong>位 5 RXNE：</strong>读取数据寄存器不为空 (Read data register not empty) </p><p>​    当 RDR 移位寄存器的内容已传输到 USART_DR 寄存器时，该位由硬件置 1。0：未接收到数据 1：已准备好读取接收到的数据</p><p>​    如果  USART_CR1 寄存器中 RXNEIE = 1，则会生成中断。</p><p>​    通过对 USART_DR 寄存器执行读入  操作将该位清零。RXNE 标志也可以通过向该位写入零来清零。建议仅在多缓冲区通信时使  用此清零序列。 </p></li><li><p><strong>位 4 IDLE：</strong>检测到空闲线路 (IDLE line detected)</p><p>​     检测到空闲线路时，该位由硬件置 1。0：未检测到空闲线路 1：检测到空闲线路</p><p>​    如果 USART_CR1 寄存器中 IDLEIE = 1，则会生成中 断。</p><p>​    该位由软件序列清零（读入 USART_SR 寄存器，然后读入 USART_DR 寄存器）。 </p><p>​    <em>注意：直到 RXNE 位本身已置 1 时（即，当出现新的空闲线路时）IDLE 位才会被再次置 1。</em></p></li><li><p><strong>位 3 ORE：</strong>上溢错误 (Overrun error)</p><p>​     在 RXNE = 1 的情况下，当移位寄存器中当前正在接收的字准备好传输到 RDR 寄存器时，该  位由硬件置 1。 0：无上溢错误 1：检测到上溢错误</p><p>​    如果 USART_CR1 寄存器中 RXNEIE = 1，则会生成中断。该位由软件序列清零（读入 USART_SR 寄存器，然后读入 USART_DR 寄存器。</p><p>​    <em>注意：当该位置 1 时，RDR 寄存器的内容不会丢失，但移位寄存器会被覆盖。如果 EIE 位置 1，  则在进行多缓冲区通信时会对 ORE 标志生成一个中断。</em></p></li><li><p><strong>位 2 NF：</strong>检测到噪声标志 (Noise detected flag) </p><p>​    当在接收的帧上检测到噪声时，该位由硬件置 1。 0：未检测到噪声  1：检测到噪声</p><p>​    该位由软件序列清零（读入 USART_SR 寄  存器，然后读入 USART_DR 寄存器。</p><p>​     <em>注意：如果 EIE 位置 1，则在进行多缓冲区通信时，该位不会生成中断，因为该位出现的时间与  本身生成中断的 RXNE 位因 NF 标志而生成的时间相同。</em></p><p>​    <em>注意：当线路无噪声时，可以通过将 ONEBIT 位编程为 1 提高 USART 对偏差的容差来禁止  NF 标志</em></p></li><li><p><strong>位 1 FE：</strong>帧错误 (Framing error) </p><p>​    当检测到去同步化、过度的噪声或中断字符时，该位由硬件置 1。0：未检测到帧错误 1：检测到帧错误或中断字符</p><p>​    该位由软件序列清零（读入  USART_SR 寄存器，然后读入 USART_DR 寄存器）。</p><p>​    <em>注意：该位不会生成中断，因为该位出现的时间与本身生成中断的 RXNE 位出现的时间相同。  如果当前正在传输的字同时导致帧错误和上溢错误，则会传输该字，且仅有 ORE 位被  置 1。 如果 EIE 位置 1，则在进行多缓冲区通信时会对 FE 标志生成一个中断。</em></p></li><li><p><strong>位 0 PE：</strong>奇偶校验错误 (Parity error) </p><p>​    当在接收器模式下发生奇偶校验错误时，该位由硬件置 1。0：无奇偶校验错误  1：奇偶校验错误</p><p>​    该位由软件序列清零（读取状态寄存器，然后对 USART_DR 数据寄存器执行读或写访问。</p><p>​    将 PE 位清零前软件必须等待  RXNE 标志被置 1。  如果 USART_CR1 寄存器中 PEIE = 1，则会生成中断。 </p></li></ul><h3 id="数据寄存器-USART-DR"><a href="#数据寄存器-USART-DR" class="headerlink" title="数据寄存器(USART_DR)"></a>数据寄存器(USART_DR)</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206223126595.png" alt="image-20240206223126595"></p><p>该寄存器有32位，但<strong>[31:9]位保留，[8:0]为用于存放待发送或接受的9位或8位数据（9位或8位由设置的字长决定）</strong>这个寄存器其实由TDR和RDR两个寄存器组成，访问的是那个寄存器由读写操作决定。如果是写要发送的数据，则访问的是TDR寄存器。如果是要读已接收的数据，则访问的是RDR寄存器。</p><p>在使能奇偶校验位的情况下（USART_CR1 寄存器中的 PCE 位被置 1）进行发送时，由于  MSB 的写入值（位 7 或位 8，具体取决于数据长度）会被奇偶校验位所取代，因此该值不起任何作用。</p><h3 id="控制寄存器1-USART-CR1"><a href="#控制寄存器1-USART-CR1" class="headerlink" title="控制寄存器1(USART_CR1)"></a>控制寄存器1(USART_CR1)</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206223222420.png" alt="image-20240206223222420"></p><ul><li><p><strong>位 15 OVER8：过采样模式 (Oversampling mode)</strong>（F1系列没有这一位）</p><p>​    0：16 倍过采样;  1：8 倍过采样</p></li><li><p><strong>位 13 UE：USART 使能 (USART enable) </strong></p><p>​    0：禁止 USART 预分频器和输出 1：使能 USART</p><p>​    该位清零后，USART 预分频器和输出将停止，并会结束当前字节传输以降低功耗。</p><p>​    此位由软  件置 1 和清零。 </p></li><li><p><strong>位 12 M：字长 (Word length)</strong>。该位决定了字长。该位由软件置 1 或清零</p><p>​    0：8 数据位； 1：9 数据位</p><p>​    <em>注意：在数据传输（发送和接收）期间不得更改 M 位</em></p></li><li><p><strong>位 10 PCE：奇偶校验控制使能 (Parity control enable)</strong></p><p>​    0：禁止奇偶校验控制；1：使能奇偶校验控制</p></li><li><p><strong>位 9 PS：奇偶校验选择 (Parity selection)</strong></p><p>​    0：偶校验； 1：奇校验</p></li><li><p><strong>位 8 PEIE：奇偶校验错误中断使能 (PE interrupt enable)</strong></p><p>​    0：禁止中断； 1：当 USART_SR 寄存器中 PE=1 时，生成 USART 中断</p></li><li><p><strong>位 7 TXEIE：发送寄存器空中断使能 (TXE interrupt enable)</strong></p><p>​    0：禁止中断； 1：当 USART_SR 寄存器中 TXE=1 时(i.e., 当 TDR 寄存器的内容已传输到移位寄存器时)，生成 USART 中断</p></li><li><p><strong>位 6 TCIE：传送完成中断使能 (Transmission complete interrupt enable)</strong></p><p>​    0：禁止中断； 1：当 USART_SR 寄存器中 TC=1 时，生成 USART 中断</p></li><li><p><strong>位 3 TE：发送器使能 (Transmitter enable)</strong></p><p>​    0：禁止发送器；1：使能发送器</p></li><li><p><strong>位 2 RE：接收器使能 (Receiver enable)</strong></p><p>​    0：禁止接收器；1：使能接收器并开始搜索起始位</p></li></ul><h3 id="控制寄存器2-USART-CR2"><a href="#控制寄存器2-USART-CR2" class="headerlink" title="控制寄存器2(USART_CR2)"></a>控制寄存器2(USART_CR2)</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206224629997.png" alt="image-20240206224629997"></p><ul><li><p><strong>位 13:12 STOP：停止位配置 (STOP bit)</strong></p><p>​    00：1 个停止位</p><p>​    01：0.5 个停止位</p><p>​    10：2 个停止位</p><p>​    11：1.5 个停止位</p><p>​    <em>注意：0.5 个停止位和 1.5 个停止位不适用于 UART4 和 UART5</em></p></li></ul><h3 id="控制寄存器3-USART-CR3"><a href="#控制寄存器3-USART-CR3" class="headerlink" title="控制寄存器3(USART_CR3)"></a>控制寄存器3(USART_CR3)</h3><p>  <img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206225157524.png" alt="image-20240206225157524"></p><ul><li><p><strong>位 11 ONEBIT：一个采样位方法使能 (One sample bit method enable)</strong></p><p>​    0：三个采样位方法 ；1：一个采样位方法（将禁止噪声检测标志 (NF)）</p></li><li><p><strong>位 10 CTSIE：CTS 中断使能 (CTS interrupt enable)</strong></p><p>​    0：禁止中断；1：当 USART_SR 寄存器中 CTS = 1 时，生成中断</p><p>​    <em>注意：该位不适用于 UART4 和 UART5。</em></p></li><li><p><strong>位 9 CTSE： CTS 使能 (CTS enable)</strong></p><p>​    0：禁止 CTS 硬件流控制；1：使能 CTS 模式，仅当 nCTS 输入有效 （连接到 0）时才发送数据。</p></li><li><p><strong>位 8 RTSE： RTS 使能 (RTS enable)</strong></p><p>​    0：禁止 RTS 硬件流控制；1：使能 RTS 中断，仅当接收缓冲区中有空间时才会请求数据。可以接收数据时使 nRTS 输出有效 （连接到 0）。</p></li><li><p><strong>位 7 DMAT： DMA 使能发送器 (DMA enable transmitter)</strong></p><p>​    1：针对发送使能 DMA 模式 ；0：针对发送禁止 DMA 模式</p></li><li><p><strong>位 6 DMAR： DMA 使能接收器 (DMA enable receiver)</strong></p><p>​    1：针对接收使能 DMA 模式 ；0：针对接收禁止 DMA 模式</p></li></ul><h2 id="常用功能对应寄存器总表"><a href="#常用功能对应寄存器总表" class="headerlink" title="常用功能对应寄存器总表"></a>常用功能对应寄存器总表</h2><div class="table-container"><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">寄存器</th><th style="text-align:center">配置</th><th style="text-align:center">功能</th><th style="text-align:center">寄存器</th><th style="text-align:center">配置</th></tr></thead><tbody><tr><td style="text-align:center">使能USART</td><td style="text-align:center">USART_CR1 UE（位13）</td><td style="text-align:center">0：失能；1：使能</td><td style="text-align:center">设置数据字长</td><td style="text-align:center">USART_CR1  M（位12）</td><td style="text-align:center">0：8数据位；1：9数据位</td></tr><tr><td style="text-align:center">设置波特率</td><td style="text-align:center">USART_BRR [15:4]&amp;[3:0]</td><td style="text-align:center">-</td><td style="text-align:center">奇偶校验使能</td><td style="text-align:center">USART_CR1 PCE（位10）</td><td style="text-align:center">0：失能；1：使能</td></tr><tr><td style="text-align:center">奇偶校验模式选择</td><td style="text-align:center">USART_CR1 PS（位9）</td><td style="text-align:center">0：偶校验；1：奇校验</td><td style="text-align:center">发送器使能</td><td style="text-align:center">USART_CR1 TE（位3）</td><td style="text-align:center">0：失能；1：使能</td></tr><tr><td style="text-align:center">接收器使能</td><td style="text-align:center">USART_CR1 RE（位2）</td><td style="text-align:center">0：失能；1：使能</td><td style="text-align:center">设置停止位</td><td style="text-align:center">USART_CR2 STOP（位[13:12]）</td><td style="text-align:center">00：1个;  01：0.5个；<br>10：2个；  11：1.5个</td></tr><tr><td style="text-align:center">DMA 使能发送器</td><td style="text-align:center">USART_CR3 DMAT（位7）</td><td style="text-align:center">0：失能；1：使能</td><td style="text-align:center">DMA 使能接收器</td><td style="text-align:center">USART_CR3 DMAR（位6）</td><td style="text-align:center">0：失能；1：使能</td></tr></tbody></table></div><h2 id="使用UART通信的配置步骤"><a href="#使用UART通信的配置步骤" class="headerlink" title="使用UART通信的配置步骤"></a>使用UART通信的配置步骤</h2><p>设置GPIO的复用模式</p><ul><li>设置为复用-推挽模式</li><li>无上拉、下拉</li><li>设置GPIO时钟（通常设置成高速）</li><li>通过配置GPIO-&gt;AFR寄存器，将USART1复用至GPIO</li></ul><p>设置NVIC（如果要使用中断串口，则需要设置NVIC）</p><ul><li>设置中断分组(AIRCR寄存器)</li><li>设置中断优先级(IPR寄存器[7:4])</li><li>使能对应的中断(ISER)</li></ul><p>设置串口通信相关参数</p><ul><li>使能串口挂在总线的时钟</li><li>对USART-&gt;BRR寄存器写入，设置波特率</li><li>通过对USART-&gt;CR1寄存器写入设置OVER8过采样模式。</li><li>通过对USART-&gt;CR2寄存器写入，设置STOP位长度</li><li>通过对USART-&gt;CR1寄存器写入，设置奇偶校验使能和模式</li><li>如需使用中断，则使能相关中断</li><li>如需使用DMA，则使能DMA</li></ul>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式中常用串行通信</title>
      <link href="/posts/aa8bcb7e.html"/>
      <url>/posts/aa8bcb7e.html</url>
      
        <content type="html"><![CDATA[<h1 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>USART：</strong>Universal Synchronous Asynchronous Receiver Transmitter，通用同步异步收发器</p><p><strong>UART：</strong>Universal Asynchronous Receiver Transmitte，通用异步收发器</p><p>USART算是UART的哥哥，比UART多一个同步通信特性。<strong>这两个都是串行通信协议</strong>。同步通信需要双方时钟频率一致，而异步通信无需时钟频率一致，通过设置固定的波特率+识别起始位和结束位来识别数据。其数字基带调制均使用NRZ（不归零）码。</p><p><strong>UART和USART最大都只能和一个主机同时通信</strong></p><h2 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h2><p>UART通信的波特率用于描述UART每秒传输的比特的速度(因为UART采用二进制信道Baud=bps)，其单位为bps(bit per sec)，常用的波特率有9600，115200等。以9600为例，每一个bit持续的Ts就是</p><script type="math/tex; mode=display">T_s=\frac{1}{9600}\approx104.2us</script><h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><p>UART规定数据空闲时，总线为高电平。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240205002705006.png" alt="image-20240205002705006" style="zoom:67%;" /></p><p>UART的帧格式为</p><ol><li>起始位：一个低电平信号，使用由高电平(空闲)朝低电平(起始位)跳变的边沿触发来检测。</li><li>先低后高的数据位，通常为8bit，不同的UART控制器支持的bit数不同，一般可以通过寄存器配置使用几位数据位。</li><li>校验位（可有可无），它有4种校验模式<ul><li>奇校验(ODD)：每个字节传送整个过程中bit为1的个数是奇数个（使用校验位调调控）</li><li>偶校验(EVEN)：每个字节传送整个过程中bit为1的个数是偶数个（使用校验位调调控）</li><li>固定校验位(STICK)： 固定在校验位置位逻辑高(MARK)或者逻辑低(SPACE)。</li><li>无校验位（NONE）：不发送校验位，直接停止。</li></ul></li><li>停止位，保持高电平，持续1位或1.5位或2位均可。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备之间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟的机会。停止位个数越多，数据传输越稳定，但是数据传输速度也越慢。</li></ol><h2 id="串口流控（CTS-RTS）"><a href="#串口流控（CTS-RTS）" class="headerlink" title="串口流控（CTS/RTS）"></a>串口流控（CTS/RTS）</h2><h3 id="串口流控介绍"><a href="#串口流控介绍" class="headerlink" title="串口流控介绍"></a>串口流控介绍</h3><p> 在两个设备正常通信时，由于处理速度不同，就存在这样一个问题，有的快，有的慢，在某些情况下，就可能导致丢失数据的情况。举个例子，假如用于接收的UART buffer已经满了，单片机还没来得及处理buffer内的数据，此时再继续发来新的数据，数据就会丢失。因此，使用串口流控来避免这种情况。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>RTS （Require ToSend，发送请求）为输出信号，用于指示本设备是否准备好接收数据，低电平有效，低电平说明本设备准备好接收数据。</p><p>CTS （Clear ToSend，发送允许）为输入信号，用于判断是否可以向对方发送数据，低电平有效，低电平说明可以向对方发送数据。</p><p>在两设备通信时，RTS和CTS的连接如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设备1RTS -------- 设备2CTS</span></span><br><span class="line"><span class="comment">设备1CTS -------- 设备2RTS</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><strong>SPI</strong> ：Serial Peripheral Interface (串行外设接口) 一种同步全双工串行通信协议。它的通信速度比I2C和UART都要快。SPI通信内只有一个主机，可支持多个从机。连接图如下</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240208213112276.png" alt="image-20240208213112276"></p><h3 id="SS或CS选择信号线："><a href="#SS或CS选择信号线：" class="headerlink" title="SS或CS选择信号线："></a>SS或CS选择信号线：</h3><p>通过给SS信号线来选择和哪一个从机通信。通常，高电平无效，低电平有效，但是有例外，要参考从机的芯片手册。</p><h3 id="SCK时钟信号线："><a href="#SCK时钟信号线：" class="headerlink" title="SCK时钟信号线："></a>SCK时钟信号线：</h3><p>由主设备产生的同步时钟。通常，MOSI和MISO上的数据信号可以在上升或下降时钟沿被采集，详情需要参考特定的芯片手册。一般来说，会有一个CKP或CKOL（时钟极性）参数，来决定时钟闲时电平高低。还有一个CKE或CPHL（时钟相位）参数来决定是第一次跳变时采集数据还是第二次。这二者共同决定数据在时钟上沿还是下沿被采集。</p><h3 id="MOSI："><a href="#MOSI：" class="headerlink" title="MOSI："></a>MOSI：</h3><p>Master Output，Slave Input，用于主机向从机发送信号</p><h3 id="MISO"><a href="#MISO" class="headerlink" title="MISO"></a>MISO</h3><p>Master Input，Slave Output，用于从机向主机发送信号</p><h2 id="时钟极性和相位的规定"><a href="#时钟极性和相位的规定" class="headerlink" title="时钟极性和相位的规定"></a>时钟极性和相位的规定</h2><p>时钟极性CPOL决定时钟在空闲时的电平高低。规定如下</p><ul><li>CPOL= 0：空闲时SCLK为低电平</li><li>CPOL= 1：空闲时SCLK为高电平</li></ul><p>CPHA表示采样时刻，也就是时钟相位。用于指明在第几次跳变时开始第一次采样。</p><ul><li><p>CPHA= 0：第一个时钟沿</p></li><li><p>CPHA= 1：第二个时钟沿</p></li></ul><h2 id="帧格式-1"><a href="#帧格式-1" class="headerlink" title="帧格式"></a>帧格式</h2><p>SPI通信在发送数据时<strong>不包含</strong>IIC中的地址码、应答信号或是UART中的起始位、停止位、校验位。它的<strong>数据是简单的纯数据位，没有应答，没有起始，没有结束</strong>。<strong>SPI的数据位先发高位(MSB)，再发低位(LSB)</strong>。高电平表示1，低电平表示0。在一个字节传输完成后，SPI可以紧跟着直接发送下一个字节，没有应答操作。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240208234346844.png" alt="image-20240208234346844"></p>]]></content>
      
      
      <categories>
          
          <category> 各种折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字基带通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32的中断(Register)</title>
      <link href="/posts/e95d61a1.html"/>
      <url>/posts/e95d61a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h1><p>不同于普通单片机的软中断（单一入口，软件识别flag）或硬中断（不同入口）会在多个中断同时发生时挂起后发生的，STM32支持对中断的优先级进行编程，在中断中触发中断。用于管理这一优先级的系统被称为NVIC。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240202143753489.png" alt="image-20240202143753489"></p><p>NVIC：Nested vectoredinterrupt controller，嵌套向量中断控制器，属于内核 (M3/4/7)。NVIC支持256个中断(16个内核中断+240个外部中断)，内核支持256个中断优先级。ST公司把256个优先级裁切为了<strong>16个优先级</strong>（所有系列都是如此）。对于F407xx系列芯片，有10个内核中断，82个外部中断。</p><p>STM32的中断优先级又分为几类：抢占式优先级、响应式优先级、自然优先级。<strong>在STM32中，优先级设置的数值越小，其优先级越高</strong></p><ul><li>抢占式优先级：当两个中断同时发生时，优先执行抢占式优先级高的中断，可形成中断嵌套(在执行某低优先级中断中被高优先级再次中断，先执行高的再回来继续执行低的)</li><li>响应式优先级：当两个同抢占式优先级的中断同时发生时，优先响应 响应式优先级 高的中断，另一个被挂起。响应式优先级无法打断执行过程中的中断。</li><li>自然优先级：由startup文件决定，当设置的抢占优先级和响应优先级相同时，先执行自然优先级高的中断。</li></ul><h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>中断向量表用于存放各个中断服务函数的首地址，每一个地址有4 byte （32位MCU）。在sartup文件中，中断向量表被定义在__Vectors中。CPU在上电后默认运行main，但一旦有中断触发，就调用对用的Handler。下方代码就是F4系列Startup文件中定义的10个内核中断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br></pre></td></tr></table></figure><p>如上代码定义的就是中断函数的接口，也就是说，不像其他单片机那样触发中断调用的函数是interrupt()，stm32不同的中断会调用不同的函数，这些函数的名字就是如上定义的这些，而非interrupt。</p><p>在startup文件中，调用中断向量表的Handler时，会天然地决定中断判定和执行的顺序，即自然优先级。例如复位(Reset)被为-3，是自然优先级最高的中断。NMI被定义为-2，硬件失效(HardFault)定义为-1。</p><h2 id="NVIC相关寄存器"><a href="#NVIC相关寄存器" class="headerlink" title="NVIC相关寄存器"></a>NVIC相关寄存器</h2><h3 id="ISER寄存器"><a href="#ISER寄存器" class="headerlink" title="ISER寄存器"></a>ISER寄存器</h3><p>ISER：Interrupt Set Enable Registers，用于控制中断使能。Cortex内核中ISER有 ISER0～ISER7 共8个，每个32位。ISER的每一个位控制一个中断，所以每一个中断使能寄存器可以控制 32 个中断，共256个。<strong>不过，由于 STM32F407 的 可屏蔽中断只有 82 个，所以对我们来说，实际用到的 ISER 只有 3 个（ISER[0]～ISER[2]）。</strong> 不同芯片ISER寄存器对应控制的中断不同，需参考芯片手册。<strong>要对某个中断使能，只需朝ISER中对应位写入1即可</strong></p><p>因为其内存地址连续，所以可以直接定义uint_32类型数组ISER[n]来控制。</p><h3 id="ICER寄存器"><a href="#ICER寄存器" class="headerlink" title="ICER寄存器"></a>ICER寄存器</h3><p>与ISER相对， ICER(Interrupt Clear Enable Registers)，用于中断失能控制。<strong>要对某个中断失能，只需朝ICER中对应位写入1即可</strong></p><h3 id="IPR寄存器"><a href="#IPR寄存器" class="headerlink" title="IPR寄存器"></a>IPR寄存器</h3><p> Cortex-M4 内核可屏蔽中断有240个，每一个有256档优先级可以设置(需要8bit 寄存器进行配置)，因此内核规定IPR有60个，每个32bit （$60\times32bit=240\times8bit$）。在编程时，同样定义为数组来处理。<strong>由于 STM32F407 只用到了 Cortex-M4 的 82 个可屏蔽中断，故数组也只用了其中的元素 IP[0]～IP[81]。STM32F407 也并没有用到 IP 数组元素中的全部 8bit 来配置中断优先级，而是只使用了其中的高4位（对应16个优先级）</strong></p><h3 id="中断优先级的分组和AIRCR寄存器"><a href="#中断优先级的分组和AIRCR寄存器" class="headerlink" title="中断优先级的分组和AIRCR寄存器"></a>中断优先级的分组和AIRCR寄存器</h3><p>前面我们已知，STM32中中断优先级有16个，也就是需要IPR中的4个bit来表示，这16个又可以被分为抢占优先级和响应优先级。<strong>那么这4bit哪些用于控制响应优先级，哪些用于控制抢占优先级呢？这是通过设置AICRC寄存器实现的。</strong></p><p>AICRC： Application Interrupt and Reset Control Register，即应用程序中断及复位控制寄存器。该寄存器有32位，功能定义如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240203183209909.png" alt="image-20240203183209909"></p><p>可以看到，第8-10位被用于中断优先级的分组，这个分组有五种，用于控制PIR中4个bit控制抢占优先级还是响应优先级。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240202150050747.png" alt="image-20240202150050747"></p><p>bit8-10的值和对应的组别如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240203182224262.png" alt="image-20240203182224262" style="zoom: 50%;" /></p><h3 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h3><p>总的来说，要启用某一个中断，需要<strong>对NVIC进行的配置步骤如下：</strong></p><ul><li>设置中断分组(AIRCR寄存器)</li><li>设置中断优先级(IPR寄存器[7:4])</li><li>使能中断(ISER)</li></ul><hr><h1 id="外部中断-事件-控制器EXTI"><a href="#外部中断-事件-控制器EXTI" class="headerlink" title="外部中断(事件)控制器EXTI"></a>外部中断(事件)控制器EXTI</h1><p>EXTI：External Interrupt/Event Controller。EXTI线含边缘检测器，可以接受外部的中断信号，来触发中断或是事件。各系列芯片的支持的EXTI线如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240203203004878.png" alt="image-20240203203004878"></p><p><strong>每条EXTI线都可以单独配置：1.选择其触发中断或是事件，2.选择触发方式(上沿、下沿、双边沿)、3.软件触发、4.设置使能/失能、5.存储中断挂起状态</strong></p><p>对于F4系列芯片，有23个EXTI线。详情需查询对应芯片的手册。</p><p><strong>中断和事件的区别</strong></p><ul><li><p>中断：要进入NVIC，触发后由CPU调用对应的中断函数来执行中断程序</p></li><li><p>事件：不进入NVIC，本质上就是一个触发信号，是用来触发特定的外设模块或核心本身(唤醒)仅用于内部硬件自动控制。事件不需要软件参与，所以响应速度也更快。事件可作为中断的触发源。</p></li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240204162635225.png" alt="image-20240204162635225"></p><p>整个电路框图如上图所示。输入线接受外部信号，通过配置EXTI_RTSR和EXTI_FTSR来设置边沿检测电路对上沿或下沿响应。EXTI_SWIER允许我们通过程序控制就可以启动中断/事件线，也就是在某些时候让中断或事件以软件作为触发源，而非外部输入的硬件信号。后续是事件屏蔽器，用于enable和disable是否产生事件脉冲。同时EXTI_PR会存储有中断请求发生，这里就是作中断flag。当EXTI_IMR被使能时，中断信号进入NVIC，触发中断。</p><h2 id="EXTI相关寄存器"><a href="#EXTI相关寄存器" class="headerlink" title="EXTI相关寄存器"></a>EXTI相关寄存器</h2><h3 id="EXTI-IMR（中断屏蔽寄存器）"><a href="#EXTI-IMR（中断屏蔽寄存器）" class="headerlink" title="EXTI_IMR（中断屏蔽寄存器）"></a>EXTI_IMR（中断屏蔽寄存器）</h3><p>该寄存器总共有32位，但因为F4系列只有23个EXTI线，所以只有0-22位被使用。<strong>该寄存器写1位enable中断，写0为disable；复位值为全0，即所有中断disable</strong>。bit0对应EXTI0，bit1对应EXTI1，以此类推。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240204162947090.png" alt="image-20240204162947090"></p><h3 id="EXTI-EMR（事件屏蔽寄存器）"><a href="#EXTI-EMR（事件屏蔽寄存器）" class="headerlink" title="EXTI_EMR（事件屏蔽寄存器）"></a>EXTI_EMR（事件屏蔽寄存器）</h3><p>该寄存器同EXTI_IMR，复位全0，写0屏蔽，写1使能。该寄存器用于控制是否产生事件脉冲。</p><h3 id="EXTI-RTSR（上沿触发选择寄存器）"><a href="#EXTI-RTSR（上沿触发选择寄存器）" class="headerlink" title="EXTI_RTSR（上沿触发选择寄存器）"></a>EXTI_RTSR（上沿触发选择寄存器）</h3><p>该寄存器也是32位，但仅有23个bit被使用。bit0对应EXTI0，bit1对应EXTI1，以此类推。<strong>写0表示禁止上沿触发，写1表示使能上沿触发，复位值全0</strong></p><h3 id="EXTI-FTSR-下降沿触发选择寄存器"><a href="#EXTI-FTSR-下降沿触发选择寄存器" class="headerlink" title="EXTI_FTSR(下降沿触发选择寄存器)"></a>EXTI_FTSR(下降沿触发选择寄存器)</h3><p>同上沿触发寄存器。如果上沿下沿触发都被enable，那么任意边沿都可唤起中断。如果在设置极性的同时产生了中断，那么中断请求会被忽略。</p><h3 id="EXTI-PR-（挂起请求寄存器）"><a href="#EXTI-PR-（挂起请求寄存器）" class="headerlink" title="EXTI_PR （挂起请求寄存器）"></a>EXTI_PR （挂起请求寄存器）</h3><p>当在外部中断线上发生了选择的边沿事件，该位被置“1”。在此位中<strong>写入“1”可以清除它（注意这里不是写0）</strong>，在改变边沿检测的极性时，该位也会自动被清除。</p><h3 id="EXTI-SWIER（软件中断寄存器）"><a href="#EXTI-SWIER（软件中断寄存器）" class="headerlink" title="EXTI_SWIER（软件中断寄存器）"></a>EXTI_SWIER（软件中断寄存器）</h3><p>当该位为“0”时，写“1”将设置 EXTI_PR 中相应的挂起位。如果在 EXTI_IMR 和 EXTI_EMR  中允许产生该中断，则产生中断请求。通过清除 EXTI_PR（挂起寄存器） 的对应位（写入“1”），可以清除该位为“0”，即处理中断flag时自动清除该位。</p><h2 id="EXTI和IO口的映射"><a href="#EXTI和IO口的映射" class="headerlink" title="EXTI和IO口的映射"></a>EXTI和IO口的映射</h2><h3 id="AFIO（功能复用寄存器）配置-对于F1单片机"><a href="#AFIO（功能复用寄存器）配置-对于F1单片机" class="headerlink" title="AFIO（功能复用寄存器）配置(对于F1单片机)"></a>AFIO（功能复用寄存器）配置(对于F1单片机)</h3><p>对F1系列单片机，此处不做过多介绍，参考芯片手册即可。</p><h3 id="SYSCFG（系统配置寄存器）配置（对于F4-F7-H7单片机）"><a href="#SYSCFG（系统配置寄存器）配置（对于F4-F7-H7单片机）" class="headerlink" title="SYSCFG（系统配置寄存器）配置（对于F4/F7/H7单片机）"></a>SYSCFG（系统配置寄存器）配置（对于F4/F7/H7单片机）</h3><p>EXTIn线可以映射到GPIOn上，例如EXTI0这条线，就可以映射至所有端口(如PA，PB等)的GPIO0这个口,EXTI15这条线，可映射至所有端口的GPIO15。一条EXTI线同一时间仅可以和一个GPIO相连。</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240204170054912.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240204171730480.png" alt="image-20240204171730480" style="zoom:78%;" /></center></td>        </tr></table><p>在SYSCFG寄存器组中，有SYSCFG_EXTICR1~4 4组用于配置EXTI映射的寄存器，用于控制EXTI线和哪一个端口相连。，每组寄存器都是32位，但仅使用16位，使用的16位又被分为4组（每4bit一组），一组控制一条EXTI线。可映射至GPIO的EXTI线共有16条，4组SYSCFG_EXTICR寄存器，每组控制4条，刚好与16条契合。下图展示SYSCFG_EXTICR1寄存器的bit构成，2-4同理：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240204171226010.png" alt="image-20240204171226010"></p><p>4bit和端口的值对应关系如下(对于F4)：</p><div class="table-container"><table><thead><tr><th style="text-align:center">数值（Binary）</th><th style="text-align:center">对应端口</th><th style="text-align:center">数值（Binary）</th><th style="text-align:center">对应端口</th></tr></thead><tbody><tr><td style="text-align:center">0000</td><td style="text-align:center">PA</td><td style="text-align:center">0101</td><td style="text-align:center">PF</td></tr><tr><td style="text-align:center">0001</td><td style="text-align:center">PB</td><td style="text-align:center">0110</td><td style="text-align:center">PG</td></tr><tr><td style="text-align:center">0010</td><td style="text-align:center">PC</td><td style="text-align:center">0111</td><td style="text-align:center">PH</td></tr><tr><td style="text-align:center">0011</td><td style="text-align:center">PD</td><td style="text-align:center">1000</td><td style="text-align:center">PI</td></tr><tr><td style="text-align:center">0100</td><td style="text-align:center">PE</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table></div><p>设置寄存器前，需要对SYSCFG时钟进行使能(<em>HAL库提供宏：__HAL_RCC_SYSCFG_CLK_ENABLE()</em>)</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><p>要在STM32芯片上使用某一中断功能，需要遵循如下步骤配置</p><ul><li>使能GPIO时钟</li><li>设置GPIO模式（输入、是否上拉等），如果使用片上外设中断，可跳过这一步</li><li>使能SYSCFG/APIO时钟，如果使用片上外设中断，可跳过这一步</li><li>设置EXTI和GPIO的映射关系（设置APIO或STYSCFG寄存器），如果使用片上外设中断，可跳过这一步</li><li>设置边沿触发模式(RTSR,FTSR)、enbale中断(IMR/EMR)，如果使用片上外设中断，可跳过这一步</li><li>（对于其他片上外设，中断会直接进入NVIC，无需配置EXTI相关设置）</li><li>设置NVIC（包含优先级分组，优先级，使能中断，详见NVIC配置步骤）</li><li>编写中断服务函数（服务函数内需清除中断标志）</li></ul><h2 id="服务函数注意事项"><a href="#服务函数注意事项" class="headerlink" title="服务函数注意事项"></a>服务函数注意事项</h2><p>在STM32中，EXTI0-4有5个独立的中断服务函数；EXTI9-5共用一个中断服务函数；EXTI15-10共用一个中断服务函数。也就是总共有7个中断服务函数。</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅思阅读</title>
      <link href="/posts/189c0aac.html"/>
      <url>/posts/189c0aac.html</url>
      
        <content type="html"><![CDATA[<h1 id="分数对应表"><a href="#分数对应表" class="headerlink" title="分数对应表"></a>分数对应表</h1><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/v2-e2a43c0d7e956a2a28630da1706b6867_1440w.webp" alt="img"></p><p>通常来说，中国的学生主要靠阅读和听力拉分，小分目标6.5-7需要阅读冲8。也就是最多错4-5分的阅读题。</p><h1 id="整体题目顺序度"><a href="#整体题目顺序度" class="headerlink" title="整体题目顺序度"></a>整体题目顺序度</h1><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/v2-fae07171ce009b09a4ca9012531114d2_1440w.webp" alt="img"></p><hr><h1 id="题型介绍"><a href="#题型介绍" class="headerlink" title="题型介绍"></a>题型介绍</h1><h2 id="单词填空题"><a href="#单词填空题" class="headerlink" title="单词填空题"></a>单词填空题</h2><ul><li>难度：低</li><li>顺序/乱序：顺序</li><li>做题步骤：<ol><li>读第一个和第二个空，勾画定位词</li><li>在文中遇到定位词即做对应的空(通常密集出现)</li><li>填完第一个空之后，读第三个空，带着第二个空和第三个空的定位词做题</li><li>以此类推</li></ol></li></ul><p>单词填空题一般分为段落(原文摘要)填空和填图题。这两类题目一般要求<strong>直接从原文选择规定词数以内的单词填入(一般不超过3个词)</strong>。常考同义替换</p><h2 id="判断题-T-F-NG"><a href="#判断题-T-F-NG" class="headerlink" title="判断题(T/F/NG)"></a>判断题(T/F/NG)</h2><ul><li>难度：低</li><li>顺序/乱序：顺序</li><li>做题步骤：<ol><li>读第一个和第二个选项，勾画定位词，考点词</li><li>在文中遇到定位词即做对应的选项(通常密集出现)</li><li>填完第一个选项之后，读第三个选项，带着第二个选项和第三个选项的定位词做题</li><li>以此类推</li></ol></li></ul><p>根据标题内容是否在原文中证实或呈现选择 True, False, Not Given. 判断题注意不要带入自己的主管臆测，一定要专注于原文是否提及、是否明确阐述。</p><p>考点词：体现出题目核心思想的词，这个词决定了是T还是F，increasing/ decreasing之类的</p><p><strong>一般来说，3个选项的判断题不一定出现NG，四个选项的含有NG。</strong></p><p><strong>连续的T或F不会超过3个</strong></p><h2 id="段落中心思想题-给段落选Heading"><a href="#段落中心思想题-给段落选Heading" class="headerlink" title="段落中心思想题(给段落选Heading)"></a>段落中心思想题(给段落选Heading)</h2><ul><li><p>难度：中等</p></li><li><p>顺序/乱序：乱序</p></li><li><p>做题步骤：</p><ol><li><p>通读题干，勾定位词</p></li><li><p>找段落主旨句和核心词汇，正确答案常常是主旨句的改写</p></li><li><p>对比主旨句和选项，寻找同义替换。<strong>这里需要注意同义改写后的表述和原文不应当有信息差</strong></p></li><li><p>确定某段话的答案后，将它从选项列表中划去</p></li><li><p>读一段选一题，不确定的可以选择了但不划去</p></li></ol></li></ul><p>这类题目要求给阅读文章中的每一段选个小标题，概括这段话的段落大意、中心思想、主旨。<strong>在文段中定位时，通常看首句，第二句，末句。当定位没有出现在这里面时，重点关注段中转折</strong></p><p>如果选项中有相似的词语或有链接的句子，那注意这些要么是干扰项，要么是</p><h2 id="信息匹配（Matching）"><a href="#信息匹配（Matching）" class="headerlink" title="信息匹配（Matching）"></a>信息匹配（Matching）</h2><ul><li>难度：中等</li><li>顺序/乱序：乱序</li><li><p>做题步骤：</p><ol><li>通读题干和选项，勾定位词，一般选项内的人名、国家、地区等比较好定位</li><li>读文章时遇到定位词就做对应的题目</li></ol></li></ul><p>Matching（匹配题）是雅思阅读最常考的题型之一，每次考试都至少有一组，很多时候会达到两组甚至更多。匹配题一般要求匹配谁干了什么，什么地区怎么样了，什么国家干了什么，谁有什么观点之类的，选项一般是人名、地名或者其他名词，比较好定位。</p><p><strong>若出现NB，也不一定会要复选，但是大部分需要复选</strong></p><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul><li>难度：中等</li><li>顺序/乱序：基本顺序，局部可能乱序</li><li>做题步骤：</li><li><p>做题步骤：</p><ol><li></li><li></li></ol></li></ul><p>每个题目都是一个特殊问句，要求根据原文作出回答。</p><p><strong>所有的答案都不用大写，专有名词除外。</strong></p><p><strong>绝大部分的答案来自原文原词，极少一部分需要自己写答案。</strong> </p><p>答案涉及数字的，一般要有简单的四则运算，且涉及钱币的，在数字前一定要有货币符号，在数字后可能会有单位。题目问 how many/how much/what proportion/what is the cost 时，答案一般不会直接是原文中出现的数字，而要涉及到简单的四则运算，通常是加减法</p><h2 id="带选择的填空"><a href="#带选择的填空" class="headerlink" title="带选择的填空"></a>带选择的填空</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240125141227927.png" alt="image-20240125141227927"></p><ul><li>难度：中等</li><li>顺序/乱序：基本顺序，局部可能乱序</li><li>做题步骤：</li></ul><p>这类题可以根据名词单复数、转折关系、因果关联，来辅助做题。</p><h2 id="单项选择"><a href="#单项选择" class="headerlink" title="单项选择"></a>单项选择</h2><ul><li>难度：中等</li><li>顺序/乱序：选项内部没有顺序，题目与题目之间有顺序</li><li>做题步骤：</li></ul><h2 id="多项选择"><a href="#多项选择" class="headerlink" title="多项选择"></a>多项选择</h2><p>没有顺序但答案集中</p><hr><h1 id="做题技巧"><a href="#做题技巧" class="headerlink" title="做题技巧"></a>做题技巧</h1><ul><li>遇到例子的时候，例子通常是为了论证例子前面的观点，所以观点一般在前面，仅有少数在例子之后</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 雅思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32——HAL库</title>
      <link href="/posts/82419430.html"/>
      <url>/posts/82419430.html</url>
      
        <content type="html"><![CDATA[<h1 id="GPIO控制"><a href="#GPIO控制" class="headerlink" title="GPIO控制"></a>GPIO控制</h1><h2 id="GPIO口寄存器的封装和总线时钟"><a href="#GPIO口寄存器的封装和总线时钟" class="headerlink" title="GPIO口寄存器的封装和总线时钟"></a>GPIO口寄存器的封装和总线时钟</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GPIO_TypeDef 结构体如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> MODER;    <span class="comment">/*!&lt;模式寄存器,                Address offset: 0x00      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OTYPER;   <span class="comment">/*!&lt;输出数据类型寄存器,         Address offset: 0x04      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OSPEEDR;  <span class="comment">/*!&lt;输出速度寄存器,             Address offset: 0x08      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PUPDR;    <span class="comment">/*!&lt;上拉下拉电阻选择寄存器,      Address offset: 0x0C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> IDR;      <span class="comment">/*!&lt;输入数据寄存器,             Address offset: 0x10      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ODR;      <span class="comment">/*!&lt;输出数据寄存器,             Address offset: 0x14      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> BSRR;     <span class="comment">/*!&lt; GPIO port bit set/reset register,      Address offset: 0x18      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> LCKR;     <span class="comment">/*!&lt;设置锁寄存器,               Address offset: 0x1C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AFR[<span class="number">2</span>];   <span class="comment">/*!&lt;复用功能寄存器,             Address offset: 0x20-0x24 */</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"><span class="comment">//GPIO_InitTypeDef 结构体如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> Pin; <span class="comment">//引脚</span></span><br><span class="line">  <span class="type">uint32_t</span> Mode; <span class="comment">//引脚模式(推挽 or 开漏 等)</span></span><br><span class="line">  <span class="type">uint32_t</span> Pull; <span class="comment">//上拉电阻使能情况</span></span><br><span class="line">  <span class="type">uint32_t</span> Speed; <span class="comment">//引脚响应速度</span></span><br><span class="line">  <span class="type">uint32_t</span> Alternate; <span class="comment">//引脚复用情况</span></span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO所在总线(AHB1)时钟使能</span></span><br><span class="line">__HAL_RCC_GPIOx_CLK_ENABLE();  <span class="comment">/*HAL库使用宏来进行使能, GPIOx可以是任意一组GPIO,但是对于f4系列芯片而言，他们挂载的总线一致，所以都是对AHB1总线时钟进行使能*/</span></span><br><span class="line"><span class="comment">/*宏内配置如下*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAL_RCC_GPIOA_CLK_ENABLE()   do &#123; \</span></span><br><span class="line"><span class="meta">                                        __IO uint32_t tmpreg = 0x00U; \</span></span><br><span class="line"><span class="meta">                                        SET_BIT(RCC-&gt;AHB1ENR, RCC_AHB1ENR_GPIOAEN);\</span></span><br><span class="line"><span class="meta">                                        <span class="comment">/* Delay after an RCC peripheral clock enabling */</span> \</span></span><br><span class="line"><span class="meta">                                        tmpreg = READ_BIT(RCC-&gt;AHB1ENR, RCC_AHB1ENR_GPIOAEN);\</span></span><br><span class="line"><span class="meta">                                        UNUSED(tmpreg); \</span></span><br><span class="line"><span class="meta">                                          &#125; while(0U)</span></span><br></pre></td></tr></table></figure><hr><h2 id="GPIO的初始化"><a href="#GPIO的初始化" class="headerlink" title="GPIO的初始化"></a>GPIO的初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_Init</span><span class="params">(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)</span></span><br></pre></td></tr></table></figure><p>其中GPIOx可以直接传入GPIOA, GPIOB等等，这些已经被预编译成了以引脚初始寄存器位置开始的GPIO_TypeDef 类型的结构体，上面一节有介绍。GPIO_InitTypeDef用于控制引脚的各个功能和状态配置。</p><p>GPIO_InitTypeDef成员的值定义如下：</p><h3 id="Pin"><a href="#Pin" class="headerlink" title="Pin:"></a>Pin:</h3><p>Pin控制要对那一个引脚操控， 可传GPIO_PIN_x，x可以为0-15，ALL，MASK三种。</p><ul><li><p>GPIO_PIN_0 如果将x设置为0-15，则传入的是GPIO的寄存器位置（例如，GPIO3对应的寄存器地址0B0000,0100）。多个引脚时，可以用或运算同时使能，如GPIO_PIN_0 | GPIO_PIN_1。</p></li><li><p>GPIO_PIN_ALL 对应的是0xFFFF，也就是将16个PIN全部操作</p></li><li><p><em>GPIO_PIN_MASK是给断言机制判断传入参数是否合法使用的，<strong>不作为用户调用参数传入</strong></em>。断言机制代码如下：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_GPIO_PIN(__PIN__)        ((((__PIN__) &amp; GPIO_PIN_MASK) != (uint32_t)0x00) &amp;&amp;\</span></span><br><span class="line"><span class="meta">                                     (((__PIN__) &amp; ~GPIO_PIN_MASK) == (uint32_t)0x00))</span></span><br></pre></td></tr></table></figure><p>  这样IS_GPIO_PIN 宏定义就会在输入非GPIO合法值时返回0，触发断言机制，程序报错并定位。</p><h3 id="Mode："><a href="#Mode：" class="headerlink" title="Mode："></a>Mode：</h3><p>Mode控制GPIO的输入、输出模式，有如下选择：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_INPUT                <span class="comment">//浮动输入：上拉</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_OUTPUT_PP            <span class="comment">//推挽输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_OUTPUT_OD            <span class="comment">//开漏输出</span></span></span><br><span class="line"><span class="comment">//复用PP/OD输出模式，与PP/OD出模式很是相似。只是输出的高低电平的来源不同，由ODR寄存器控制，而是用片内外设模块的复用功能输出来决定的。</span></span><br><span class="line"><span class="comment">//复用开漏输出功能有：（TX1,MOSI,MISO.SCK.SS）</span></span><br><span class="line"><span class="comment">//复用推挽输出功能有：（I2C的SCL,SDA）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_AF_PP                 <span class="comment">//复用推挽输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_AF_OD                 <span class="comment">//复用开漏输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_ANALOG                <span class="comment">//此时GPIO处于analog模式。可作ADC转换通道,可做比较器、DAC等模拟外设的复用通道</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_RISING             <span class="comment">//具有上升沿触发检测的外部中断模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_FALLING            <span class="comment">//具有下降沿触发检测的外部中断模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_RISING_FALLING     <span class="comment">//上升沿和下降沿均触发的外部中断模式</span></span></span><br><span class="line"><span class="comment">//下面几个对应的是&quot;事件&quot;,RISING,FALLING等含义同中断.在这里事件可以唤醒休眠状态(WFE)的MCU,但是不会产生&quot;中断事件&quot;,也就是说不会执行中断处理函数,也就说不需要清除外设中断挂起位或 NVIC. 使用GPIO&quot;事件&quot;来启动AD转换也是可以的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_RISING                   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_FALLING                  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_RISING_FALLING            </span></span><br></pre></td></tr></table></figure><h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull:"></a>Pull:</h3><p>PULL控制上拉、下拉电阻使能情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_NOPULL        ((uint32_t)0x00000000)   <span class="comment">//上拉下拉都不使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_PULLUP        ((uint32_t)0x00000001)   <span class="comment">//使能上拉电阻</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_PULLDOWN      ((uint32_t)0x00000002)   <span class="comment">//使能下拉电阻</span></span></span><br></pre></td></tr></table></figure><h3 id="Speed"><a href="#Speed" class="headerlink" title="Speed"></a>Speed</h3><p>控制GPIO时钟的速度，对应也就是GPIO的响应速度.ST公司给了四种不同的相对速度(相对MCU极限速度而言)可供选择。<strong>对于不同的MCU，这里define的值是不一样的，对应的频率也是不一样的，需要参考芯片手册。对于F4系列，其定义如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_SPEED_FREQ_LOW        <span class="comment">//2 MHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_SPEED_FREQ_MEDIUM     <span class="comment">//12.5 MHz to 50 MHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_SPEED_FREQ_HIGH       <span class="comment">//25 MHz to 100 MHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_SPEED_FREQ_VERY_HIGH  <span class="comment">//50 MHz to 200 MHz</span></span></span><br></pre></td></tr></table></figure><h3 id="Alternate"><a href="#Alternate" class="headerlink" title="Alternate"></a>Alternate</h3><p>控制引脚的复用情况，不同的MCU引脚可复用功能不同，需要参看<em>stm32f4xx_hal_gpio_ex.h</em> 头文件内的定义。例如F407系列，AF8引脚就可以配置成GPIO_AF8_UART4、GPIO_AF8_UART5、GPIO_AF8_USART6三种。详情需要参考不同芯片的手册。</p><hr><h2 id="GPIO的去初始化"><a href="#GPIO的去初始化" class="headerlink" title="GPIO的去初始化"></a>GPIO的去初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_DeInit</span><span class="params">(GPIO_TypeDef  *GPIOx, <span class="type">uint32_t</span> GPIO_Pin)</span></span><br></pre></td></tr></table></figure><p>这个函数用于将已初始化的GPIO恢复至默认值</p><ul><li>GPIOx 同init。</li><li>GPIO_Pin传入要初始化第几个即可，多个Pin使用或运算合并，同Init。</li></ul><hr><h2 id="读取引脚电平"><a href="#读取引脚电平" class="headerlink" title="读取引脚电平"></a>读取引脚电平</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_PinState <span class="title function_">HAL_GPIO_ReadPin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span></span><br></pre></td></tr></table></figure><p>用于读取GPIO的电平，读取的是IDR寄存器内对应的值。其返回值类型为GPIO_PinState，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GPIO_PIN_RESET = <span class="number">0</span>,</span><br><span class="line">  GPIO_PIN_SET</span><br><span class="line">&#125;GPIO_PinState;</span><br></pre></td></tr></table></figure><p>也就是RESET=0，SET=1。</p><hr><h2 id="写引脚电平"><a href="#写引脚电平" class="headerlink" title="写引脚电平"></a>写引脚电平</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_WritePin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, GPIO_PinState PinState)</span></span><br></pre></td></tr></table></figure><p>用于写入GPIO某一引脚的电平。GPIOx, GPIO_Pin同上，PinState有 GPIO_PIN_RESET 和  GPIO_PIN_SET 两种</p><hr><h2 id="反转引脚电平"><a href="#反转引脚电平" class="headerlink" title="反转引脚电平"></a>反转引脚电平</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_TogglePin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span></span><br></pre></td></tr></table></figure><p>这个函数的作用是讲某个引脚输出的值反转</p><p>这个函数的实现原理是使用BSRR寄存器，如果直接操作ODR寄存器，有被中断等(IRQ)打断的风险，而通过BSRR和BRR去改变管脚状态是不会被中断打断的，即不需要关闭中断。</p><p>BSRR的<strong>低 16bits 是set操作</strong>，而<strong>高16bits是 reset 操作</strong>。这个函数的实现原理如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOx-&gt;BSRR = ((odr &amp; GPIO_Pin) &lt;&lt; GPIO_NUMBER) | (~odr &amp; GPIO_Pin);</span><br><span class="line"><span class="comment">//GPIO_NUMBER 在F4中被定义为16，因为一组GPIO有16Pin</span></span><br></pre></td></tr></table></figure><p>这个语句首先将要操作PIN的ODR值放进Reset里面，然后再将这个值取反放进Set里面，如果此时这个Pin是1，那么对应寄存器的Reset就会是1，Set是0，反之亦然。这样就达到了对某一个PIN反相的效果。</p><hr><h2 id="锁定端口电平"><a href="#锁定端口电平" class="headerlink" title="锁定端口电平"></a>锁定端口电平</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_GPIO_LockPin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span></span><br></pre></td></tr></table></figure><p>这个函数通过对LCKR寄存器进行配置，对某一个引脚输出的值进行锁定，一般用得比较少。其返回值是锁定是否成功，成功返回HAL_OK (0)，失败返回HAL_ERROR (1)</p><hr><h2 id="GPIO触发的中断处理函数"><a href="#GPIO触发的中断处理函数" class="headerlink" title="GPIO触发的中断处理函数"></a>GPIO触发的中断处理函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* EXTI line interrupt detected */</span></span><br><span class="line">  <span class="keyword">if</span>(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</span><br><span class="line">    HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;UNUSED(GPIO_Pin);&#125;</span><br></pre></td></tr></table></figure><p>这个函数在中断入口的位置被自动调用。函数首先会清除中断Flag，然后调用HAL_GPIO_EXTI_Callback函数，这个回调函数就是中断要干什么。在HAL库内，有一个HAL_GPIO_EXTI_Callback已经被定义，但是使用__weak修饰，且函数只是返回一个void值，这里的意思是当用户自己定义这个中断处理函数时HAL库内这个会被disable，这个函数存在在这个只是为了防止gcc报错，<strong>且用户不可直接修改HAL库内这个callback</strong>，需要自己重新定义一个新的。</p><p><strong>也就是说，我们需要自定义一个void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) 的函数，来写入中断操作的内容。</strong></p><hr><h1 id="NVIC、EXTI和中断"><a href="#NVIC、EXTI和中断" class="headerlink" title="NVIC、EXTI和中断"></a>NVIC、EXTI和中断</h1><p>代码在stm32f4xx_hal_cortex.c中</p><h2 id="设置中断分组-NVIC"><a href="#设置中断分组-NVIC" class="headerlink" title="设置中断分组(NVIC)"></a>设置中断分组(NVIC)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_NVIC_SetPriorityGrouping</span><span class="params">(<span class="type">uint32_t</span> PriorityGroup)</span></span><br></pre></td></tr></table></figure><p>其中参数如下：</p><ul><li>NVIC_PRIORITYGROUP_0</li><li>NVIC_PRIORITYGROUP_1</li><li>NVIC_PRIORITYGROUP_2</li><li>NVIC_PRIORITYGROUP_3</li><li>NVIC_PRIORITYGROUP_4</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240202150050747.png" alt="image-20240202150050747"></p><h2 id="设置中断优先级-NVIC"><a href="#设置中断优先级-NVIC" class="headerlink" title="设置中断优先级(NVIC)"></a>设置中断优先级(NVIC)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_NVIC_SetPriority</span><span class="params">(IRQn_Type IRQn, <span class="type">uint32_t</span> PreemptPriority, <span class="type">uint32_t</span> SubPriority)</span></span><br></pre></td></tr></table></figure><p>其中IRQn表示要设置的中断，PreemptPriority表示抢占优先级，SubPriority表示响应优先级</p><h3 id="IRQn-中断号"><a href="#IRQn-中断号" class="headerlink" title="IRQn(中断号)"></a>IRQn(中断号)</h3><p>中断号用于指明控制哪一个中断，代码定义和对应中断如下：</p><p>它存储的是偏移地址，即相对于外部中断第一个中断寄存器WWDG_IRQn(0x0000,0040)地址的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/******  Cortex-M4 Processor Exceptions Numbers ****************************************************************/</span></span><br><span class="line">  NonMaskableInt_IRQn         = <span class="number">-14</span>,    <span class="comment">/*!&lt; 2 Non Maskable Interrupt                                          */</span></span><br><span class="line">  MemoryManagement_IRQn       = <span class="number">-12</span>,    <span class="comment">/*!&lt; 4 Cortex-M4 Memory Management Interrupt                           */</span></span><br><span class="line">  BusFault_IRQn               = <span class="number">-11</span>,    <span class="comment">/*!&lt; 5 Cortex-M4 Bus Fault Interrupt                                   */</span></span><br><span class="line">  UsageFault_IRQn             = <span class="number">-10</span>,    <span class="comment">/*!&lt; 6 Cortex-M4 Usage Fault Interrupt                                 */</span></span><br><span class="line">  SVCall_IRQn                 = <span class="number">-5</span>,     <span class="comment">/*!&lt; 11 Cortex-M4 SV Call Interrupt                                    */</span></span><br><span class="line">  DebugMonitor_IRQn           = <span class="number">-4</span>,     <span class="comment">/*!&lt; 12 Cortex-M4 Debug Monitor Interrupt                              */</span></span><br><span class="line">  PendSV_IRQn                 = <span class="number">-2</span>,     <span class="comment">/*!&lt; 14 Cortex-M4 Pend SV Interrupt                                    */</span></span><br><span class="line">  SysTick_IRQn                = <span class="number">-1</span>,     <span class="comment">/*!&lt; 15 Cortex-M4 System Tick Interrupt                                */</span></span><br><span class="line">  <span class="comment">/******  STM32 specific Interrupt Numbers **********************************************************************/</span></span><br><span class="line">  WWDG_IRQn                   = <span class="number">0</span>,      <span class="comment">/*!&lt; Window WatchDog Interrupt                                         */</span></span><br><span class="line">  PVD_IRQn                    = <span class="number">1</span>,      <span class="comment">/*!&lt; PVD through EXTI Line detection Interrupt                         */</span></span><br><span class="line">  TAMP_STAMP_IRQn             = <span class="number">2</span>,      <span class="comment">/*!&lt; Tamper and TimeStamp interrupts through the EXTI line             */</span></span><br><span class="line">  RTC_WKUP_IRQn               = <span class="number">3</span>,      <span class="comment">/*!&lt; RTC Wakeup interrupt through the EXTI line                        */</span></span><br><span class="line">  FLASH_IRQn                  = <span class="number">4</span>,      <span class="comment">/*!&lt; FLASH global Interrupt                                            */</span></span><br><span class="line">  RCC_IRQn                    = <span class="number">5</span>,      <span class="comment">/*!&lt; RCC global Interrupt                                              */</span></span><br><span class="line">  EXTI0_IRQn                  = <span class="number">6</span>,      <span class="comment">/*!&lt; EXTI Line0 Interrupt                                              */</span></span><br><span class="line">  EXTI1_IRQn                  = <span class="number">7</span>,      <span class="comment">/*!&lt; EXTI Line1 Interrupt                                              */</span></span><br><span class="line">  EXTI2_IRQn                  = <span class="number">8</span>,      <span class="comment">/*!&lt; EXTI Line2 Interrupt                                              */</span></span><br><span class="line">  EXTI3_IRQn                  = <span class="number">9</span>,      <span class="comment">/*!&lt; EXTI Line3 Interrupt                                              */</span></span><br><span class="line">  EXTI4_IRQn                  = <span class="number">10</span>,     <span class="comment">/*!&lt; EXTI Line4 Interrupt                                              */</span></span><br><span class="line">  DMA1_Stream0_IRQn           = <span class="number">11</span>,     <span class="comment">/*!&lt; DMA1 Stream 0 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream1_IRQn           = <span class="number">12</span>,     <span class="comment">/*!&lt; DMA1 Stream 1 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream2_IRQn           = <span class="number">13</span>,     <span class="comment">/*!&lt; DMA1 Stream 2 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream3_IRQn           = <span class="number">14</span>,     <span class="comment">/*!&lt; DMA1 Stream 3 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream4_IRQn           = <span class="number">15</span>,     <span class="comment">/*!&lt; DMA1 Stream 4 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream5_IRQn           = <span class="number">16</span>,     <span class="comment">/*!&lt; DMA1 Stream 5 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream6_IRQn           = <span class="number">17</span>,     <span class="comment">/*!&lt; DMA1 Stream 6 global Interrupt                                    */</span></span><br><span class="line">  ADC_IRQn                    = <span class="number">18</span>,     <span class="comment">/*!&lt; ADC1, ADC2 and ADC3 global Interrupts                             */</span></span><br><span class="line">  CAN1_TX_IRQn                = <span class="number">19</span>,     <span class="comment">/*!&lt; CAN1 TX Interrupt                                                 */</span></span><br><span class="line">  CAN1_RX0_IRQn               = <span class="number">20</span>,     <span class="comment">/*!&lt; CAN1 RX0 Interrupt                                                */</span></span><br><span class="line">  CAN1_RX1_IRQn               = <span class="number">21</span>,     <span class="comment">/*!&lt; CAN1 RX1 Interrupt                                                */</span></span><br><span class="line">  CAN1_SCE_IRQn               = <span class="number">22</span>,     <span class="comment">/*!&lt; CAN1 SCE Interrupt                                                */</span></span><br><span class="line">  EXTI9_5_IRQn                = <span class="number">23</span>,     <span class="comment">/*!&lt; External Line[9:5] Interrupts                                     */</span></span><br><span class="line">  TIM1_BRK_TIM9_IRQn          = <span class="number">24</span>,     <span class="comment">/*!&lt; TIM1 Break interrupt and TIM9 global interrupt                    */</span></span><br><span class="line">  TIM1_UP_TIM10_IRQn          = <span class="number">25</span>,     <span class="comment">/*!&lt; TIM1 Update Interrupt and TIM10 global interrupt                  */</span></span><br><span class="line">  TIM1_TRG_COM_TIM11_IRQn     = <span class="number">26</span>,     <span class="comment">/*!&lt; TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */</span></span><br><span class="line">  TIM1_CC_IRQn                = <span class="number">27</span>,     <span class="comment">/*!&lt; TIM1 Capture Compare Interrupt                                    */</span></span><br><span class="line">  TIM2_IRQn                   = <span class="number">28</span>,     <span class="comment">/*!&lt; TIM2 global Interrupt                                             */</span></span><br><span class="line">  TIM3_IRQn                   = <span class="number">29</span>,     <span class="comment">/*!&lt; TIM3 global Interrupt                                             */</span></span><br><span class="line">  TIM4_IRQn                   = <span class="number">30</span>,     <span class="comment">/*!&lt; TIM4 global Interrupt                                             */</span></span><br><span class="line">  I2C1_EV_IRQn                = <span class="number">31</span>,     <span class="comment">/*!&lt; I2C1 Event Interrupt                                              */</span></span><br><span class="line">  I2C1_ER_IRQn                = <span class="number">32</span>,     <span class="comment">/*!&lt; I2C1 Error Interrupt                                              */</span></span><br><span class="line">  I2C2_EV_IRQn                = <span class="number">33</span>,     <span class="comment">/*!&lt; I2C2 Event Interrupt                                              */</span></span><br><span class="line">  I2C2_ER_IRQn                = <span class="number">34</span>,     <span class="comment">/*!&lt; I2C2 Error Interrupt                                              */</span></span><br><span class="line">  SPI1_IRQn                   = <span class="number">35</span>,     <span class="comment">/*!&lt; SPI1 global Interrupt                                             */</span></span><br><span class="line">  SPI2_IRQn                   = <span class="number">36</span>,     <span class="comment">/*!&lt; SPI2 global Interrupt                                             */</span></span><br><span class="line">  USART1_IRQn                 = <span class="number">37</span>,     <span class="comment">/*!&lt; USART1 global Interrupt                                           */</span></span><br><span class="line">  USART2_IRQn                 = <span class="number">38</span>,     <span class="comment">/*!&lt; USART2 global Interrupt                                           */</span></span><br><span class="line">  USART3_IRQn                 = <span class="number">39</span>,     <span class="comment">/*!&lt; USART3 global Interrupt                                           */</span></span><br><span class="line">  EXTI15_10_IRQn              = <span class="number">40</span>,     <span class="comment">/*!&lt; External Line[15:10] Interrupts                                   */</span></span><br><span class="line">  RTC_Alarm_IRQn              = <span class="number">41</span>,     <span class="comment">/*!&lt; RTC Alarm (A and B) through EXTI Line Interrupt                   */</span></span><br><span class="line">  OTG_FS_WKUP_IRQn            = <span class="number">42</span>,     <span class="comment">/*!&lt; USB OTG FS Wakeup through EXTI line interrupt                     */</span></span><br><span class="line">  TIM8_BRK_TIM12_IRQn         = <span class="number">43</span>,     <span class="comment">/*!&lt; TIM8 Break Interrupt and TIM12 global interrupt                   */</span></span><br><span class="line">  TIM8_UP_TIM13_IRQn          = <span class="number">44</span>,     <span class="comment">/*!&lt; TIM8 Update Interrupt and TIM13 global interrupt                  */</span></span><br><span class="line">  TIM8_TRG_COM_TIM14_IRQn     = <span class="number">45</span>,     <span class="comment">/*!&lt; TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */</span></span><br><span class="line">  TIM8_CC_IRQn                = <span class="number">46</span>,     <span class="comment">/*!&lt; TIM8 Capture Compare global interrupt                             */</span></span><br><span class="line">  DMA1_Stream7_IRQn           = <span class="number">47</span>,     <span class="comment">/*!&lt; DMA1 Stream7 Interrupt                                            */</span></span><br><span class="line">  FSMC_IRQn                   = <span class="number">48</span>,     <span class="comment">/*!&lt; FSMC global Interrupt                                             */</span></span><br><span class="line">  SDIO_IRQn                   = <span class="number">49</span>,     <span class="comment">/*!&lt; SDIO global Interrupt                                             */</span></span><br><span class="line">  TIM5_IRQn                   = <span class="number">50</span>,     <span class="comment">/*!&lt; TIM5 global Interrupt                                             */</span></span><br><span class="line">  SPI3_IRQn                   = <span class="number">51</span>,     <span class="comment">/*!&lt; SPI3 global Interrupt                                             */</span></span><br><span class="line">  UART4_IRQn                  = <span class="number">52</span>,     <span class="comment">/*!&lt; UART4 global Interrupt                                            */</span></span><br><span class="line">  UART5_IRQn                  = <span class="number">53</span>,     <span class="comment">/*!&lt; UART5 global Interrupt                                            */</span></span><br><span class="line">  TIM6_DAC_IRQn               = <span class="number">54</span>,     <span class="comment">/*!&lt; TIM6 global and DAC1&amp;2 underrun error  interrupts                 */</span></span><br><span class="line">  TIM7_IRQn                   = <span class="number">55</span>,     <span class="comment">/*!&lt; TIM7 global interrupt                                             */</span></span><br><span class="line">  DMA2_Stream0_IRQn           = <span class="number">56</span>,     <span class="comment">/*!&lt; DMA2 Stream 0 global Interrupt                                    */</span></span><br><span class="line">  DMA2_Stream1_IRQn           = <span class="number">57</span>,     <span class="comment">/*!&lt; DMA2 Stream 1 global Interrupt                                    */</span></span><br><span class="line">  DMA2_Stream2_IRQn           = <span class="number">58</span>,     <span class="comment">/*!&lt; DMA2 Stream 2 global Interrupt                                    */</span></span><br><span class="line">  DMA2_Stream3_IRQn           = <span class="number">59</span>,     <span class="comment">/*!&lt; DMA2 Stream 3 global Interrupt                                    */</span></span><br><span class="line">  DMA2_Stream4_IRQn           = <span class="number">60</span>,     <span class="comment">/*!&lt; DMA2 Stream 4 global Interrupt                                    */</span></span><br><span class="line">  ETH_IRQn                    = <span class="number">61</span>,     <span class="comment">/*!&lt; Ethernet global Interrupt                                         */</span></span><br><span class="line">  ETH_WKUP_IRQn               = <span class="number">62</span>,     <span class="comment">/*!&lt; Ethernet Wakeup through EXTI line Interrupt                       */</span></span><br><span class="line">  CAN2_TX_IRQn                = <span class="number">63</span>,     <span class="comment">/*!&lt; CAN2 TX Interrupt                                                 */</span></span><br><span class="line">  CAN2_RX0_IRQn               = <span class="number">64</span>,     <span class="comment">/*!&lt; CAN2 RX0 Interrupt                                                */</span></span><br><span class="line">  CAN2_RX1_IRQn               = <span class="number">65</span>,     <span class="comment">/*!&lt; CAN2 RX1 Interrupt                                                */</span></span><br><span class="line">  CAN2_SCE_IRQn               = <span class="number">66</span>,     <span class="comment">/*!&lt; CAN2 SCE Interrupt                                                */</span></span><br><span class="line">  OTG_FS_IRQn                 = <span class="number">67</span>,     <span class="comment">/*!&lt; USB OTG FS global Interrupt                                       */</span></span><br><span class="line">  DMA2_Stream5_IRQn           = <span class="number">68</span>,     <span class="comment">/*!&lt; DMA2 Stream 5 global interrupt                                    */</span></span><br><span class="line">  DMA2_Stream6_IRQn           = <span class="number">69</span>,     <span class="comment">/*!&lt; DMA2 Stream 6 global int   terrupt                                    */</span></span><br><span class="line">  USART6_IRQn                 = <span class="number">71</span>,     <span class="comment">/*!&lt; USART6 global interrupt                                           */</span></span><br><span class="line">  I2C3_EV_IRQn                = <span class="number">72</span>,     <span class="comment">/*!&lt; I2C3 event interrupt                                              */</span></span><br><span class="line">  I2C3_ER_IRQn                = <span class="number">73</span>,     <span class="comment">/*!&lt; I2C3 error interrupt                                              */</span></span><br><span class="line">  OTG_HS_EP1_OUT_IRQn         = <span class="number">74</span>,     <span class="comment">/*!&lt; USB OTG HS End Point 1 Out global interrupt                       */</span></span><br><span class="line">  OTG_HS_EP1_IN_IRQn          = <span class="number">75</span>,     <span class="comment">/*!&lt; USB OTG HS End Point 1 In global interrupt                        */</span></span><br><span class="line">  OTG_HS_WKUP_IRQn            = <span class="number">76</span>,     <span class="comment">/*!&lt; USB OTG HS Wakeup through EXTI interrupt                          */</span></span><br><span class="line">  OTG_HS_IRQn                 = <span class="number">77</span>,     <span class="comment">/*!&lt; USB OTG HS global interrupt                                       */</span></span><br><span class="line">  DCMI_IRQn                   = <span class="number">78</span>,     <span class="comment">/*!&lt; DCMI global interrupt                                             */</span></span><br><span class="line">  RNG_IRQn                    = <span class="number">80</span>,     <span class="comment">/*!&lt; RNG global Interrupt                                              */</span></span><br><span class="line">  FPU_IRQn                    = <span class="number">81</span>      <span class="comment">/*!&lt; FPU global interrupt                                               */</span></span><br><span class="line">&#125; IRQn_Type;</span><br></pre></td></tr></table></figure><h3 id="PreemptPriority（抢占优先级）和SubPriority-响应优先级"><a href="#PreemptPriority（抢占优先级）和SubPriority-响应优先级" class="headerlink" title="PreemptPriority（抢占优先级）和SubPriority (响应优先级)"></a>PreemptPriority（抢占优先级）和SubPriority (响应优先级)</h3><p>可输入0-15（十进制），对应抢占优先级/响应优先级的大小，数字越小优先级越高。朝IPR寄存器内写入，优先级的输入范围随Group设置范围变化。</p><h2 id="使能-失能中断-NVIC"><a href="#使能-失能中断-NVIC" class="headerlink" title="使能/失能中断(NVIC)"></a>使能/失能中断(NVIC)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_NVIC_EnableIRQ</span><span class="params">(IRQn_Type IRQn)</span> <span class="comment">//使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_NVIC_DisableIRQ</span><span class="params">(IRQn_Type IRQn)</span> <span class="comment">//失能</span></span><br></pre></td></tr></table></figure><p>其输入参数IRQn(中断号) 同上。用于指明控制哪一个中断。</p><h2 id="配置EXTI模式和映射IO"><a href="#配置EXTI模式和映射IO" class="headerlink" title="配置EXTI模式和映射IO"></a>配置EXTI模式和映射IO</h2><p>在HAL库中，配置EXTI寄存器上沿/下沿触发，映射IO，都通过在引脚初始化时，设置GPIO_InitTypeDef.mode实现。可设置参数如下，详见GPIO章节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_RISING             <span class="comment">//具有上升沿触发检测的外部中断模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_FALLING            <span class="comment">//具有下降沿触发检测的外部中断模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_RISING_FALLING     <span class="comment">//上升沿和下降沿均触发的外部中断模式</span></span></span><br><span class="line"><span class="comment">//下面几个对应的是&quot;事件&quot;,RISING,FALLING等含义同中断.在这里事件可以唤醒休眠状态(WFE)的MCU,但是不会产生&quot;中断事件&quot;,也就是说不会执行中断处理函数,也就说不需要清除外设中断挂起位或 NVIC. 使用GPIO&quot;事件&quot;来启动AD转换也是可以的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_RISING                   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_FALLING                  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_RISING_FALLING        </span></span><br></pre></td></tr></table></figure><h2 id="清除中断flag"><a href="#清除中断flag" class="headerlink" title="清除中断flag"></a>清除中断flag</h2><p>HAL库中中断flag会在调用回调函数前自动通过宏清除，宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI-&gt;PR = (__EXTI_LINE__))</span></span><br></pre></td></tr></table></figure><p>这个过程无需人为干预</p><h2 id="中断Handler"><a href="#中断Handler" class="headerlink" title="中断Handler"></a>中断Handler</h2><p>在进入中断时，我们需要编写中断执行的函数，STM32不同于大部分单片机中断函数都叫interrupt，它不同的中断会调用各自不同的函数。这些中断函数在startup文件中被定义，称之为“中断向量表”。以下是定义代码和对应的名称。<strong>在使用CubeMX初始化代码时，这些Handler会被定义在stm32fxxx_it.c文件中，可以直接在it.c文件中对中断进行编辑。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler                   ; Window WatchDog                                        </span><br><span class="line">                DCD     PVD_IRQHandler                    ; PVD through EXTI Line detection                        </span><br><span class="line">                DCD     TAMP_STAMP_IRQHandler             ; Tamper and TimeStamps through the EXTI line            </span><br><span class="line">                DCD     RTC_WKUP_IRQHandler               ; RTC Wakeup through the EXTI line                       </span><br><span class="line">                DCD     FLASH_IRQHandler                  ; FLASH                                           </span><br><span class="line">                DCD     RCC_IRQHandler                    ; RCC                                             </span><br><span class="line">                DCD     EXTI0_IRQHandler                  ; EXTI Line0                                             </span><br><span class="line">                DCD     EXTI1_IRQHandler                  ; EXTI Line1                                             </span><br><span class="line">                DCD     EXTI2_IRQHandler                  ; EXTI Line2                                             </span><br><span class="line">                DCD     EXTI3_IRQHandler                  ; EXTI Line3                                             </span><br><span class="line">                DCD     EXTI4_IRQHandler                  ; EXTI Line4                                             </span><br><span class="line">                DCD     DMA1_Stream0_IRQHandler           ; DMA1 Stream 0                                   </span><br><span class="line">                DCD     DMA1_Stream1_IRQHandler           ; DMA1 Stream 1                                   </span><br><span class="line">                DCD     DMA1_Stream2_IRQHandler           ; DMA1 Stream 2                                   </span><br><span class="line">                DCD     DMA1_Stream3_IRQHandler           ; DMA1 Stream 3                                   </span><br><span class="line">                DCD     DMA1_Stream4_IRQHandler           ; DMA1 Stream 4                                   </span><br><span class="line">                DCD     DMA1_Stream5_IRQHandler           ; DMA1 Stream 5                                   </span><br><span class="line">                DCD     DMA1_Stream6_IRQHandler           ; DMA1 Stream 6                                   </span><br><span class="line">                DCD     ADC_IRQHandler                    ; ADC1, ADC2 and ADC3s                            </span><br><span class="line">                DCD     CAN1_TX_IRQHandler                ; CAN1 TX                                                </span><br><span class="line">                DCD     CAN1_RX0_IRQHandler               ; CAN1 RX0                                               </span><br><span class="line">                DCD     CAN1_RX1_IRQHandler               ; CAN1 RX1                                               </span><br><span class="line">                DCD     CAN1_SCE_IRQHandler               ; CAN1 SCE                                               </span><br><span class="line">                DCD     EXTI9_5_IRQHandler                ; External Line[9:5]s                                    </span><br><span class="line">                DCD     TIM1_BRK_TIM9_IRQHandler          ; TIM1 Break and TIM9                   </span><br><span class="line">                DCD     TIM1_UP_TIM10_IRQHandler          ; TIM1 Update and TIM10                 </span><br><span class="line">                DCD     TIM1_TRG_COM_TIM11_IRQHandler     ; TIM1 Trigger and Commutation and TIM11</span><br><span class="line">                DCD     TIM1_CC_IRQHandler                ; TIM1 Capture Compare                                   </span><br><span class="line">                DCD     TIM2_IRQHandler                   ; TIM2                                            </span><br><span class="line">                DCD     TIM3_IRQHandler                   ; TIM3                                            </span><br><span class="line">                DCD     TIM4_IRQHandler                   ; TIM4                                            </span><br><span class="line">                DCD     I2C1_EV_IRQHandler                ; I2C1 Event                                             </span><br><span class="line">                DCD     I2C1_ER_IRQHandler                ; I2C1 Error                                             </span><br><span class="line">                DCD     I2C2_EV_IRQHandler                ; I2C2 Event                                             </span><br><span class="line">                DCD     I2C2_ER_IRQHandler                ; I2C2 Error                                               </span><br><span class="line">                DCD     SPI1_IRQHandler                   ; SPI1                                            </span><br><span class="line">                DCD     SPI2_IRQHandler                   ; SPI2                                            </span><br><span class="line">                DCD     USART1_IRQHandler                 ; USART1                                          </span><br><span class="line">                DCD     USART2_IRQHandler                 ; USART2                                          </span><br><span class="line">                DCD     USART3_IRQHandler                 ; USART3                                          </span><br><span class="line">                DCD     EXTI15_10_IRQHandler              ; External Line[15:10]s                                  </span><br><span class="line">                DCD     RTC_Alarm_IRQHandler              ; RTC Alarm (A and B) through EXTI Line                  </span><br><span class="line">                DCD     OTG_FS_WKUP_IRQHandler            ; USB OTG FS Wakeup through EXTI line                        </span><br><span class="line">                DCD     TIM8_BRK_TIM12_IRQHandler         ; TIM8 Break and TIM12                  </span><br><span class="line">                DCD     TIM8_UP_TIM13_IRQHandler          ; TIM8 Update and TIM13                 </span><br><span class="line">                DCD     TIM8_TRG_COM_TIM14_IRQHandler     ; TIM8 Trigger and Commutation and TIM14</span><br><span class="line">                DCD     TIM8_CC_IRQHandler                ; TIM8 Capture Compare                                   </span><br><span class="line">                DCD     DMA1_Stream7_IRQHandler           ; DMA1 Stream7                                           </span><br><span class="line">                DCD     FMC_IRQHandler                    ; FMC                                             </span><br><span class="line">                DCD     SDIO_IRQHandler                   ; SDIO                                            </span><br><span class="line">                DCD     TIM5_IRQHandler                   ; TIM5                                            </span><br><span class="line">                DCD     SPI3_IRQHandler                   ; SPI3                                            </span><br><span class="line">                DCD     UART4_IRQHandler                  ; UART4                                           </span><br><span class="line">                DCD     UART5_IRQHandler                  ; UART5                                           </span><br><span class="line">                DCD     TIM6_DAC_IRQHandler               ; TIM6 and DAC1&amp;2 underrun errors                   </span><br><span class="line">                DCD     TIM7_IRQHandler                   ; TIM7                   </span><br><span class="line">                DCD     DMA2_Stream0_IRQHandler           ; DMA2 Stream 0                                   </span><br><span class="line">                DCD     DMA2_Stream1_IRQHandler           ; DMA2 Stream 1                                   </span><br><span class="line">                DCD     DMA2_Stream2_IRQHandler           ; DMA2 Stream 2                                   </span><br><span class="line">                DCD     DMA2_Stream3_IRQHandler           ; DMA2 Stream 3                                   </span><br><span class="line">                DCD     DMA2_Stream4_IRQHandler           ; DMA2 Stream 4                                   </span><br><span class="line">                DCD     ETH_IRQHandler                    ; Ethernet                                        </span><br><span class="line">                DCD     ETH_WKUP_IRQHandler               ; Ethernet Wakeup through EXTI line                      </span><br><span class="line">                DCD     CAN2_TX_IRQHandler                ; CAN2 TX                                                </span><br><span class="line">                DCD     CAN2_RX0_IRQHandler               ; CAN2 RX0                                               </span><br><span class="line">                DCD     CAN2_RX1_IRQHandler               ; CAN2 RX1                                               </span><br><span class="line">                DCD     CAN2_SCE_IRQHandler               ; CAN2 SCE                                               </span><br><span class="line">                DCD     OTG_FS_IRQHandler                 ; USB OTG FS                                      </span><br><span class="line">                DCD     DMA2_Stream5_IRQHandler           ; DMA2 Stream 5                                   </span><br><span class="line">                DCD     DMA2_Stream6_IRQHandler           ; DMA2 Stream 6                                   </span><br><span class="line">                DCD     DMA2_Stream7_IRQHandler           ; DMA2 Stream 7                                   </span><br><span class="line">                DCD     USART6_IRQHandler                 ; USART6                                           </span><br><span class="line">                DCD     I2C3_EV_IRQHandler                ; I2C3 event                                             </span><br><span class="line">                DCD     I2C3_ER_IRQHandler                ; I2C3 error                                             </span><br><span class="line">                DCD     OTG_HS_EP1_OUT_IRQHandler         ; USB OTG HS End Point 1 Out                      </span><br><span class="line">                DCD     OTG_HS_EP1_IN_IRQHandler          ; USB OTG HS End Point 1 In                       </span><br><span class="line">                DCD     OTG_HS_WKUP_IRQHandler            ; USB OTG HS Wakeup through EXTI                         </span><br><span class="line">                DCD     OTG_HS_IRQHandler                 ; USB OTG HS                                      </span><br><span class="line">                DCD     DCMI_IRQHandler                   ; DCMI  </span><br><span class="line">                DCD     0                                 ; Reserved                              </span><br><span class="line">                DCD     HASH_RNG_IRQHandler               ; Hash and Rng</span><br><span class="line">                DCD     FPU_IRQHandler                    ; FPU</span><br><span class="line">                </span><br><span class="line">                                         </span><br><span class="line">__Vectors_End</span><br></pre></td></tr></table></figure><h2 id="HAL库的中断处理流程"><a href="#HAL库的中断处理流程" class="headerlink" title="HAL库的中断处理流程"></a>HAL库的中断处理流程</h2><h3 id="CubeMX-HAL工程中断初始化的流程"><a href="#CubeMX-HAL工程中断初始化的流程" class="headerlink" title="CubeMX+HAL工程中断初始化的流程"></a>CubeMX+HAL工程中断初始化的流程</h3><p>如果我们采用寄存器编程，以初始化映射至IO的EXTI中断为例，那么需要经历以下步骤：</p><ol><li>使能GPIO时钟和NVIC、EXTI总线时钟</li><li>设置GPIO模式（输入、是否上拉等）</li><li>设置EXTI和GPIO的映射关系（设置APIO或STYSCFG寄存器）</li><li>设置边沿触发模式(RTSR,FTSR)、enbale中断(IMR/EMR)</li><li>设置NVIC分组模式</li><li>设置NVIC优先级模式</li><li>使能NVIC对应中断</li></ol><p>在使用CubeMX生成的工程中，1,2,3,4都是在MX_GPIO_Init()函数内完成。如果是映射至IO的EXTI的中断，那么MX_GPIO_Init()函数内还会完成相应中断的优先级设置和使能，也就是6,7；如果是其他中断，那么在相应外设的init函数中也会完成优先级设置和使能。</p><p>鉴于NVIC的分组模式一般不会更改，因此NVIC的分组在一开始就被设置，CubeMX+HAL库生成的工程会在HAL_Init()函数中完成。</p><p>main函数中，会依次调用这三个函数来完成整个系统的初始化，其中便囊括了中断的初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_Init();<span class="comment">//完成步骤5，设置分组</span></span><br><span class="line">SystemClock_Config();</span><br><span class="line">MX_GPIO_Init();<span class="comment">//完成步骤1.2.3.4.6.7;初始化GPIO并配置和映射EXTI线，然后使能NVIC对应的中断</span></span><br></pre></td></tr></table></figure><h3 id="中断调用函数的流程"><a href="#中断调用函数的流程" class="headerlink" title="中断调用函数的流程"></a>中断调用函数的流程</h3><p>在中断被触发时，STM32首先会调用Handler，也就是下方 <em>中断Handler</em> 小节内介绍的这些。这些Handler的内容存储在stm32fxxx_it.c。Hander函数内首先调用公共中断函数，来实现清除中断标志等，然后调用回调函数执行处理的内容。这里面用户可直接编辑Handler函数的内容，来决定其调用哪些公共函数，也可自行重新定义Callback函数的内容，来编写中断处理程序。</p><p>这个流程的函数伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xxx_IRQHandler</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//public interrupt functions</span></span><br><span class="line">xxx_public_INT_Func(specific parameters);<span class="comment">//e.g. HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">xxx_public_INT_Func</span><span class="params">(parameters)</span>&#123;</span><br><span class="line">public_funcs(parameters);<span class="comment">// e.g. __HAL_GPIO_EXTI_CLEAR_IT(GOIO_Pin)</span></span><br><span class="line">Callback_func(parameters);<span class="comment">// e.g. HAL_GPIO_EXTI_Callback(GPIO_Pin)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Callback_func</span><span class="params">(parameters)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parameters == xx)&#123;</span><br><span class="line">        <span class="comment">//do sth</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameters == yy)&#123;</span><br><span class="line">        <span class="comment">//do sth</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//interrupt Processing code, written by user</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，callback函数是弱定义的，例如EXTI的回调函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br></pre></td></tr></table></figure><p><strong>因此，在HAL库中使用中断时，用户只需要自定重新定义回调函数部分，找到不同中断Handler调用的回调函数，在回调函数部分写入中断处理的代码即可。</strong>通常来说，用户只需要自己重新定义Callback fucntion，并根据传入的参数不同，使用if编写不同中断源的处理程序即可。但是再多个外设共用一个回调函数时，这些if可能需要写非常多，这样不便于管理，因此直接把处理函数写在其自己的驱动文件内，然后在xxx_IRQHandler() 内调用即可。</p><hr><h1 id="UART串口"><a href="#UART串口" class="headerlink" title="UART串口"></a>UART串口</h1><h2 id="huart句柄"><a href="#huart句柄" class="headerlink" title="huart句柄"></a>huart句柄</h2><p>这是一个调用和uart相关HAL库接口时，需要传入的参数，用于说明数据从哪个串口进来，串口的基本设置参数。这个参数被称为”handel”，也就是huart中h的来源，可以理解为握着uart1的handel，就可以控制和操作uart1的意思。其源代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">UART_HandleTypeDef</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  USART_TypeDef                 *Instance;        <span class="comment">/*!&lt; UART 控制寄存器基地址        */</span></span><br><span class="line">  UART_InitTypeDef              Init;             <span class="comment">/*!&lt; UART 串口初始化数据类型      */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>                 *pTxBuffPtr;      <span class="comment">/*!&lt; 发送buffer地址 */</span></span><br><span class="line">  <span class="type">uint16_t</span>                      TxXferSize;       <span class="comment">/*!&lt; 发送数据个数             */</span></span><br><span class="line">  __IO <span class="type">uint16_t</span>                 TxXferCount;      <span class="comment">/*!&lt; 发送数据计数器           */</span></span><br><span class="line">  <span class="type">uint8_t</span>                       *pRxBuffPtr;      <span class="comment">/*!&lt; 接收buffer地址*/</span></span><br><span class="line">  <span class="type">uint16_t</span>                      RxXferSize;       <span class="comment">/*!&lt; 接收数据个数            */</span></span><br><span class="line">  __IO <span class="type">uint16_t</span>                 RxXferCount;      <span class="comment">/*!&lt; 接收数据计数器           */</span></span><br><span class="line">  __IO HAL_UART_RxTypeTypeDef ReceptionType;      <span class="comment">/*!&lt; Type of ongoing reception          */</span></span><br><span class="line">  __IO HAL_UART_RxEventTypeTypeDef RxEventType;   <span class="comment">/*!&lt; Type of Rx Event                   */</span></span><br><span class="line">  DMA_HandleTypeDef             *hdmatx;          <span class="comment">/*!&lt; UART Tx DMA Handle parameters      */</span></span><br><span class="line">  DMA_HandleTypeDef             *hdmarx;          <span class="comment">/*!&lt; UART Rx DMA Handle parameters      */</span></span><br><span class="line">  HAL_LockTypeDef               Lock;             <span class="comment">/*!&lt; Locking object                     */</span></span><br><span class="line">  __IO HAL_UART_StateTypeDef    gState;           <span class="comment">/*!&lt; UART state information related to global Handle management</span></span><br><span class="line"><span class="comment">                                                       and also related to Tx operations.</span></span><br><span class="line"><span class="comment">                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef */</span></span><br><span class="line">  __IO HAL_UART_StateTypeDef    RxState;          <span class="comment">/*!&lt; UART state information related to Rx operations.</span></span><br><span class="line"><span class="comment">                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span>                 ErrorCode;        <span class="comment">/*!&lt; UART Error code                    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (USE_HAL_UART_REGISTER_CALLBACKS == 1)</span></span><br><span class="line">  <span class="type">void</span> (* TxHalfCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);        <span class="comment">/*!&lt; UART Tx Half Complete Callback        */</span></span><br><span class="line">  <span class="type">void</span> (* TxCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);            <span class="comment">/*!&lt; UART Tx Complete Callback             */</span></span><br><span class="line">  <span class="type">void</span> (* RxHalfCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);        <span class="comment">/*!&lt; UART Rx Half Complete Callback        */</span></span><br><span class="line">  <span class="type">void</span> (* RxCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);            <span class="comment">/*!&lt; UART Rx Complete Callback             */</span></span><br><span class="line">  <span class="type">void</span> (* ErrorCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);             <span class="comment">/*!&lt; UART Error Callback                   */</span></span><br><span class="line">  <span class="type">void</span> (* AbortCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);         <span class="comment">/*!&lt; UART Abort Complete Callback          */</span></span><br><span class="line">  <span class="type">void</span> (* AbortTransmitCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart); <span class="comment">/*!&lt; UART Abort Transmit Complete Callback */</span></span><br><span class="line">  <span class="type">void</span> (* AbortReceiveCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);  <span class="comment">/*!&lt; UART Abort Receive Complete Callback  */</span></span><br><span class="line">  <span class="type">void</span> (* WakeupCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);            <span class="comment">/*!&lt; UART Wakeup Callback                  */</span></span><br><span class="line">  <span class="type">void</span> (* RxEventCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Pos); <span class="comment">/*!&lt; UART Reception Event Callback     */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (* MspInitCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);           <span class="comment">/*!&lt; UART Msp Init callback                */</span></span><br><span class="line">  <span class="type">void</span> (* MspDeInitCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);         <span class="comment">/*!&lt; UART Msp DeInit callback              */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* USE_HAL_UART_REGISTER_CALLBACKS */</span></span></span><br><span class="line"></span><br><span class="line">&#125; UART_HandleTypeDef;</span><br></pre></td></tr></table></figure><h3 id="USART-TypeDef"><a href="#USART-TypeDef" class="headerlink" title="USART_TypeDef"></a>USART_TypeDef</h3><p>该结构体用于参数UASRT硬件的寄存器基地址，结构体定义如下：</p><p>在创建 $USART_TypeDef\ *$ 类型，以某一个串口配置寄存器开始的结构体指针后，便可以访问该串口的配置寄存器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> SR;         <span class="comment">/*!&lt; USART Status register,                   Address offset: 0x00 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> DR;         <span class="comment">/*!&lt; USART Data register,                     Address offset: 0x04 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> BRR;        <span class="comment">/*!&lt; USART Baud rate register,                Address offset: 0x08 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CR1;        <span class="comment">/*!&lt; USART Control register 1,                Address offset: 0x0C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CR2;        <span class="comment">/*!&lt; USART Control register 2,                Address offset: 0x10 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CR3;        <span class="comment">/*!&lt; USART Control register 3,                Address offset: 0x14 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> GTPR;       <span class="comment">/*!&lt; USART Guard time and prescaler register, Address offset: 0x18 */</span></span><br><span class="line">&#125; USART_TypeDef;</span><br></pre></td></tr></table></figure><p>该结构体的基地址变量，由总线基地址+偏移地址宏定义，例如F407定义的USART1和2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USART1_BASE           (APB2PERIPH_BASE + 0x1000UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART2_BASE           (APB1PERIPH_BASE + 0x4400UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART1              ((USART_TypeDef *) USART1_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART2              ((USART_TypeDef *) USART2_BASE)</span></span><br></pre></td></tr></table></figure><p>对于F4系列，有6个串口：USART1-3，UART4-5，USART6，他们都通过如上代码宏定义了基地址，因此给结构体成员Instance传入这些地址即可。</p><h3 id="UART-InitTypeDef"><a href="#UART-InitTypeDef" class="headerlink" title="UART_InitTypeDef"></a>UART_InitTypeDef</h3><p>该结构体用于存放UART通信中的一些基本参数，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> BaudRate; <span class="comment">//波特率</span></span><br><span class="line">  <span class="type">uint32_t</span> WordLength; <span class="comment">//数据长度</span></span><br><span class="line">  <span class="type">uint32_t</span> StopBits; <span class="comment">//停止位长度</span></span><br><span class="line">  <span class="type">uint32_t</span> Parity; <span class="comment">//奇偶校验配置</span></span><br><span class="line">  <span class="type">uint32_t</span> Mode;<span class="comment">// UART收发模式设置（收、发、同时收发）</span></span><br><span class="line">  <span class="type">uint32_t</span> HwFlowCtl; <span class="comment">//硬件流控制</span></span><br><span class="line">  <span class="type">uint32_t</span> OverSampling; <span class="comment">//过采样设置</span></span><br><span class="line">&#125; UART_InitTypeDef;</span><br></pre></td></tr></table></figure><ul><li><p><strong>BaudRate:</strong> 直接设置波特率数字即可</p></li><li><p><strong>WordLength:</strong> 宏定义了 UART_WORDLENGTH_8B 和 UART_WORDLENGTH_9B 两种，分别对应8bit和9bit数据位</p></li><li><p><strong>StopBits:</strong> 宏定义 UART_STOPBITS_1，UART_STOPBITS_2 两种输入，分别对应1个停止位和2个</p></li><li><strong>Parity：</strong>有 UART_PARITY_NONE，UART_PARITY_EVEN，UART_PARITY_ODD 三种，分别对应无、偶校验、奇校验</li><li><strong>Mode:</strong> 有UART_MODE_RX，UART_MODE_TX，UART_MODE_TX_RX 三种，分别对应单收、单发、同时收发三种工作模式</li><li><strong>HwFlowCtl:</strong> 有UART_HWCONTROL_NONE，UART_HWCONTROL_RTS，UART_HWCONTROL_CTS，UART_HWCONTROL_RTS_CTS四种输入，分别对应无硬件流控制，接受流控制，发送流控制，同时启用接受发送流控制。</li><li><strong>OverSampling：</strong> UART_OVERSAMPLING_16，UART_OVERSAMPLING_8两种，对应16位过采样和8位，F1系列不可配置</li></ul><h2 id="串口初始化"><a href="#串口初始化" class="headerlink" title="串口初始化"></a>串口初始化</h2><h3 id="轮询方式收发的初始化"><a href="#轮询方式收发的初始化" class="headerlink" title="轮询方式收发的初始化"></a>轮询方式收发的初始化</h3><p>使用轮询模式时，只需要先配置huart中Init结构体的参数，然后再调用HAL_UART_Init函数进行寄存器配置即可。下面是一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">huart1.Instance = USART3;</span><br><span class="line">huart1.Init.BaudRate = <span class="number">115200</span>;</span><br><span class="line">huart1.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">huart1.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">huart1.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">huart1.Init.Mode = UART_MODE_TX_RX;</span><br><span class="line">huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;</span><br><span class="line">huart1.Init.OverSampling = UART_OVERSAMPLING_16;</span><br><span class="line"><span class="keyword">if</span> (HAL_UART_Init(&amp;huart1) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">  Error_Handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HAL_UART_Init()函数中，会依次执行如下操作：</p><ul><li>若检测为轮询模式的初始化，则会调用HAL_UART_MspInit()函数对其所用的总线时钟、GPIO等关联设备进行初始化</li><li>UART_SetConfig() 函数来对控制寄存器写入</li><li>对句柄结构体中所有状态指示器写入OK的状态</li></ul><p>其中HAL_UART_MspInit()函数一个例子如下，它会对所有关联的设备进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_MspInit</span><span class="params">(UART_HandleTypeDef* uartHandle)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span>(uartHandle-&gt;Instance==USART1)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_RCC_USART1_CLK_ENABLE();</span><br><span class="line">    __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;</span><br><span class="line">    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;<span class="comment">//该GPIO复用设置为GPIO_AF7_USART1</span></span><br><span class="line">    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用CubeMX配置工程时，会生成usart.c文件来存放各项init函数，例如总初始化函数MX_USART1_UART_Init()、关联设备初始化函数HAL_UART_MspIni()，以备HAL库文件stm32fxxx_hal_uart.c调用</p><h2 id="轮询-阻塞-数据收发"><a href="#轮询-阻塞-数据收发" class="headerlink" title="轮询(阻塞)数据收发"></a>轮询(阻塞)数据收发</h2><p>在轮询数据模式下，MCU专注于发送数据或接受数据，在Timeout规定的时间内收发完成则return 成功，否则return超时。在这个期间，MCU一直除以等数据接受或者看着输出发送的状态，效率较低。</p><h3 id="轮询串口接收"><a href="#轮询串口接收" class="headerlink" title="轮询串口接收"></a>轮询串口接收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span></span><br></pre></td></tr></table></figure><p>huart句柄已在上方介绍，剩余输入参数分别是：</p><ul><li>pData：存放数据的buffer首地址</li><li>Size：接受数据的字符串长度</li><li>Timeout：轮询时长，超时则返回</li></ul><p>这个函数会返回的类型”HAL_StatusTypeDef”有如下状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  HAL_OK       = <span class="number">0x00</span>U, <span class="comment">//成功接收</span></span><br><span class="line">  HAL_ERROR    = <span class="number">0x01</span>U, <span class="comment">//出现错误</span></span><br><span class="line">  HAL_BUSY     = <span class="number">0x02</span>U, <span class="comment">//串口忙</span></span><br><span class="line">  HAL_TIMEOUT  = <span class="number">0x03</span>U  <span class="comment">//轮询超时</span></span><br><span class="line">&#125; HAL_StatusTypeDef;</span><br></pre></td></tr></table></figure><h3 id="轮询串口发送"><a href="#轮询串口发送" class="headerlink" title="轮询串口发送"></a>轮询串口发送</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">const</span> <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span></span><br></pre></td></tr></table></figure><p>其输入参数、返回参数定义均同轮询接收函数一样，这里不重复介绍。</p><h2 id="中断数据收发"><a href="#中断数据收发" class="headerlink" title="中断数据收发"></a>中断数据收发</h2><p>使用中断模式进行数据收发时，MCU进会在有数据进来的时候让CPU去处理数据。其余时候可以干其他事情。这样效率较高</p><h3 id="中断串口接收"><a href="#中断串口接收" class="headerlink" title="中断串口接收"></a>中断串口接收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span></span><br></pre></td></tr></table></figure><p>参数如下：</p><ul><li>huart：uart handle地址</li><li>pData：存放数据的buffer首地址</li><li>Size：接受数据的字符串长度</li></ul><p>这里面输入的Size参数会被赋值进handle内的RxXferSize成员内。pData会被赋值进handle内的pRxBuffPtr成员内。在USART中断函数</p><p>HAL_UART_IRQHandler()中，会首先判断有没有错误出现，如果没有错误，则调用UART_Receive_IT()函数进行接收。这两个函数都被定义在stm32xxx_hal_uart.c内。</p><p>UART_Receive_IT函数中，每接收一个数据，就会对pRxBuffPtr的指针地址进行位移，来指向下一个内存单元的地址。同时对RxXferCount自减。当RxXferCount自减至0时，会关闭USART接受相关的中断使能。这一段代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> HAL_StatusTypeDef <span class="title function_">UART_Receive_IT</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span>  *pdata8bits;</span><br><span class="line">  <span class="type">uint16_t</span> *pdata16bits;</span><br><span class="line">  <span class="keyword">if</span> (huart-&gt;RxState == HAL_UART_STATE_BUSY_RX)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((huart-&gt;Init.WordLength == UART_WORDLENGTH_9B) &amp;&amp; (huart-&gt;Init.Parity == UART_PARITY_NONE))</span><br><span class="line">    &#123;</span><br><span class="line">      pdata8bits  = <span class="literal">NULL</span>;</span><br><span class="line">      pdata16bits = (<span class="type">uint16_t</span> *) huart-&gt;pRxBuffPtr;</span><br><span class="line">      *pdata16bits = (<span class="type">uint16_t</span>)(huart-&gt;Instance-&gt;DR &amp; (<span class="type">uint16_t</span>)<span class="number">0x01FF</span>);</span><br><span class="line">      huart-&gt;pRxBuffPtr += <span class="number">2U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      pdata8bits = (<span class="type">uint8_t</span> *) huart-&gt;pRxBuffPtr;</span><br><span class="line">      pdata16bits  = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((huart-&gt;Init.WordLength == UART_WORDLENGTH_9B) || ((huart-&gt;Init.WordLength == UART_WORDLENGTH_8B) &amp;&amp; (huart-&gt;Init.Parity == UART_PARITY_NONE)))</span><br><span class="line">      &#123;</span><br><span class="line">        *pdata8bits = (<span class="type">uint8_t</span>)(huart-&gt;Instance-&gt;DR &amp; (<span class="type">uint8_t</span>)<span class="number">0x00FF</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        *pdata8bits = (<span class="type">uint8_t</span>)(huart-&gt;Instance-&gt;DR &amp; (<span class="type">uint8_t</span>)<span class="number">0x007F</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      huart-&gt;pRxBuffPtr += <span class="number">1U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (--huart-&gt;RxXferCount == <span class="number">0U</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);</span><br><span class="line">      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);</span><br><span class="line">      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);</span><br><span class="line">      huart-&gt;RxState = HAL_UART_STATE_READY;</span><br><span class="line">      huart-&gt;RxEventType = HAL_UART_RXEVENT_TC;</span><br><span class="line">      <span class="keyword">if</span> (huart-&gt;ReceptionType == HAL_UART_RECEPTION_TOIDLE)</span><br><span class="line">      &#123;</span><br><span class="line">        huart-&gt;ReceptionType = HAL_UART_RECEPTION_STANDARD;</span><br><span class="line">        ATOMIC_CLEAR_BIT(huart-&gt;Instance-&gt;CR1, USART_CR1_IDLEIE);</span><br><span class="line">        <span class="keyword">if</span> (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))</span><br><span class="line">          __HAL_UART_CLEAR_IDLEFLAG(huart);</span><br><span class="line">          <span class="comment">//...未完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因此，调用HAL_UART_Receive_IT()后便会自动使能UART接收相关串口中断，同时准备好接受。在当接受的字符&gt;=Size所指定的字符数之后，便会自动失能相关中断</strong></p><p>在UART_Receive_IT()中，如果指定的字符数已经接收完成（RxXferCount == 0），则会调用HAL_UART_RxCpltCallback()这一公共回调函数。因为HAL库的库文件需要把硬件抽象成接口，因此直接改库文件内的代码不利于移植，用户的自定义中断回到函数写在HAL_UART_RxCpltCallback()内即可。此时UART已经将接收到的字符存在了pData指定的地址内，在HAL_UART_RxCpltCallback()内对pData内的数据进行处理即可。如果处理完成还需继续接收下一个数据，则再次调用HAL_UART_Receive_IT()来启用中断准备接收。</p><p>举个例子，假设我使用的通信协议规定每8byte数据为以通信帧，一数据帧传送数据位1byte，那么就可以把Size设置为8，然后每8byte数据接收完成之后就会调用用户自定义的回调函数HAL_UART_RxCpltCallback()函数来让用户处理数据。</p><p>下面是一个例程，实现使用中断接受UART数据，然后在收到换行符时把接收的数据发回去（省去了系统初始化部分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> ch;</span><br><span class="line"><span class="type">uint8_t</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">13</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    HAL_UART_Receive_IT(&amp;huart1,&amp;ch,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>&#123;</span><br><span class="line"><span class="comment">//user code here</span></span><br><span class="line">  buffer[count] = ch; <span class="comment">//ch就是pData指向的变量地址</span></span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">if</span>(buffer[count<span class="number">-1</span>] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">    HAL_UART_Transmit(huart, buffer, count , <span class="number">100</span>);<span class="comment">//把收到的字符发回串口</span></span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  HAL_UART_Receive_IT(&amp;huart1,&amp;ch,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1-CH2-电路实现技术</title>
      <link href="/posts/2f4a86be.html"/>
      <url>/posts/2f4a86be.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用-AND-OR-NOT门综合设计（Synthesis-Using-AND-OR-and-NOT-Gates）"><a href="#使用-AND-OR-NOT门综合设计（Synthesis-Using-AND-OR-and-NOT-Gates）" class="headerlink" title="使用 AND OR NOT门综合设计（Synthesis Using AND, OR, and NOT Gates）"></a>使用 AND OR NOT门综合设计（Synthesis Using AND, OR, and NOT Gates）</h1><ul><li><p><strong>Minterm:</strong> 选取为1的项目。 <strong>选择输入逻辑满足F=1的输入组合</strong>，通过以下步骤设计Boolean function:</p><ol><li><p>使得某一个输入满足组合时输出为1（输入进行AND运算）</p></li><li><p>当 1 中任意一个满足时（步骤1的结果们进行OR运算），输出为1</p><p>例如，对$x_1,x_2,x_3$三个输入，想要满足$x_1=1 x_2=1 x_3=1$ 和$x_1=0 x_2=1 x_3=1$ 时输出为1，首先选取使得f输出为1的组合，也就是前面提到的两个，然后进行and运算:$x_1x_2x_3$和$\overline x_1 x_2x_3$，再对and运算的结果进行OR运算$F=x_1x_2x_3+\overline x_1 x_2x_3$(<strong>对应 Sum of Product SOP</strong>)</p></li></ol></li><li><p><strong>Maxterm:</strong> 排除为0的项目。<strong>选择输入逻辑满足F=0的输入组合</strong>，通过以下步骤设计Boolean function:</p><ol><li><p>使得输入满足这个组合时输出为0（输入AND运算的结果取反，然后德摩根化开，此时$\overline {A.B}$ 就会变成$\overline A+\overline B$ ）</p></li><li><p>当所有输入情况任意一个满足为0时为0，否则为1（步骤1的结果AND运算）。</p><p>例如： $F=(A+B).(  \overline {A}  +B).(A+  \overline {B}  )$ <strong>(对应 Product of Sum POS)</strong></p></li></ol></li><li><p><strong>Cost：</strong>电路中  <strong>门的总数</strong>  加 <strong>门的输入信号的总数</strong>, 如果题目说需要同时给了未取反和取反(complement)的形式，则可以忽略not门造成的cost，否则需要计算not门的cost</p></li></ul><p><em>例: Maxterm的化简</em></p><script type="math/tex; mode=display">f=(  x_ {1}  +  x_ {2}  +  x_ {3}  )(  x_ {1}  +  \overline {x}_ {2}  +  x_ {3}  )(  x_ {1}  +  \overline {x}_ {2}  +  \overline {x}_ {3}  )  (\overline {x}_ {1}+\overline {x}_ {2}+\overline {x}_ {3})_ {(}</script><script type="math/tex; mode=display">f=((  x_ {1}  +  x_ {3}  )+  x_ {2}  )((  x_ {1}  +  x_ {3}  )+  \overline {x}_ {2}  )(  x_ {1}  +(\overline  x_ {2}  +  \overline {x}_ {3}  ))(  \overline {x}_ {1}  +(  \overline {x}_ {2}  +  \overline {x}_ {3}  ))\\</script><script type="math/tex; mode=display">f=(  x_ {1}  +  x_ {3}  )(  \overline {x}_ {2}  +  \overline {x}_ {3}  )\\</script><div class="note info simple"><p><em>把AND OR NOT门电路转化成NAND和NOR只需要用DeMorgan’s theorem 整体取反后化开即可。Multiplexer后面有更详细的涉及，此处省去。</em></p></div><hr><h1 id="晶体管开关-Transistor-Switches"><a href="#晶体管开关-Transistor-Switches" class="headerlink" title="晶体管开关 (Transistor Switches)"></a>晶体管开关 (Transistor Switches)</h1><p>晶体管有三个级：  源极(Source)  漏极(Drain)  栅极(Gate)  </p><ul><li><p><strong>NMOS:</strong>   当$V_G$是低电平的时候关断，高电平的时候导通。 </p></li><li><p><strong>PMOS:</strong>    当$V_G$是低电平的时候导通，高电平的时候截止。</p><table>   <tr>       <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240113231550895.png"/></center></td>       <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240113232443627.png"/></center></td>   </tr></table></li></ul><h2 id="NMOS-逻辑门"><a href="#NMOS-逻辑门" class="headerlink" title="NMOS 逻辑门"></a><strong>NMOS</strong> <strong>逻辑门</strong></h2><ul><li><p>利用开关的特性，通过上拉或下拉工作模式即可实现一个基于NMOS的逻辑门。此时需要一个限流电阻。因此该种方式功耗较大 </p></li><li><p>从MOS管的构成视角来看，AND和OR门其实是NAND和NOR门取反(如下图所示)，成本更高</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240113232959053.png" alt="image-20240113232959053.png (748×237) (kaysonz.top)"></p><h2 id="CMOS逻辑门-五星级的"><a href="#CMOS逻辑门-五星级的" class="headerlink" title="CMOS逻辑门 (五星级的)"></a>CMOS逻辑门 (五星级的)</h2><h3 id="CMOS逻辑门的介绍"><a href="#CMOS逻辑门的介绍" class="headerlink" title="CMOS逻辑门的介绍"></a>CMOS逻辑门的介绍</h3><p>NMOS逻辑门中通过上拉电阻实现上拉电路，这导致了功耗增加。CMOS逻辑门则优化了这个问题。</p><p>CMOS使用上拉电路和下拉电路，构成逻辑门。以NOT门为例，无论输入是低或高时，CMOS NOT门都直接被连到VCC或者GND，内部没有电流流动，理想状态下没有功率。这是CMOS是当今最流行的逻辑电路技术的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114004622139.png" alt="image-20240114004622139"></p><h3 id="使用CMOS逻辑门构建逻辑电路"><a href="#使用CMOS逻辑门构建逻辑电路" class="headerlink" title="使用CMOS逻辑门构建逻辑电路"></a>使用CMOS逻辑门构建逻辑电路</h3><p>在MOS层面，<strong>AND逻辑需要两个MOS都导通才导通，因此可以用两个MOS管串联来实现；OR逻辑只需要任意任意一个MOS导通它就导通，因此可以用两个MOS管并联来实现</strong></p><p>下图就时一个使用MOS管实现NOR逻辑的例子：</p><ul><li><p>上拉电路是电路取1的表达状态：根据真值表，只有当$x_1,x_2$都是0的时候，电路输出才是1。也就是$x_1x_2$</p></li><li><p>下拉电路是电路取0的表达状态，根据真值表，只要任意输入不为0，电路输出0。也就是$x_1+x_2$</p></li><li>根据上面的分析，AND逻辑使用串联，OR逻辑使用并联，即可得到下面这个NOR gate</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114004807165.png" alt="image-20240114004807165"></p><p><em>Example：Realise the following function using PMOS and NMOS$f=  \overline {x_ {1}}  +  \overline {x_ {2}}   \cdot   \overline {x_ {3}}  $</em> </p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114005501784.png" alt="img" style="zoom:150%;" /></p><p>如上图所示，上拉电路为$f=1$的时候，也就是$f=  \overline {x_ {1}}  +  \overline {x_ {2}}   \cdot   \overline {x_ {3}}  $</p><p>下拉电路为$f=0$的时候，也就是$  \overline f=\overline { \overline {x_ {1}}  +  \overline {x_ {2}}   \cdot   \overline {x_ {3}}  }=<br>(  x_ {1}  )  (x_ {2}+x_ {3}) $，逻辑是($x_1$) 与 ($x_2,x_3$并联的结果) 串联</p><hr><h1 id="可编程逻辑器件-Programmable-Logic-Devices-PLDs"><a href="#可编程逻辑器件-Programmable-Logic-Devices-PLDs" class="headerlink" title="可编程逻辑器件 (Programmable Logic Devices PLDs)"></a>可编程逻辑器件 (Programmable Logic Devices PLDs)</h1><h2 id="Programmable-Logic-Array-PLA"><a href="#Programmable-Logic-Array-PLA" class="headerlink" title="Programmable Logic Array (PLA)"></a><strong>Programmable Logic Array (PLA)</strong></h2><p>PLA 由AND运算后输入给OR运算，整体构成了一个SOP的形式，下图中曲线的位置代表它可编程。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011303571.png" alt="image-20240114011303571"></p><p>下图逻辑表达式如下 </p><p>$ P_ {1} $ = $ x_ {1} $ $ x_ {2} $  $ P_ {2} $ = $ x_ {1} $ $ \overline {x}_ {3} $ , $ P_ {3} $ = $ \overline {x}_ {1} $ $ \overline {x}_ {2} $ $ x_ {3} $ , $ andP_ {4} $ = $ x_ {1} $ $ x_ {3} $<br> $ f_ {1} $ = $ x_ {1} $ $ x_ {2} $ + $ x_ {1} $ $ \overline {x}_ {3} $ + $ \overline {x}_ {1} $ $ \overline {x}_ {2} $ $ x_ {3} $<br> $ f_ {2} $ = $ x_ {1} $ $ x_ {2} $ + $ \overline {x}_ {1} $ $ \overline {x_ {2}} $ $ x_ {3} $ + $ x_ {1} $ $ x_ {3} $ </p><p><strong>PLA 所需的可编程开关具有难以制造，速度慢的问题。</strong></p><h2 id="Programmable-Array-Logic-PAL"><a href="#Programmable-Array-Logic-PAL" class="headerlink" title="Programmable Array Logic (PAL)"></a><strong>Programmable Array Logic (PAL)</strong></h2><p>PAL的AND plane是可编程的，OR plane是固定的。与PLA相比，PAL提供的灵活性较小；PLA允许每个或门最多有四个乘积项，而PAL中的或门只有两个输入。但它减少了可编程开关的数量。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114010919955.png" alt="image-20240114010919955"></p><p>上图的输出为： $ f_ {1} $ = $ x_ {1} $ $ x_ {2} $ $ \overline {x}_ {3} $ + $ \overline {x}_ {1} $ $ x_ {2} $ $ x_ {3} $ ；   $ f_ {2} $ = $ \overline {x}_ {1} $ $ \overline {x}_ {2} $ + $ x_ {1} $ $ x_ {2} $ $ x_ {3} $ </p><p>因为PAL的OR的输出是不可编程的，因此flexibility较差。利用额外的宏单元来提升flexibility。宏(Macrocell) :将OR Gate的输出连接至额外的电路，如下图例子所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011123843.png" alt="image-20240114011123843"></p><h2 id="Complex-Programmable-Logic-Device-CPLD"><a href="#Complex-Programmable-Logic-Device-CPLD" class="headerlink" title="Complex Programmable Logic Device (CPLD)"></a><strong>Complex Programmable Logic Device (CPLD)</strong></h2><p>为了实现需要更多输入和输出的电路，可以使用多个PLA或PAL，或者可以使用更复杂类型的芯片，称为复杂可编程逻辑器件（CPLD）。CPLD的基本结构可看成由可编程逻辑阵列（LAB），可编程I/O控制模块和可编程内部连线（PIA）等三部分组成。</p><p>Example：下图是四个类似PAL的块，连接到一组互连线。每个类似PAL的块也连接到标记为I/O块。note: 一旦CPLD被编程了，那它的程序是可以断电保存的。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011242968.png" alt="image-20240114011242968"></p><h2 id="Field-programmable-gate-array-FPGA"><a href="#Field-programmable-gate-array-FPGA" class="headerlink" title="Field-programmable gate array (FPGA)"></a><strong>Field-programmable gate array (FPGA)</strong></h2><p>FPGA由可编程逻辑块（CLB/Logic Block），输入/输出模块（IOB）及可编程互连资源（PIR）等三种可编程电路和一个SRAM结构的配置存储单元组成。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011406647.png" alt="image-20240114011406647"></p><p>最常用的可编程逻辑块（Logic Block），是查表(Look Up Table LUT)</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011456609.png" alt="image-20240114011456609"></p><hr><h1 id="Custom-Chips-Standard-Cells-and-Gate-Arrays"><a href="#Custom-Chips-Standard-Cells-and-Gate-Arrays" class="headerlink" title="Custom Chips, Standard Cells, and Gate Arrays"></a><strong>Custom Chips, Standard Cells, and Gate Arrays</strong></h1><p>限制PLD中可以容纳的电路大小的关键因素是可编程开关的存在。尽管这些开关提供了用户可编程性的重要优势</p><ul><li><p><strong>它们在芯片上消耗了大量空间，从而导致成本增加。</strong></p></li><li><p><strong>它们还导致电路运行速度的降低</strong></p></li><li><p><strong>以及功耗的增加。</strong></p><p>AISC可以解决如上问题</p></li></ul><h2 id="Application-specific-integrated-circuits-AISCs"><a href="#Application-specific-integrated-circuits-AISCs" class="headerlink" title="Application-specific integrated circuits (AISCs)"></a><strong>Application-specific integrated circuits (AISCs)</strong></h2><p>专用集成电路，是指应特定用户要求和特定电子系统的需要而设计、制造的集成电路。制造商首先制造出逻辑操作的模板，后根据用户需求将模板用不同方式组合在一起。</p><p><strong>ASIC在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低等优点。</strong></p><p><strong>ASIC和FPGA相比，ASIC是专用集成电路，一旦设计完成后集成电路即固定。而FPGA是在阵列内集成大量数字电路基本门电路和存储器，开发人员可以通过烧写FPGA配置来定义电路。</strong></p><p>一个AISC的例子：这个电路中，制造商制造框起来的标准逻辑块，用户自定义连接(红线)，来实现不同输出，下图电路实现的输出就是：$f_1=  x_ {1}   x_ {2}  +  \overline {x_ {1}}  \overline {x_ {2}}   x_ {3}  +  x_ {1}   x_ {3}  $;    $ f_2=  \overline {x_ {1}}    \overline {x_ {3}}  +  \overline {x_ {1}}   \overline {x_ {2}}   x_ {3}  +  x_ {1}   x_ {3}  $</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011657224.png" alt="image-20240114011657224"></p><hr><h1 id="传输门（Transmission-Gates）五星级"><a href="#传输门（Transmission-Gates）五星级" class="headerlink" title="传输门（Transmission Gates）五星级"></a><strong>传输门（Transmission Gates）五星级</strong></h1><p>NMOS(高开低关)传输0较好，而传输1较差。PMOS（低开高关）传输1较好而传输0较差。传输门把一个NMOS和一个PMOS组合在一起，从而实现很低的导通电阻和很高的截止电阻。因此，传输门可以直接使得原始信号x通过逻辑门，此时逻辑门输出$f=x$。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114012221074.png" alt="image-20240114012221074"></p><div class="note warning simple"><p>五星级问题：一个传输门有几个 Transistor？ ——2个; 因为是把PMOS和NMOS组合在一起</p></div><p><strong>五星级例题：使用传输门构建XOR</strong></p><p>XOR表达式：$f=\overline x_1x_2+x_1 \overline x_2$</p><p>根据真值表，当$x_1=0$时，输出$f=x_2$。当$x_1=1$时，输出$f=\overline x_2 $。根据传输门良好导通的特性，下图电路可被设计。</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114012807046.png"/></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114012819416.png"/></center></td>    </tr></table><hr><h1 id="SPLD、CPLD和FPGA的实现细节"><a href="#SPLD、CPLD和FPGA的实现细节" class="headerlink" title="SPLD、CPLD和FPGA的实现细节"></a><strong>SPLD、CPLD和FPGA的实现细节</strong></h1><h2 id="PLD"><a href="#PLD" class="headerlink" title="PLD"></a>PLD</h2><p>这是一个普通的XOR Gate，使用NMOS实现的电路</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114012954804.png" alt="image-20240114012954804"></p><p>这是可编程版本</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114013017068.png" alt="image-20240114013017068"></p><p>白色框框内部结构是EEPROM编程开关，$Ve$连接的就是EEPROM</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114013141719.png" alt="image-20240114013141719"></p><h2 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h2><p>与白色框框不同，FPGA采用SRAM编程，结构如下图所示.  <strong>SRAM 单元中的数据掉电就会丢失</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114014257973.png" alt="image-20240114014257973"></p><hr><h1 id="典型逻辑电路和它们的VHDL代码"><a href="#典型逻辑电路和它们的VHDL代码" class="headerlink" title="典型逻辑电路和它们的VHDL代码"></a>典型逻辑电路和它们的VHDL代码</h1><h2 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114013350317.png" alt="image-20240114013350317"></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--定义实体，主要定义输入输出的端口--</span></span><br><span class="line"><span class="keyword">ENTITY</span> examplel <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span> (x1,x2,x3 :<span class="keyword">IN</span> <span class="built_in">BIT</span> ; <span class="comment">--PORT后定义输入的端口和输出的端口</span></span><br><span class="line">f  : <span class="keyword">OUT</span> <span class="built_in">BIT</span> );<span class="comment">--这里定义类型为BIT，只有0和1两种状态；这里也可以定义为STD_LOGIC,会多出高阻等等状态，Dr.Wu一般只会考0和1的</span></span><br><span class="line"><span class="keyword">END</span> example1 ;</span><br><span class="line"><span class="comment">--定义某个实体对应的逻辑结构--</span></span><br><span class="line"><span class="keyword">ARCHITECTURE</span> LogicFunc <span class="keyword">OF</span> examplel <span class="keyword">IS</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">f &lt;= (x1 <span class="keyword">AND</span> x2) <span class="keyword">OR</span> (<span class="keyword">NOT</span> X2 <span class="keyword">AND</span> x3) <span class="comment">--写输入，输出端口对应的逻辑表达式</span></span><br><span class="line"><span class="keyword">END</span> LogicFunc;</span><br></pre></td></tr></table></figure><h2 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114013524391.png" alt="image-20240114013524391"></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTITY</span> example2 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span> (xl,x2,x3,x4 :<span class="keyword">IN</span> <span class="built_in">BIT</span> ; <span class="comment">--PORT后定义输入的端口和输出的端口，这里是多路输出，有f和g两个OUT</span></span><br><span class="line">f,g : <span class="keyword">OUT</span> <span class="built_in">BIT</span>);</span><br><span class="line"><span class="keyword">END</span> example2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARCHITECTURE</span> LogicFunc <span class="keyword">OF</span> example2 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">f &lt;=(x1 <span class="keyword">AND</span> x3) <span class="keyword">OR</span> (x2 <span class="keyword">AND</span> x4) ;<span class="comment">--分别写出输出的逻辑表达式</span></span><br><span class="line">g &lt;= (x1 <span class="keyword">OR</span> <span class="keyword">NOT</span> x3) <span class="keyword">AND</span> (<span class="keyword">NOT</span> X2 <span class="keyword">OR</span> X4)</span><br><span class="line"><span class="keyword">END</span> LogicFunc ;</span><br></pre></td></tr></table></figure><hr><center>---CHAPTER END---</center>]]></content>
      
      
      <categories>
          
          <category> 大三上 </category>
          
          <category> 数字电路设计与可靠性工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/posts/423abe9e.html"/>
      <url>/posts/423abe9e.html</url>
      
        <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><p>以下内容中&lt;参数&gt;都表示输入参数，输入时不需要加&lt;&gt;</p><h2 id="本地仓库相关"><a href="#本地仓库相关" class="headerlink" title="本地仓库相关"></a>本地仓库相关</h2><h3 id="在某一文件夹内初始化git"><a href="#在某一文件夹内初始化git" class="headerlink" title="在某一文件夹内初始化git"></a><strong>在某一文件夹内初始化git</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="把工作区文件添加至暂存区"><a href="#把工作区文件添加至暂存区" class="headerlink" title="把工作区文件添加至暂存区"></a><strong>把工作区文件添加至暂存区</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;文件名 或 通配符&gt;</span><br><span class="line">git add -u <span class="comment">#将已跟踪的文件提交至暂存区</span></span><br></pre></td></tr></table></figure><h3 id="把暂存区文件提交至本地仓库"><a href="#把暂存区文件提交至本地仓库" class="headerlink" title="把暂存区文件提交至本地仓库"></a><strong>把暂存区文件提交至本地仓库</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;&lt;对本次提交的描述&gt;&quot;</span> <span class="comment">#从暂存区提交</span></span><br><span class="line">git commit -am <span class="string">&quot;&lt;对本次提交的描述&gt;&quot;</span> <span class="comment">#将已跟踪的文件提交至暂存区和仓库</span></span><br><span class="line">git commit --amend -m <span class="string">&quot;&lt;对上次提交的描述修改&gt;&quot;</span> <span class="comment">#修改上次提交的描述，不加-m可进入vim编辑</span></span><br></pre></td></tr></table></figure><h3 id="查看当前仓库的状态（分支、文件、文件状态）"><a href="#查看当前仓库的状态（分支、文件、文件状态）" class="headerlink" title="查看当前仓库的状态（分支、文件、文件状态）"></a><strong>查看当前仓库的状态（分支、文件、文件状态）</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a><strong>回退版本</strong></h3><p>  &lt;输入参数&gt;有：</p><ul><li>—soft  (保留工作区和暂存区仅回退版本)</li><li>—hard  （回退版本、工作区、暂存区）</li><li>—mixed   (回退功版本和暂存区，保留工作区)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;输入参数&gt;</span><br></pre></td></tr></table></figure><h3 id="查看差异"><a href="#查看差异" class="headerlink" title="查看差异"></a><strong>查看差异</strong></h3><p>  &lt;输入参数&gt;有：</p><ul><li>无： 工作区和暂存区的差异； 如果存在merge冲突，将在下面显示</li><li>HEAD：工作区和版本库的差异</li><li>— cache或—staged：暂存区和版本库的差异</li><li>&lt;版本1 id&gt; &lt;版本2 id&gt;：版本1和版本2之间的差异，这里可以用HEAD指代当前版本的id；HEAD~ 来指代上一个版本的id; HEAD~n 表示前n个版本的id；</li><li>&lt;分支名1&gt; &lt;分支名2&gt;：分支1和分支2间的差异</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;输入参数&gt;</span><br></pre></td></tr></table></figure><h3 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a><strong>查看提交记录</strong></h3><p>  &lt;参数&gt;：</p><ul><li>—oneline， 这样只会显示哈希值的前几位。</li><li>—graph —oneline —decorate -all 查看分支图形式的提交记录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> &lt;参数&gt;</span><br></pre></td></tr></table></figure><h3 id="查看暂存区文件"><a href="#查看暂存区文件" class="headerlink" title="查看暂存区文件"></a><strong>查看暂存区文件</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a><strong>删除文件</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> &lt;文件名&gt; <span class="comment">#等效于删除某一文件后git add</span></span><br><span class="line">git <span class="built_in">rm</span> &lt;文件夹&gt; -r * <span class="comment">#递归删除某个文件夹以及内部所有文件和子文件夹</span></span><br><span class="line">git <span class="built_in">rm</span> --cached &lt;文件名&gt; <span class="comment"># 从暂存区删除，但保留在工作区</span></span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul><li><strong>branch 命令</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;分支名&gt; <span class="comment">#创建一个新的分支</span></span><br><span class="line">git branch <span class="comment">#查看当前的分支状态</span></span><br><span class="line">git branch -d &lt;分支名&gt; <span class="comment">#删除已经被合并的分支</span></span><br><span class="line">git branch -D &lt;分支名&gt; <span class="comment">#强制删除未被合并的分支</span></span><br><span class="line">git branch -vv <span class="comment">#查看本地分支时候和远程分支存在映射关系</span></span><br></pre></td></tr></table></figure><ul><li><strong>switch 命令（同checkout）</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;分支名&gt; <span class="comment">#切换到某分支</span></span><br><span class="line">git switch -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>merge命令</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;分支名&gt; <span class="comment">#把输入名字的分支合并到当前分支</span></span><br><span class="line">git merge --abort <span class="comment">#终止合并</span></span><br></pre></td></tr></table></figure><p>当合并冲突出现时，需要手动修改冲突内容，并使用git add + commit进行提交来合并分支</p><ul><li><strong>rebase命令</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;分支名&gt; <span class="comment">#将&lt;分支名&gt;上由共同祖先到当前HEAD的所有提交记录，移动到当前分支的分支树上（直接变基在当前分支HEAD的顶上）</span></span><br></pre></td></tr></table></figure><h2 id="远程仓库相关"><a href="#远程仓库相关" class="headerlink" title="远程仓库相关"></a>远程仓库相关</h2><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a><strong>克隆仓库</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;仓库地址&gt;</span><br></pre></td></tr></table></figure><h3 id="设置远程仓库"><a href="#设置远程仓库" class="headerlink" title="设置远程仓库"></a>设置远程仓库</h3><p>  &lt;输入参数&gt;：</p><ul><li>add &lt;仓库别名,通常origin&gt; &lt;仓库地址&gt;: 添加远程仓库</li><li>-v :查看本地仓库对应的远程仓库的别名和地址</li><li>rm &lt;仓库别名&gt;：删除远程仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote &lt;输入参数&gt;</span><br></pre></td></tr></table></figure><p>设置远程仓库和本地仓库的分支映射关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream &lt;本地分支&gt; &lt;远程仓库名&gt;/&lt;远程分支&gt; <span class="comment">#将本地分支映射到远程主机的远程分支</span></span><br><span class="line">git branch --set-upstream &lt;本地分支&gt; &lt;远程仓库名&gt; <span class="comment">#将本地分支映射到远程主机的同名分支</span></span><br></pre></td></tr></table></figure><h3 id="拉取仓库"><a href="#拉取仓库" class="headerlink" title="拉取仓库"></a>拉取仓库</h3><p><strong>pull</strong>  </p><p>&lt;输入参数&gt;：</p><ul><li><p>&lt;远程主机名&gt; &lt;远程分支&gt;:&lt;本地分支&gt;: 将远程主机上的远程分支取回，并与本地分支合并</p></li><li><p>&lt;远程主机名&gt; &lt;远程分支&gt;: 将远程主机上的远程分支取回，并与当前的本地分支合并</p><p><strong>如果当前分支已经被设置了和远程分支的映射关系，则不需要输入参数</strong></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;输入参数&gt;</span><br></pre></td></tr></table></figure><p><strong>fetch</strong></p><p>所有使用pull命令拉取的分支都会自动和本地分支合并，fetch则是先存在本地，等待人工merge合并</p><p>&lt;输入参数&gt;：</p><ul><li>&lt;远程主机名&gt; &lt;远程分支&gt;:&lt;本地分支(一般新建tmp分支)&gt;: 将远程主机上的远程分支取回到本地工作区，不合并，需要主动$merge <tmp>$</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;输入参数&gt;</span><br></pre></td></tr></table></figure><h3 id="上传仓库"><a href="#上传仓库" class="headerlink" title="上传仓库"></a>上传仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; <span class="comment">#把本地分支推送至远程</span></span><br><span class="line"><span class="comment">#在本地分支和远程分支同名时或设置了映射关系时，可省略远程分支</span></span><br><span class="line">git push &lt;远程仓库名&gt; &lt;本地分支名&gt;</span><br><span class="line"><span class="comment">#推送当前分支时,可省略本地分支名</span></span><br><span class="line">git push &lt;远程仓库名&gt;</span><br><span class="line"><span class="comment">#在本地分支只和一个远程仓库有映射关系时，可省略远程仓库名</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">git push  &lt;远程仓库名&gt; --delete &lt;远程分支名&gt; <span class="comment">#删除远程仓库中的某一分支</span></span><br></pre></td></tr></table></figure><h1 id="git常用工作流"><a href="#git常用工作流" class="headerlink" title="git常用工作流"></a>git常用工作流</h1><h3 id="gitflow工作流模型"><a href="#gitflow工作流模型" class="headerlink" title="gitflow工作流模型"></a><strong>gitflow工作流模型</strong></h3><ul><li><p><strong>mian分支</strong>（核心分支）：项目的可靠分支，可直接部署进生产环境，不允许直接修改，只能通过merge合并</p><p>主分支的版本号命名规则：Major Version（主要功能或者重大版本更新）；Minor Version（新功能改进和更新，不会影响现有功能）；Patch Version（一些bug修复）</p></li><li><p>hotfix分支：bug的热修复分支，一般从主分支中分离出来，修复完成后合并至mian分支和各个开发分支</p></li><li><p><strong>develop分支</strong>(核心分支)：开发分支，</p></li><li><p>feature分支：功能分支，用于开发新的功能的分支，新功能在稳定后会合并进开发分支。</p></li><li><p>release分支：发布前测试和验证的分支，由开发分支分离，当预发布分支稳定后，merge到主分支和开发分支并删除release分支。当预发布分支发现问题时，直接在预发布分支内进行修改。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 各种折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sx1280芯片手册</title>
      <link href="/posts/dead6220.html"/>
      <url>/posts/dead6220.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h2><p>SX1280是一个工作在2.4GHz(ISM频段)的半双工收发器。芯片引脚定义如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Pin Number</th><th style="text-align:center">引脚名称</th><th style="text-align:center">I/O类型</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">VR_PA</td><td style="text-align:center">-</td><td style="text-align:center">功放的稳压供电</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">VDD_IN</td><td style="text-align:center">I</td><td style="text-align:center">设备稳压供电，连接到Pin12</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">NRESET</td><td style="text-align:center">I</td><td style="text-align:center">复位信号，低电平有效，内部上拉为50kΩ</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">XTA</td><td style="text-align:center">-</td><td style="text-align:center">参考振荡器或温补晶振输入</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">XTB</td><td style="text-align:center">-</td><td style="text-align:center">参考振荡器</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">BUSY</td><td style="text-align:center">O</td><td style="text-align:center">忙信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">DIO1</td><td style="text-align:center">I/O</td><td style="text-align:center">数字IO</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">DIO2</td><td style="text-align:center">I/O</td><td style="text-align:center">数字IO</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">DIO3</td><td style="text-align:center">I/O</td><td style="text-align:center">数字IO</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">VBAT_IO</td><td style="text-align:center">I</td><td style="text-align:center">数字IO供电（1.8V至3.7V）</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">DCC_FB</td><td style="text-align:center">O</td><td style="text-align:center">片内稳压输出</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">DCC_SW</td><td style="text-align:center">O</td><td style="text-align:center">DCDC开关电源输出</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">VBAT</td><td style="text-align:center">I</td><td style="text-align:center">RFIC的供电（1.8V至3.7V）</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">MISO_TX</td><td style="text-align:center">O</td><td style="text-align:center">SPI slave output_UART TX</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">MOSI_RX</td><td style="text-align:center">I</td><td style="text-align:center">SPI slave input_UART RX</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">SCK_RTSN</td><td style="text-align:center">I</td><td style="text-align:center">SPI 时钟_ UART请求发送（Request to Send）</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">NSS_CTSN</td><td style="text-align:center">I</td><td style="text-align:center">SPI 从机选择_UART 允许发发送（Clear to Send）</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">RFIO</td><td style="text-align:center">I/O</td><td style="text-align:center">射频发射/接收 IO</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120041210550.png" alt="image-20240120041210550"></p><h2 id="SX1280的一些关键的参数"><a href="#SX1280的一些关键的参数" class="headerlink" title="SX1280的一些关键的参数"></a>SX1280的一些关键的参数</h2><ul><li>供电：1.8~3.7V</li><li>工作温度：-40~85 摄氏度</li><li>RF天线功率 ：最小输出-18dBm 最大输入12.5dBm</li><li>数字IO： 最大输入/输出电流 2.5mA</li></ul><h2 id="硬件模块结构"><a href="#硬件模块结构" class="headerlink" title="硬件模块结构"></a>硬件模块结构</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124162852697.png" alt="image-20240124162852697"></p><p>通过SPI或UART，发送对应的opcode+data的形式来控制这个模块。模块大致分为5个部分，模拟前端用于调制和发射频带信号，绿色的是数字调制部分，可产生不同调制的信号。Data Buffer用于存放接收的和待发送的数据。和 Protocol Engine用于硬件实现一些通信协议。</p><p>在供电方面，SX1280有两个独立的供电模组：DC-DC和LDO，默认情况下，仅开启LDO做为供电，但DCDC电源可在FS，RX，TX模式下启用，来承载更高的功耗。<strong>如果要想启用DCDC电源，则需要在12和14引脚之间接一个15uH的电感并将DCDC和LDO并联做为VDD。</strong>在DCDC被并入供电时，可在待机模式时切换启用和关闭DCDC供电，下方工作模式将会详细介绍。</p><h2 id="SX1280的几种工作模式"><a href="#SX1280的几种工作模式" class="headerlink" title="SX1280的几种工作模式"></a>SX1280的几种工作模式</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120013631945.png" alt="image-20240120013631945"></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240208021648925.png" alt="image-20240208021648925"></p><h3 id="STDBY（待机）模式"><a href="#STDBY（待机）模式" class="headerlink" title="STDBY（待机）模式"></a>STDBY（待机）模式</h3><p>该模式有两种时钟源，分别是13M的RC振荡器和外部晶振XOSC，可以用命令 $SetStandby(oscillatorMode)$ 来进行切换。当选用XOSC作为时钟源时，自动切换为DCDC模块供电。也可使用如下命令手动设置供电：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetRegulatorType(regulatorType); <span class="comment">//该指令仅可在STDBY_RC模式使用</span></span><br></pre></td></tr></table></figure><h3 id="Frequency-Synthesis-FS-频率合成-模式"><a href="#Frequency-Synthesis-FS-频率合成-模式" class="headerlink" title="Frequency Synthesis (FS 频率合成)模式"></a>Frequency Synthesis (FS 频率合成)模式</h3><p>在FS模式下，模拟部分的PLL会按照设置的Tx开始震荡，当震荡稳定时，BUSY引脚就会变成低电平（标明设备已准备好接受指令）</p><p>在SX1280的设计中，RX和TX的频率是不同的，RX的频率等于Tx的频率（i.e., 锁相环产生的频率）减去中间频率(Intermediate Frequency IF)，IF默认是1.3MHz。</p><h3 id="Receice（接收）模式"><a href="#Receice（接收）模式" class="headerlink" title="Receice（接收）模式"></a>Receice（接收）模式</h3><p>在接收模式下除了FS模式启用的PLL外，片上LNA，相干器，和对应的解调器（LoRa/FSK/FLRC）都会开始工作。接受模式可设置为连续接收（continuous mode）和单次接收（single mode）。在连续接收模式下，模块会保持接收模式。在单次接收模式下，模块会在一次接收完成后返回STDBY模式。</p><p>接收模式通过官方驱动的SetRx函数来设置，其输入参数periodBase是指的时钟振荡周期，periodBaseCount是指的历经多少次时钟震荡算超时。当超时时，会从Receive mode 返回至 STDBY_RC mode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetRx(periodBase, periodBaseCount); <span class="comment">//Opcode 0x83</span></span><br></pre></td></tr></table></figure><h3 id="Transmit（发送）模式"><a href="#Transmit（发送）模式" class="headerlink" title="Transmit（发送）模式"></a>Transmit（发送）模式</h3><p>发送模式会在信号放大器（PA）启动完成后，发送待发送的数据包。在发送完成后自动返回STDBY_RC模式</p><h3 id="Sleep（睡眠）模式"><a href="#Sleep（睡眠）模式" class="headerlink" title="Sleep（睡眠）模式"></a>Sleep（睡眠）模式</h3><p>睡眠模式下，只有睡眠控制器模块和可选的64KHz RC时钟工作。睡眠模式仅能从STDBY_RC模式下进入。</p><p>唤醒的方式有：</p><ul><li>NSS（Pin 19）变成低电平</li><li>RTC定时器产生计时结束事件</li></ul><p>SX1280在上电时，会自动校准其RC时钟，PLL和ADC，在校准期间BUSY信号会保持高电平，在校准完成后会进入STDBY_RC模式，并使BUSY信号变为低电平以表示准备好接收指令。</p><p>上电校准的结果会有寄存器存储，因此在休眠模式被唤醒时无需再次校准。</p><h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><p>Sx1280使用串口发送opcode的形式来控制模块，串口可使用UART或SPI，二者发送命令和支持的功能（如校验、流控）有些许差异。详细介绍如下。</p><h2 id="使用UART和模块建立连接"><a href="#使用UART和模块建立连接" class="headerlink" title="使用UART和模块建立连接"></a>使用UART和模块建立连接</h2><ul><li>波特率：该模块支持的波特率有921.6K，460.6K，115.2K，57.6K，38.4K，19.2K，9.6K。 <strong>在上电时，默认以115200工作，通过配置寄存器更改其他波特率</strong></li><li>停止位：模块支持1或2个停止位，通过寄存器配置，<strong>上电默认一个停止位</strong></li><li>仅支持8byte数据</li><li>模块支持奇偶校验、无校验</li><li>模块支持在Rx满，Tx空，奇偶校验错误或无停止位时，产生中断</li></ul><p><strong>使用UART和模块通信时，主机必须提供长度信息，模块一旦接受到所需长度的信息，就会开始处理任务，命令格式通常为：opcode+后续长度+后续参数</strong></p><p>举个例子，在UART执行写寄存器的操作时，必须发送操作码+要写的首地址+数据的长度+数据+….+数据n。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209004243157.png" alt="image-20240209004243157"></p><p>在使用UART进行读寄存器时，发送完操作码+要读的首地址+数据的长度后，主机RX线便会收到从机的数据内容。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209004849480.png" alt="image-20240209004849480"></p><p>在使用UART指令时，模块一收到opcode就会将busy线拉高，然后在接收后续长度指定的命令个数后，将BUSY线重新拉低进行命令处理。</p><h2 id="使用SPI和模块建立连接"><a href="#使用SPI和模块建立连接" class="headerlink" title="使用SPI和模块建立连接"></a>使用SPI和模块建立连接</h2><ul><li>NSS引脚变成低电平使能，高电平失能</li><li>MOSI 由主机在 SCK 下降沿时产生，并由从机在 SCK 上升沿时采样。 MISO 由 SCK 下降沿的从机产生。</li><li>通信时钟SCK最高频率为18MHz</li></ul><p><strong>使用SPI和模块通信时，无需提供命令长度，以NSS信号线被拉高来结束一次通信即可，即，命令格式为：opcode+后续参数</strong></p><p>举个例子，在SPI执行写寄存器时，只需发送操作码+要写的首地址+数据+…+数据n，相较于UART无需发送数据长度。由NSS信号被拉高来标明当前写操作结束。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209004451160.png" alt="image-20240209004451160"></p><p>在使用SPI执行读寄存器时，要发送操作码+要读的首地址+NOP（0x00），MISO线才开始传输数据。也就是说，UART内数据长度的位置需要用一个NOP来顶替，以此达到一个延时等待响应的目的。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209004819079.png" alt="image-20240209004819079"></p><h1 id="指令操作码（OPcode）"><a href="#指令操作码（OPcode）" class="headerlink" title="指令操作码（OPcode）"></a>指令操作码（OPcode）</h1><p><em>在以下笔记中，所有NOP表示数据0x00，指令顺序中用+连接的是通过不同数据帧发送的不同byte，比如0x01+0x02是先发送0x01再发送0x02</em></p><h2 id="寄存器相关"><a href="#寄存器相关" class="headerlink" title="寄存器相关"></a>寄存器相关</h2><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">写寄存器数据</td><td style="text-align:center">0x18</td><td style="text-align:center">操作码+地址[15:8]+地址[7:0]+数据…+数据n</td><td style="text-align:center">操作码+地址[15:8]+地址[7:0]+长度+数据…+数据n</td></tr><tr><td style="text-align:center">读寄存器数据</td><td style="text-align:center">0x19</td><td style="text-align:center">操作码+地址[15:8]+地址[7:0]+NOP</td><td style="text-align:center">操作码+地址[15:8]+地址[7:0]+长度</td></tr></tbody></table></div><h2 id="数据缓冲区-Buffer-相关"><a href="#数据缓冲区-Buffer-相关" class="headerlink" title="数据缓冲区(Buffer)相关"></a>数据缓冲区(Buffer)相关</h2><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">写Buffer数据</td><td style="text-align:center">0x1A</td><td style="text-align:center">操作码+地址偏移+数据…+数据n</td><td style="text-align:center">操作码+地址偏移+长度+数据…+数据n</td></tr><tr><td style="text-align:center">读Buffer数据</td><td style="text-align:center">0x1B</td><td style="text-align:center">操作码+地址偏移+NOP</td><td style="text-align:center">操作码+地址偏移+长度</td></tr></tbody></table></div><h2 id="模式切换相关"><a href="#模式切换相关" class="headerlink" title="模式切换相关"></a>模式切换相关</h2><h3 id="睡眠模式"><a href="#睡眠模式" class="headerlink" title="睡眠模式"></a>睡眠模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetSleep</td><td style="text-align:center">0x84</td><td style="text-align:center">操作码+睡眠配置</td><td style="text-align:center">操作码+睡眠配置</td></tr></tbody></table></div><p>其中睡眠配置为1byte，但只有低二位有用，其余bit保持0。例如0x01,0x03等：</p><ul><li>第0位：如果该位被置1，那么在RAM中的部分数据会被存放进非易失存储器（称为 retention mode）。否则RAM数据被刷新。RAM主要用于存放模块初始化设置，被备份的数据如下：<ul><li>SetPacketType()</li><li>SetModulationParams()</li><li>SetRfFrequency()</li><li>SetDioIrqParams()</li><li>SetCadParams()</li></ul></li></ul><ul><li>第1位：如果该为被置1，那么Data buffer中的数据会被存放进非易失存储器。否则Data Buffer内数据被刷新。</li></ul><h3 id="待机模式"><a href="#待机模式" class="headerlink" title="待机模式"></a>待机模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetStandby</td><td style="text-align:center">0x80</td><td style="text-align:center">操作码+待机配置</td><td style="text-align:center">操作码+0x01+待机配置</td></tr></tbody></table></div><p>其中待机配置为1byte，但只有LSB有用，其余bit保持0，也就是只有0x00和0x01两种：</p><ul><li>0x00：STDBY_RC模式，使用13MHz RC振荡器做为时钟源</li><li>0x01：STDBY_XOSC模式，使用外部晶振做为时钟源</li></ul><h3 id="频率合成模式（FS-mode）"><a href="#频率合成模式（FS-mode）" class="headerlink" title="频率合成模式（FS mode）"></a>频率合成模式（FS mode）</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetFs</td><td style="text-align:center">0xC1</td><td style="text-align:center">操作码</td><td style="text-align:center">操作码</td></tr></tbody></table></div><h3 id="发送模式"><a href="#发送模式" class="headerlink" title="发送模式"></a>发送模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th></tr></thead><tbody><tr><td style="text-align:center">SetTx</td><td style="text-align:center">0x83</td></tr><tr><td style="text-align:center"><strong>SPI模式指令顺序</strong></td><td style="text-align:center"><strong>UART模式指令顺序</strong></td></tr><tr><td style="text-align:center">操作码+periodBase+periodBaseCount[15:8]+periodBaseCount[7:0]</td><td style="text-align:center">操作码+0x03(后续长度)+periodBase+periodBaseCount[15:8]+periodBaseCount[7:0]</td></tr></tbody></table></div><p><em>note：在设置为发送模式前，需要先清除IRQ status</em></p><p><strong>Single Mode Tx</strong>： 如果periodBase和PeriodBaseCount都设置为0x00，即，传输指令0x83+0x00+0x00（SPI模式下），那么模块将工作在单次发模式（Single Mode Tx）。在该模式下，不会有超时限制，会在发送一个包之后结束Tx模式。</p><p><strong>发送模式的流程</strong>： 1. 打开PLL     2. 打开PA（功率放大器）     3. PA根据SetTxParam函数设置的模式，进行上升     4. 待PA上升完成，数据开始分包传输 5.传输完成后，关闭PA，关闭PLL，收发器返回STDBY_RC模式，并产生中断“IRQ TxDone”     6.若传输超时，则中断传输，返回STDBY_RC模式，并产生中断“TIMEOUT IRQ”。</p><p><strong>periodBase参数：</strong> 这个参数影响RTC时钟一步的计时时长，表如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">periodBase</th><th style="text-align:center">Time-Out step</th></tr></thead><tbody><tr><td style="text-align:center">0x00</td><td style="text-align:center">15.625us</td></tr><tr><td style="text-align:center">0x01</td><td style="text-align:center">62.5us</td></tr><tr><td style="text-align:center">0x02</td><td style="text-align:center">1ms</td></tr><tr><td style="text-align:center">0x03</td><td style="text-align:center">4ms</td></tr></tbody></table></div><p><strong>PeriodBaseCount参数</strong>：该参数有16位，用于指明在计数多少个周期后超时。计算公式如下：</p><script type="math/tex; mode=display">Time-out\ duration = periodBase\times periodBaseCount</script><p>如果该为被设置为0x00，那么直到单个包发送完成之前，都不会退出Tx模式，无超时限制。当单个包发送完之后返回STDBY_RC模式。</p><h3 id="接收模式"><a href="#接收模式" class="headerlink" title="接收模式"></a>接收模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th></tr></thead><tbody><tr><td style="text-align:center">SetRx</td><td style="text-align:center">0x82</td></tr><tr><td style="text-align:center"><strong>SPI模式指令顺序</strong></td><td style="text-align:center"><strong>UART模式指令顺序</strong></td></tr><tr><td style="text-align:center">操作码+periodBase+periodBaseCount[15:8]+periodBaseCount[7:0]</td><td style="text-align:center">操作码+0x03(后续长度)+periodBase+PeriodBaseCount[15:8]+PeriodBaseCount[7:0]</td></tr></tbody></table></div><p><em>note：在设置为发送模式前，需要先清除IRQ status</em></p><p>接收模式的参数意义同发送模式，但它可以设置单次接收模式，连续接收模式，超时模式三种，表如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">periodBaseCount</th><th style="text-align:center">超时时间</th></tr></thead><tbody><tr><td style="text-align:center">0x0000</td><td style="text-align:center">单次接收模式，没有超时时间，但在完成一个包的接收之后返回STDBY_RC模式</td></tr><tr><td style="text-align:center">0xFFFF</td><td style="text-align:center">连续接收模式，设备一直保持接收模式，直到主机发送改变模式的命令。每次接收到数据包时，都会向主机发送已接收新的数据包的指示。</td></tr><tr><td style="text-align:center">其他</td><td style="text-align:center">超时时间=超时基周期*超时计数数量</td></tr></tbody></table></div><p><em>举个例子，保持一秒接收模式：0x82+0x03+0x00+0xFA</em></p><h2 id="特殊模式"><a href="#特殊模式" class="headerlink" title="特殊模式"></a>特殊模式</h2><h3 id="嗅探模式"><a href="#嗅探模式" class="headerlink" title="嗅探模式"></a>嗅探模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th></tr></thead><tbody><tr><td style="text-align:center">SetRxDutyCycle</td><td style="text-align:center">0x94</td></tr><tr><td style="text-align:center"><strong>SPI模式指令顺序</strong></td><td style="text-align:center"><strong>UART模式指令顺序</strong></td></tr><tr><td style="text-align:center">操作码+periodBase+periodBaseCount[15:8]+periodBaseCount[7:0]+<br>sleepPeriodBaseCount[15:8]+sleepPeriodBaseCount[7:0]</td><td style="text-align:center">操作码后面+0x05（后续长度）</td></tr></tbody></table></div><p>在嗅探模式（sniff mode）下，模块会周期性地寻找新的包。<strong>在此模式下，用于preamble必须被设置为long preamble mode。因此使用这个指令之前必须使用SetLongPreamble设置preamble模式。</strong></p><p>该模式下periodBase同Tx模式中的表。</p><p><strong>periodBaseCount</strong>：该位用于指明模块唤醒，查询新包的时间</p><p><strong>sleepPeriodBaseCount</strong>：用于指明模块休眠的时间</p><ol><li>模块会进入接收模式，寻找新的包，寻找的时间由periodBaseCount决定。</li><li>如果接收模式的窗口期内没有嗅探到preamble，模块会进入睡眠模式（设置会被保存）。睡眠时间由sleepPeriodBaseCount定义。</li><li>在睡眠时间结束后，模块会将设置重新存会RAM，并返回接收模式，重新嗅探包。</li><li>当如下事件发生时，嗅探模式会被停止：<ul><li>在Rx模式窗口期间，接受到了数据包，在接收完成后会产生”RxDone”中断，并返回STDBY_RC模式</li><li>在Rx模式窗口期间，收到了来自主机的SetStandby()命令。<em>注意：在sleep模式下无法接收命令</em></li></ul></li></ol><p><strong>如果periodBaseCount被设置为0x0000，那么又会进入单次接收模式，没有超时限制，模块会保持接收模式直到收到新的数据包，然后返回STDBY_RC模式。设置为其他数据时，periodBaseCount才能用于指定接收的窗口期长度</strong></p><h3 id="信道活动检测模式（Channel-Activity-Detection-CAD）"><a href="#信道活动检测模式（Channel-Activity-Detection-CAD）" class="headerlink" title="信道活动检测模式（Channel Activity Detection CAD）"></a>信道活动检测模式（Channel Activity Detection CAD）</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetCAD</td><td style="text-align:center">0xC5</td><td style="text-align:center">操作码</td><td style="text-align:center">操作码</td></tr></tbody></table></div><p><strong>该模式仅能在LoRa调制下使用</strong>。该模式下，模块会寻找LoRa的信号，寻找的Preamble长度由SetCadParams()操作来设置。在寻找结束后，模块会返回STDBY_RC模式。在寻找结束时，设备会产生“CadDone”中断，如果有效的信号被找到了，还会产生“CadDetected”中断</p><p><em>这个模式在需要先收后发的应用中非常实用</em></p><p>参数设置命令SetCadParams()</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetCadParams</td><td style="text-align:center">0x88</td><td style="text-align:center">操作码+cadSymbolNum</td><td style="text-align:center">操作码+0x01+cadSymbolNum</td></tr></tbody></table></div><p>其中，cadSymbolNum用于指明触发CAD的符号数（变相决定了寻找时长），定义如下</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215160705990.png" alt="image-20240215160705990"></p><p><strong><em>注意：用于CAD的符号数设置为1和2时，错误检测风险较高</em></strong></p><h2 id="基本设置相关"><a href="#基本设置相关" class="headerlink" title="基本设置相关"></a>基本设置相关</h2><h3 id="长Preamble模式"><a href="#长Preamble模式" class="headerlink" title="长Preamble模式"></a>长Preamble模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetLongPreamble</td><td style="text-align:center">0x98</td><td style="text-align:center">操作码+enable（0x01）</td><td style="text-align:center">-</td></tr></tbody></table></div><p><strong>该指令只能在LoRa模式或GFSK模式使用</strong>。这个指令对LoRa的影响是：会修改嗅探模式SetRxDutyCycle的行为，如果有preamble被侦测到，那么RX模式的时间会被拓展为 $sleepPeriod+2*RxPeriod$</p><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetAutoTx</td><td style="text-align:center">0x98</td><td style="text-align:center">操作码+time[15:8]+time[7:0]</td><td style="text-align:center">操作码+0x02+time[15:8]+time[7:0]</td></tr></tbody></table></div><p>部分通信协议要求在收到数据包后发送一个应答包，例如BLE要求在收到数据包后150us发送回应。这个命令就是用来设置自动回应用的。回应延时由time参数控制，由于从RX模式切换到TX模式需要时间，因此需要一个Offset来修正，通常$offset\approx 33us$。延时计算公式如下</p><script type="math/tex; mode=display">Tx_{Delay}=time+offset</script><p>time就是输入的time参数，该参数以毫秒为单位。time参数传递0x0001就是1us。</p><p>只要这个命令被发送了，那么每当设备进入Rx模式并收到了数据包后，就会自动切入Tx模式，在延时$Tx_{Delay}$后发送一个应答包，然后回到普通模式（例如STDBY_RC模式）。</p><p><em>note:user must issue the command SetAutoTx with 0x00 as the time argument</em></p><h3 id="传输完成后返回FS模式"><a href="#传输完成后返回FS模式" class="headerlink" title="传输完成后返回FS模式"></a>传输完成后返回FS模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetAutoFS</td><td style="text-align:center">0x9E</td><td style="text-align:center">操作码+enable（0x01）</td><td style="text-align:center">操作码+0x01+enable（0x01）</td></tr></tbody></table></div><p>默认情况下，Rx和Tx模式结束后都会返回STDBY_RC模式，如果使用了此命令，那么则是返回至FS模式。这样可以减少切换至Rx或Tx模式的时间。</p><p>enbale用于控制该功能是否启用，0x01表示使能，0x00表示失能。</p><h3 id="包格式选择"><a href="#包格式选择" class="headerlink" title="包格式选择"></a>包格式选择</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetPacketType</td><td style="text-align:center">0x8A</td><td style="text-align:center">操作码+PacketType</td><td style="text-align:center">操作码+0x01+PacketType</td></tr></tbody></table></div><p>PacketType参数用于指定调制包格式，定义如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240211172403669.png" alt="image-20240211172403669"></p><p><em>例如：选择LoRa包格式，发送指令为0x8A+0x01</em></p><h3 id="设置包参数"><a href="#设置包参数" class="headerlink" title="设置包参数"></a>设置包参数</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetPacketParams</td><td style="text-align:center">0x8C</td><td style="text-align:center">操作码+param1…param7</td><td style="text-align:center">操作码+0x07+param1…param7</td></tr></tbody></table></div><p> 对于7个parameter，其作用如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215162800145.png" alt="image-20240215162800145"></p><p>在LoRa模式下，几个参数详细定义如下</p><p><strong>PreambleLength</strong>（参数1）</p><p>改Byte由两部分组成，LORA_PBLE_LEN_MANT[3:0] 和 LORA_PBLE_LEN_EXP[7:4]。mant表示尾数，exp表示指数，MANT占低四位，EXP占高四位，它们各自的范围都在[1,15]之间（注意不可为0）。preamble的长度和这两个参数的关系如下：</p><script type="math/tex; mode=display">preamble\ length=LORA\_PBLE\_LEN\_MANT*2^{LORA\_PBLE\_LEN\_EXP}</script><p>推荐的preamble长度是12 symbols，也就是将MANT设置为6，EXP设置为1，即可得到该值。</p><p><strong>HeaderType</strong>（参数2）</p><p>Header用于指明LoRa包中是否包含Header，详见LoRa包格式章节。</p><div class="table-container"><table><thead><tr><th style="text-align:center">宏定义关键词</th><th style="text-align:center">值</th><th style="text-align:center">Header模式</th></tr></thead><tbody><tr><td style="text-align:center">EXPLICIT_HEADER</td><td style="text-align:center">0x00</td><td style="text-align:center">EXPLICIT HEADER</td></tr><tr><td style="text-align:center">IMPLICIT_HEADER</td><td style="text-align:center">0x80</td><td style="text-align:center">IMPLICIT HEADER</td></tr></tbody></table></div><p><strong>PayloadLength</strong>（参数3）</p><p>该参数值的范围在 [1,255] 之间。用于指明载荷数据的长度。</p><p><strong>CRC</strong>（参数4）</p><p>该参数用于控制CRC使能与否</p><div class="table-container"><table><thead><tr><th style="text-align:center">宏定义关键词</th><th style="text-align:center">值</th><th style="text-align:center">CRC使能情况</th></tr></thead><tbody><tr><td style="text-align:center">LORA_CRC_ENABLE</td><td style="text-align:center">0x20</td><td style="text-align:center">CRC ENABLE</td></tr><tr><td style="text-align:center">LORA_CRC_DISABLE</td><td style="text-align:center">0x00</td><td style="text-align:center">CRC DISABLE</td></tr></tbody></table></div><h3 id="设置调制参数"><a href="#设置调制参数" class="headerlink" title="设置调制参数"></a>设置调制参数</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetModulationParams</td><td style="text-align:center">0x8B</td><td style="text-align:center">操作码+param[0]+param[1]+param[2]</td><td style="text-align:center">操作码+0x03+param[0]+param[1]+param[2]</td></tr></tbody></table></div><p>该指令的param参数在不同包格式下有不同意义，此处只介绍LoRa包格式下</p><ul><li>param[0]：扩展因子SF，值，宏定义和SF间关系如下表</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">宏定义</th><th style="text-align:center">值</th><th style="text-align:center">SF</th></tr></thead><tbody><tr><td style="text-align:center">LORA_SF_5</td><td style="text-align:center">0x50</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">LORA_SF_6</td><td style="text-align:center">0x60</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">LORA_SF_7</td><td style="text-align:center">0x70</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">LORA_SF_8</td><td style="text-align:center">0x80</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">LORA_SF_9</td><td style="text-align:center">0x90</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">LORA_SF_10</td><td style="text-align:center">0xA0</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">LORA_SF_11</td><td style="text-align:center">0xB0</td><td style="text-align:center">11</td></tr><tr><td style="text-align:center">LORA_SF_12</td><td style="text-align:center">0xC0</td><td style="text-align:center">12</td></tr></tbody></table></div><ul><li>param[1]：带宽BW，值，宏定义和SF间关系如下表</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">宏定义</th><th style="text-align:center">值</th><th style="text-align:center">BW (KHz)</th></tr></thead><tbody><tr><td style="text-align:center">LORA_BW_1600</td><td style="text-align:center">0x0A</td><td style="text-align:center">1625.0</td></tr><tr><td style="text-align:center">LORA_BW_800</td><td style="text-align:center">0x18</td><td style="text-align:center">812.5</td></tr><tr><td style="text-align:center">LORA_BW_400</td><td style="text-align:center">0x26</td><td style="text-align:center">406.25</td></tr><tr><td style="text-align:center">LORA_BW_200</td><td style="text-align:center">0x34</td><td style="text-align:center">203.125</td></tr></tbody></table></div><ul><li>param[2]：前向纠错编码率CR，CR，值，宏定义和SF间关系如下表<br>|     宏定义     |  值  | 编码率 |<br>| :——————: | :—: | :——: |<br>|  LORA_CR_4_5   | 0x01 |  4/5   |<br>|  LORA_CR_4_6   | 0x02 |  4/6   |<br>|  LORA_CR_4_7   | 0x03 |  4/7   |<br>|  LORA_CR_4_8   | 0x04 |  4/8   |<br>| LORA_CR_Li_4_5 | 0x05 |  4/5<em>  |<br>| LORA_CR_Li_4_6 | 0x06 |  4/6</em>  |<br>| LORA_CR_Li_4_7 | 0x07 |  4/8*  |</li></ul><p>上表中 * 代表长交织。</p><ul><li>以上参数详见 <em>LoRa基础</em> 篇</li></ul><h3 id="设置RF频率模式频率"><a href="#设置RF频率模式频率" class="headerlink" title="设置RF频率模式频率"></a>设置RF频率模式频率</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetRfFrequency</td><td style="text-align:center">0x86</td><td style="text-align:center">操作码+频率[23:16]+频率[15:8]+频率[7:0]</td><td style="text-align:center">操作码+0x03+频率[23:16]+频率[15:8]+频率[7:0]</td></tr></tbody></table></div><p>其中，频率(rfFrequency)参数与发射频率间公式如下：</p><script type="math/tex; mode=display">F_{RF}=\frac{F_{XOSC}}{2^{18}}*rfFrequency</script><p><em>例如：通过SPI发送0x86+0xB8+0x9D+0x89，即可设置rfFrequency=12098953（D），在外部晶振52MHz的情况下，$F_{RF}=2399999832Hz$，即，2.4GHz</em></p><h3 id="设置发送功率"><a href="#设置发送功率" class="headerlink" title="设置发送功率"></a>设置发送功率</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetTxParams</td><td style="text-align:center">0x8E</td><td style="text-align:center">操作码+power+rampTime</td><td style="text-align:center">操作码+0x02+power+rampTime</td></tr></tbody></table></div><p>power参数用于控制发射功率，SX1280支持的<strong>功率范围在-18~13dBm</strong>，其与power参数的关系公式如下</p><script type="math/tex; mode=display">P_{RF}=-18+power</script><p>也就是说，<strong>power参数的范围在[0,31]区间内。</strong></p><p>rampTime参数用于控制运放（PA）的上升时间，官方驱动中的宏定义、参数和时间对应表如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215142108205.png" alt="image-20240215142108205"></p><h3 id="设置数据缓冲区-buffer-基地址"><a href="#设置数据缓冲区-buffer-基地址" class="headerlink" title="设置数据缓冲区(buffer)基地址"></a>设置数据缓冲区(buffer)基地址</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetBufferBaseAddress</td><td style="text-align:center">0x8F</td><td style="text-align:center">操作码+txBaseAdress+rxBaseAdress</td><td style="text-align:center">操作码+0x02+txBaseAdress+rxBaseAdress</td></tr></tbody></table></div><p>数据缓冲区rx和tx共享256字节空间，地址从0x00到0xFF之间。详见硬件-Data buffer</p><h2 id="获取设备工作状态"><a href="#获取设备工作状态" class="headerlink" title="获取设备工作状态"></a>获取设备工作状态</h2><h3 id="获取设备状态"><a href="#获取设备状态" class="headerlink" title="获取设备状态"></a>获取设备状态</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">GetStatus</td><td style="text-align:center">0xC0</td><td style="text-align:center">操作码</td><td style="text-align:center">操作码</td></tr></tbody></table></div><p>该命令用于检索收发器的状态，任意模式（STDBY，RX，TX）都可以执行该命令。模块会在收到该操作码后返回1byte的设备状态码，状态码定义如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240216151615876.png" alt="image-20240216151615876"></p><h3 id="获取当前包格式"><a href="#获取当前包格式" class="headerlink" title="获取当前包格式"></a>获取当前包格式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">GetPacketType</td><td style="text-align:center">0x03</td><td style="text-align:center">操作码+NOP+NOP</td><td style="text-align:center">操作码+0x01</td></tr></tbody></table></div><p>模块会在SPI命令的第二个NOP时，向主机发送当前包格式数据。UART通信下，在0x01发送完之后的空隙位返回包格式。</p><p>包格式如下</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240211172403669.png" alt="image-20240211172403669"></p><h3 id="获取Rx缓冲区状态"><a href="#获取Rx缓冲区状态" class="headerlink" title="获取Rx缓冲区状态"></a>获取Rx缓冲区状态</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">GetRxBufferStatus</td><td style="text-align:center">0x17</td><td style="text-align:center">操作码+NOP+NOP+NOP</td><td style="text-align:center">操作码+0x02</td></tr></tbody></table></div><p>该命令会先后返回最后收到的数据包的长度（rxPayloadLength）和Rx缓冲区的基地址（rxStartBufferPointer）。在发送操作码后，SPI命令间隔一个NOP后开始接收，先接收rxPayloadLength，再接收rxStartBufferPointer。UART命令在发送0x02后开始接收。</p><p><em>注意：当采用LoRa包格式，且设置为Implicit Header（Fixed-length）模式的时候，rxPayloadLength参数会始终返回0x00。因为在这个模式中不存在Header，因此无法提取Payload长度。在这种模式下，要得知Payload长度，直接通过寄存器操作命令，读取预先设置的寄存器即可。</em></p><h3 id="获取当前包状态"><a href="#获取当前包状态" class="headerlink" title="获取当前包状态"></a>获取当前包状态</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">GetPacketStatus</td><td style="text-align:center">0x1D</td><td style="text-align:center">操作码+NOP+NOP+NOP+NOP+NOP+NOP(6个 NOP)</td><td style="text-align:center">操作码+0x05</td></tr></tbody></table></div><p>使用此命令可以检索有关上次接收的数据包的信息，命令会在SPI模式的第一个NOP后，UART模式的长度码后，开始返回信息。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215164517698.png" alt="image-20240215164517698"></p><p>信息总共有5位。不同包格式返回的信息意义不同，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215164255603.png" alt="image-20240215164255603"></p><p>对于LoRa包模式下，参数意义如下</p><ul><li>rssiSync：:Received Signal Strength Indicator，信号强度。一旦检测到同步地址，就会锁存rssiSync值，根据rssiSync可算出真实信号功率：$P=-(rssiSync)/2(dBm)$</li><li>snrPkt：信噪比，该值由最后一个数据包估计得出。实际SNR和该值换算关系是$SNR=snrPkt/4 (dB)$。如果SNR&lt;=0，那么RSSI值需要修正为：$RSSI_\{packet, real\} = RSSI_\{packet,measured\} – SNR_\{measured\}$</li></ul><h3 id="获取当前瞬时-RSSI-值"><a href="#获取当前瞬时-RSSI-值" class="headerlink" title="获取当前瞬时 RSSI 值"></a>获取当前瞬时 RSSI 值</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">Getressiinst</td><td style="text-align:center">0x1F</td><td style="text-align:center">操作码+NOP+NOP</td><td style="text-align:center">操作码+0x01</td></tr></tbody></table></div><p>该指令会在SPI模式第二个NOP，UART指令发送完0x01后，返回参数rssiInst参数，用于指明当前包的RSSI强度，参数值与强度对应关系如下：</p><script type="math/tex; mode=display">Signal Power=(-rssiInst)/2(dBm)</script><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>SX1280有16个中断源，每一个都可以单独启用或是屏蔽，每一个也都可以被映射至DIO1,DIO2,DIO3。中断寄存器和中断源如下表：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215170132747.png" alt="image-20240215170132747"></p><h3 id="设置DIO和中断映射、中断使能"><a href="#设置DIO和中断映射、中断使能" class="headerlink" title="设置DIO和中断映射、中断使能"></a>设置DIO和中断映射、中断使能</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th></tr></thead><tbody><tr><td style="text-align:center">SetDioIrqParams</td><td style="text-align:center">0x8D</td></tr></tbody></table></div><p>SPI指令顺序：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215170643786.png" alt="image-20240215170643786"></p><p>UART指令顺序</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215170703777.png" alt="image-20240215170703777"></p><p><strong>irqMask参数</strong></p><p>​    该参数用于使能中断，1表示使能，0表示失能。参考上方中断寄存器和中断源表，其左边的bit对应的就是该参数。例如，要使能TxDone中断，就需要把irqMask的bit0设置为1，此时，产生中断时，IRQ Register中对应的 TxDone 才会被置1。</p><p><strong>dioMask参数</strong></p><p>​    该参数用于标明链接哪些中断到DIO引脚上。例如，如果想要TxDone中断产生时，DIO1引脚也被置1，就需要置位irqMask bit0 来使能中断，然后置位dio1Mask bit0 来链接该中断至DIO1。任意中断都可被映射至所有DIO，对于某一个DIO，当映射至该脚位的所有中断标志都为0的时候，IO输出0，否则输出1（或运算的逻辑）。</p><h3 id="获取中断状态"><a href="#获取中断状态" class="headerlink" title="获取中断状态"></a>获取中断状态</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">GetIrqStatus</td><td style="text-align:center">0x15</td><td style="text-align:center">操作码+NOP+NOP+NOP</td><td style="text-align:center">操作码+0x02</td></tr></tbody></table></div><p>该指令会在SPI模式第二个NOP，UART指令发送完0x02后，先后返回irqStatus[15:8]和irqStatus[7:0]。这是16位IRQ寄存器中的值的状态，对应本小节中最开始的寄存器表。</p><h3 id="清除中断标志"><a href="#清除中断标志" class="headerlink" title="清除中断标志"></a>清除中断标志</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">ClearIrqStatus</td><td style="text-align:center">0x97</td><td style="text-align:center">操作码+IRQMASK[15:8]+IRQMASK[7:0]</td><td style="text-align:center">操作码+0x02+IRQMASK[15:8]+IRQMASK[7:0]</td></tr></tbody></table></div><p>将需要清除的中断在对应的IRQMASK位中置1，即可清除中断。例如，如果IRQMASK的位0置1，则IRQ寄存器中的位0处的IRQ标志清0。</p><h2 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h2><h3 id="发送连续波"><a href="#发送连续波" class="headerlink" title="发送连续波"></a>发送连续波</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetTxContinuousWave</td><td style="text-align:center">0xD1</td><td style="text-align:center">操作码</td><td style="text-align:center">操作码</td></tr></tbody></table></div><p>该命令会使模块以设置的频率和功率发送连续的波。直到主机发送切换模式的命令之前，设备都会保持在发送连续波的模式中。这个命令对除了FLRC之外的所有包格式都适用。</p><h3 id="发送连续Preamble"><a href="#发送连续Preamble" class="headerlink" title="发送连续Preamble"></a>发送连续Preamble</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetTxContinuousPreamble</td><td style="text-align:center">0xD2</td><td style="text-align:center">操作码</td><td style="text-align:center">操作码</td></tr></tbody></table></div><p>在GFSK包格式下，这个命令会使得天线发送交变的”0”和“1”。在LoRa模式下，这个命令会发送“0” （也就是LoRa的Preamble）。在主机发送更改模式的命令之前都会保持发送。</p><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="Data-Buffer"><a href="#Data-Buffer" class="headerlink" title="Data Buffer"></a>Data Buffer</h2><p>片上Data Buffer有256Byte，用于存放待发送数据或接收数据，其如何分配是可编程的。可使用官方提供的接口来指定TX和RX所用buffer的基地址。除睡眠模式外，任何工作模式均可访问该buffer。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240208020605152.png" alt="image-20240208020605152"></p><h3 id="接收数据对Data-Buffer的写入"><a href="#接收数据对Data-Buffer的写入" class="headerlink" title="接收数据对Data Buffer的写入"></a>接收数据对Data Buffer的写入</h3><p>接收数据时，数据由 rxBaseAddress （也就是图中蓝色区域，SetBufferBaseAddress()指向的地方）开始写入，向上生长。然后由 RxDataPointer 指向数据顶部地址。在一开始时，RxDataPointer = rxBaseAddress 。</p><h3 id="发送数据读取Data-Buffer的方式"><a href="#发送数据读取Data-Buffer的方式" class="headerlink" title="发送数据读取Data Buffer的方式"></a>发送数据读取Data Buffer的方式</h3><p>在切换到传输模式时，会先由setPacketParam() 中的 payLoadLength 参数指明待发送的数据长度，然后由数据指针 TxDataPointer 初始化为 TxBaseAddress 的地址，发送一个字节自增1，直到发送的字节等于payLoadLength为止。</p><h2 id="模拟信号收发前端"><a href="#模拟信号收发前端" class="headerlink" title="模拟信号收发前端"></a>模拟信号收发前端</h2><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><ul><li><p><strong>自动增益控制(Automatic Gain Control AGC)</strong></p><p>用于确保接收机增益被设定成最佳的值来接收信号。可以通过以下寄存器配置：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120010721928.png" alt="image-20240120010721928" style="zoom:67%;" /></p></li></ul><p>人工配置增益时，寄存器数值于增益对应关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120010828585.png" alt="image-20240120010828585"></p><ul><li><strong>低功耗模式和高感模式</strong></li></ul><p>收模式分为低功耗模式和高灵敏度模式，通过配置寄存器0x891的bit6:7来控制。设置为3(11)的时候，为灵敏度模式，设置为0(00)的时候为低功耗模式</p><h3 id="片上RC震荡器"><a href="#片上RC震荡器" class="headerlink" title="片上RC震荡器"></a>片上RC震荡器</h3><p>片上RC振荡器有64KHz和13MHz两个频率，64KHz的用于休眠模式时钟，13MHz用于SPI或UART通信</p><p>RC振荡器需要在上电或环境温度发生变化时进行校准。校准使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先配置需要校准的，选项如下:</span></span><br><span class="line"> calibParam.ADCBulkPEnable = <span class="number">1</span>;</span><br><span class="line"> calibParam.ADCBulkNEnable = <span class="number">1</span>;</span><br><span class="line"> calibParam.ADCPulseEnable = <span class="number">1</span>;</span><br><span class="line"> calibParam.PLLEnable = <span class="number">1</span>;</span><br><span class="line"> calibParam.RC13MEnable = <span class="number">1</span>;</span><br><span class="line"> calibParam.RC64KEnable = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//然后调用函数校准</span></span><br><span class="line">Radio.Calibrate(calibParam); <span class="comment">//opcode 0x89</span></span><br></pre></td></tr></table></figure><h1 id="驱动LoRa的步骤"><a href="#驱动LoRa的步骤" class="headerlink" title="驱动LoRa的步骤"></a>驱动LoRa的步骤</h1><h2 id="初始化设备"><a href="#初始化设备" class="headerlink" title="初始化设备"></a>初始化设备</h2><ol><li>SX1280在上电复位时，会默认进入STDBY_RC模式，如果不处于该模式，必须使用 SetStandby 附加 0x00 参数，使其切换至STDBY_RC模式；UART指令为0x80+0x01+0x00；</li><li>使用 SetPacketType 附加LoRa包格式的参数（0x01），选择为LoRa数据包格式；UART指令顺序为0x8A+0x01+0x01；</li><li>设置RF的频率，通常设置为2.4G即可，其他值可参照操作码中 SetRfFrequency 章节；UART指令为：0x86+0x03+0xB8+0x9D+0x89，SPI下命令组合为：0x86+0xB8+0x9D+0x89</li><li>通过 SetBufferBaseAddress 指定数据buffer内rx和tx的基地址通过 SetModulationParams 设置LoRa的SF，BW 和 CR</li><li>通过 SetPacketParams 选择LoRa需要使用的Preamble长度（推荐12个符号），Header类型，数据长度，CRC类型，是否反转IQ</li><li>通过 SetTxParam 设置发信输出功率和ramp time</li><li>通过 SetDioIrqParams 使能和映射相应中断</li></ol><h2 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h2><ol><li>通过 WriteBuffer(offset, <em>数据) </em>(官方驱动API)* 将数据写入 Data Buffer，offset 的值通常设为 txBaseAddress 即可</li><li>通过 SetTx 发送数据，直到 TxDone 或是 RxTxTimeout 中断产生，代表发送结束</li><li>清除中断</li></ol><h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><ol><li>通过 SetRx 将设备置于接收模式，等待 RxDone 或 RxTxTimeout</li><li>通过 ClrIrqStatus 清除中断</li><li>通过 GetRxBufferStatus 取得 PayloadLengthRx 和 rxStartBufferPointer</li><li>使用 ReadBuffer(offset, PayloadLengthRx) 来读取接受的buffer数据，其中offset = rxStartBufferPointer</li></ol><h1 id="测距的步骤"><a href="#测距的步骤" class="headerlink" title="测距的步骤"></a>测距的步骤</h1><h1 id="官方驱动函数接口"><a href="#官方驱动函数接口" class="headerlink" title="官方驱动函数接口"></a>官方驱动函数接口</h1><h2 id="进入待机模式"><a href="#进入待机模式" class="headerlink" title="进入待机模式"></a>进入待机模式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **朝寄存器写入**</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="title function_">WriteRegister</span><span class="params">(address,data)</span> <span class="comment">//opcode 0x18</span></span><br></pre></td></tr></table></figure><ul><li><strong>读取寄存器</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReadRegister(address) <span class="comment">//opcode 0x19</span></span><br></pre></td></tr></table></figure><ul><li><strong>朝数据buffer写入</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WriteBuffer(offset,data) <span class="comment">//opcode 0x1A</span></span><br></pre></td></tr></table></figure><ul><li><strong>读取数据buffer</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReadBuffer(offset) <span class="comment">//opcode 0x1B</span></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="供电的选择"><a href="#供电的选择" class="headerlink" title="供电的选择"></a>供电的选择</h1><p>在DCDC线路被并入供电线路时，可以使用如下指令进行配置供电：</p><p>配置参数对应的模式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120040942451.png" alt="image-20240120040942451"></p><p>VBAT(RF天线供电)和VBAT_IO(数字IO供电)可以独立供电，如果都使用一个电压两个直接并一起即可。如果主控单片机IO口接受的电压很低，可以把VBAT_IO接到单片机的低压供电。举个例子，VBAT给3.3V供电，但是VBAT_IO只给1.8V，这样就可以和一个1.8V电压的单片机通讯。</p><h1 id="LoRa通信包和LoRa-Packet-Engine"><a href="#LoRa通信包和LoRa-Packet-Engine" class="headerlink" title="LoRa通信包和LoRa Packet Engine"></a>LoRa通信包和LoRa Packet Engine</h1><p><strong>在使用LoRa通信时，扩频因子（SF）和带宽（BW）必须在链路的发送侧和接收侧预已知，因为不同的扩频因子彼此正交</strong></p><p>使用LoRa调制解调时，灵敏度和速率如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120042818216.png" alt="image-20240120042818216"></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120042827446.png" alt="image-20240120042827446"></p><h2 id="LoRa-通信包格式"><a href="#LoRa-通信包格式" class="headerlink" title="LoRa 通信包格式"></a>LoRa 通信包格式</h2><p>LoRa调制有两种包格式，无论是哪种格式，preamble都是必须的。preamble用于接受信号的时钟同步，其基础长度为4.25个symbol （LoRa自动添加），冗余长度可在[8, 61444.25] 个符号编程。因此preamble的符号长度为[12.25, 61444.25]范围内。在<em>LoRa基础</em>一章中，已经介绍LoRa的包长度为$2^{SF}$，也就是下面两图的总symbol数是$2^{SF}$个。</p><p>两种格式如下：</p><ul><li><p>Explicit Header Mode（default）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240123175952581.png" alt="image-20240123175952581"></p><p>Explicit格式如图所示，相比于Implicit Header Mode，它多一个8个symbol长的header，其包含三部分：</p><ul><li>有效码字(payload) 长度</li><li>前向纠错码编码率</li><li>16bit-CRC是否使能</li></ul></li><li><p>Implicit Header Mode</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240123175412975.png" alt="image-20240123175412975"></p></li></ul><p>如果有效码字(payload)长度、前向纠错编码率、CRC使能状态已知，则可以省去header。此时有效码字(payload)长度、前向纠错编码率、CRC使能状态必须在通信链路双方进行手动预配置。</p><h2 id="LoRa测距包格式"><a href="#LoRa测距包格式" class="headerlink" title="LoRa测距包格式"></a>LoRa测距包格式</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124010130578.png" alt="image-20240124010130578"></p><p>测距的包格式如上，其包含一个指定的测距Header，包含了测距指令+测距ID+2bit的CRC。Rangging symbols内包含测距同步信息和时钟同步信息。<strong>LoRa规定测距时SF的范围是[5, 10]，带宽BW范围是[400KHz, 1.6MHz].</strong></p><p>主机视角测距过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124010545561.png" alt="image-20240124010545561"></p><p>从机视角测距过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124010621166.png" alt="image-20240124010621166"></p><h2 id="测距引擎"><a href="#测距引擎" class="headerlink" title="测距引擎"></a>测距引擎</h2><h3 id="测距误差的来源"><a href="#测距误差的来源" class="headerlink" title="测距误差的来源"></a>测距误差的来源</h3><ul><li><p>主、从设备的时钟频率不一致</p></li><li><p>数字和模拟调制模块对信号产生了延迟，这种延迟需要手动补偿</p></li><li><p>多径效应</p></li></ul><p>针对以上误差，官方建议以交换主从设备，测好几遍来进行补偿。一个测两遍的补偿例子如下：</p><script type="math/tex; mode=display">  T_{Master-Slave}=2T_{ToF}-T_{ERROR}</script><script type="math/tex; mode=display">  T_{Slave-Master}=2T_{ToF}-T_{ERROR}</script><script type="math/tex; mode=display">  T_{RTToF}=\frac{T_{Master-Slave}+T_{Slave-Master}}{2}</script><p>官方给出了交换测距次数和测距误差的关系图( SF9 1600 kHz 条件下)</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124020804572.png" alt="image-20240124020804572"></p><h3 id="距离分辨率"><a href="#距离分辨率" class="headerlink" title="距离分辨率"></a>距离分辨率</h3><p>LoRa的最小距离分辨率由如下公式计算得到：</p><script type="math/tex; mode=display">D_{LSB}=\frac{c}{2^{12}BW}</script><p>其中c是光速，BW是设置的带宽(与SF有关)</p><p>2倍测量距离（也就是飞行时间换算出的距离）和$D_{LSB}$可以由如下公式转换：</p><script type="math/tex; mode=display">D_{RTToF}=RangingRsult*D_{LSB}</script><h3 id="RxTx造成DELAY的补偿"><a href="#RxTx造成DELAY的补偿" class="headerlink" title="RxTx造成DELAY的补偿"></a>RxTx造成DELAY的补偿</h3><p>在初始测试时，需要在一段已知距离为D的空间内进行测距，来确定<strong>距离补偿误差</strong>。补偿误差可由如下公式计算：</p><script type="math/tex; mode=display">D_{uncalibrated}=((RangingResult * DLSB)/2)</script><script type="math/tex; mode=display">D_{calibration} = (D_{uncalibrated} - D) / 2</script><p>补偿时间可由如下公式进一步算得：</p><script type="math/tex; mode=display">Calibration = D_{calibration} / D_{LSB}</script><p>SEMTECH公司给出了一部分已知的Delay补偿值：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124014924763.png" alt="image-20240124014924763"></p><p><strong>在LoRa中，TxRx延迟的补偿是自动的，补偿值（Calibration）必须被写入RxTxDelay寄存器</strong></p><h3 id="时钟误差产生的测距误差的补偿"><a href="#时钟误差产生的测距误差的补偿" class="headerlink" title="时钟误差产生的测距误差的补偿"></a>时钟误差产生的测距误差的补偿</h3><p>LoRa在收发信号时，有一个频率误差指示器，由于射频信号的频率是参考各自的晶振频率产生的，因此可以使用LoRa频率误差指示器（FEI）对主设备和从设备之间的频率误差进行简单的频率误差测量，以准确评估定时误差和等效距离误差。其中官方给出的距离误差如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124015930104.png" alt="image-20240124015930104"></p><p>官方给出的BW和SF对测距精度的影响如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124020345728.png" alt="image-20240124020345728"></p><p>官方宣称在视线内，它具有和激光测距同等的精度。下图红色表示激光测距仪的误差范围。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124020611211.png" alt="image-20240124020611211"></p><h3 id="测距参数设计准则"><a href="#测距参数设计准则" class="headerlink" title="测距参数设计准则"></a>测距参数设计准则</h3><p>LoRa测距，SF和BW会影响广播时间(直接影响功耗)和测距距离，其关系图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124021355928.png" alt="image-20240124021355928"></p><p>可以看到SF影响测距距离，BW影响广播时间。当这俩个参数都最大时，测距可有最高精度。</p><h3 id="超短距离-lt-18-5m-的补偿"><a href="#超短距离-lt-18-5m-的补偿" class="headerlink" title="超短距离(&lt;18.5m)的补偿"></a>超短距离(&lt;18.5m)的补偿</h3><p>在小于18.5m时，LoRa测距会非常不精确，STMTECH给出了以下补偿公式：</p><script type="math/tex; mode=display">displayDistance = EXP( ( measuredDistance +2.4917 ) / 7.2262 ))</script><p>补偿效果图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124021812831.png" alt="image-20240124021812831"></p><h3 id="测距的计算："><a href="#测距的计算：" class="headerlink" title="测距的计算："></a>测距的计算：</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124022454968.png" alt="image-20240124022454968"></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124022730601.png" alt="image-20240124022730601"></p><p><strong>一个例子</strong>：配置测距参数如下，得到如下测距结果：</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124022121668.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124022331367.png"></center></td>    </tr></table>]]></content>
      
      
      <categories>
          
          <category> LoRa定位开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LoRa基础</title>
      <link href="/posts/4f0d2e64.html"/>
      <url>/posts/4f0d2e64.html</url>
      
        <content type="html"><![CDATA[<h1 id="LoRa的调制与扩频"><a href="#LoRa的调制与扩频" class="headerlink" title="LoRa的调制与扩频"></a>LoRa的调制与扩频</h1><p>由通信原理的知识知，在一个载波中，基带信息可以被承载在幅度、相位、和频率上。以2FSK调制为例，它使用两个不同频率的载波来分别表示不同的”0” 和 “1”。但是Chirp调制本身就进行了”扫频”, 那么如何来通过频率进行载波呢？由<em>扩频通信简介</em>一节中Chirp扩频知，Chirp频率是有个范围的，始于$f_0$，上下被$f_H,f_L$限制。<strong>LoRa将基带信息承载在这个$f_0$上面</strong>，也就是说，LoRa调制后Symbol的频率-时间图如下<strong>（LoRa采用线性Chirp）</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240117191531057.png" alt="image-20240117191531057"></p><p>信号在时域上振幅-时间图如下(这张图里面是down-chirp, 和上面那张up-chirp的图不是对应的关系)：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240117202641043.png" alt="image-20240117202641043"></p><p>论文[1]中作者把它称为：频移啁啾调制 Frequency Shift Chirp Modulation (FSCM) 大部分文章都是这么叫的，也有另外一些地方直接把这个称为PSK调制</p><h2 id="起始频率-f-0-的确定"><a href="#起始频率-f-0-的确定" class="headerlink" title="起始频率$f_0$的确定"></a>起始频率$f_0$的确定</h2><p><strong>LoRa的扩频因子SF不光决定了频率的展扩倍数，还决定了信道进制M</strong>(例如，8FSK的M=8，一个symbol包含$log_28=3$个bit)。M和SF的关系是：</p><script type="math/tex; mode=display">log_2M=SF</script><p>MFSK里，M为几就有几个不同的频率；对应地，LoRa里M为几就有几个不同的$f_0$。$M=2^{SF}$,也就是说，一个Chirp symbol 可以调进去SF个二进制位,共有$2^{SF}$种不同的$f_0$，我们把这一簇二级制数据记为一个向量<strong>w</strong>。举个例子，如果SF=4，那么一个Chirp symbol就有4个Bit，<strong>w</strong>就为</p><script type="math/tex; mode=display">w=[x,x,x,x]</script><p>其中x代表这一位可以是0也可以是1。那么第n个chirp symbol 承载的信息 $s(nT_s)$ 就可以用如下公式算得：</p><script type="math/tex; mode=display">s(nT_s)=\sum_{h=0}^{SF-1}w(nT_s)_h\cdot2^h</script><p><em>注意这个$w(nT_s)$是一个整体，下标h才代表取这个向量里面的第几个，这个$T_s$是符号持续时间，$nT_s$只是指这是第几个符号之后</em>。</p><p><strong>论文就是喜欢用弯弯绕绕的表达，这玩意其实就是把二进制序列换算成十进制了！</strong>，更详细地说，LoRa在调制的时候把二进制序列换算成了范围在$[0,2^{SF}-1]$的十进制，然后作为频率的偏移量调进载波里面。$s(nT_s)=\{0,1,2,3,4….,2^{SF}-1\}$</p><h2 id="调入载波"><a href="#调入载波" class="headerlink" title="调入载波"></a>调入载波</h2><p>现在，我们要把这个十进制数用成一个起始频率来表示。LoRa的码元持续时间$T_s$被规定成$T_s=\frac{2^{SF}}{Bandwidth}$，把这个$T_s$ 以B为采样频率离散化一下:</p><script type="math/tex; mode=display">T=\frac{1}{B}, T_s=2^{SF}\cdot T</script><p>同时再来个离散化的时间轴$k=0,1,2…2^{SF}-1$</p><p>那么频率相较于$f_L$的偏移量就可以通过$(s(nT_s)+k)\ mod\ 2^{SF}$算出来，这里巧妙的利用取余计算实现了频率顶到$f_H$又返回$f_L$的操作。整体的调后信号就可以被表示为：</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}e^{j2\pi[(s(nT_s)+k)mod2^{SF}]\frac{k}{2^{SF}}}</script><h2 id="LoRa的规定："><a href="#LoRa的规定：" class="headerlink" title="LoRa的规定："></a>LoRa的规定：</h2><ul><li><p>扩频因子： LoRa规定SF必须在[7,12]之内</p></li><li><p>码元持续时间：规定$T_s=\frac{2^{SF}}{Bandwidth}$</p><p>通过码元持续时间可以计算符号速率$R_s=\frac{BW}{2^{SF}}$</p></li><li><p>LoRa支持冗余纠错，SEMTECH定义了一个$Rate Code=\frac{4}{4+CR}$,其中CR={1,2,3,4}</p><p>在rate code已知时，bit传输速率使用这个公式计算：</p><script type="math/tex; mode=display">R_b=SF*\frac{Rate Code}{\frac{2^{SF}}{BW}}</script></li></ul><h1 id="LoRa的解调"><a href="#LoRa的解调" class="headerlink" title="LoRa的解调"></a>LoRa的解调</h1><p>我们已知，LoRa调后的信号长这样：</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}e^{j2\pi[(s(nT_s)+k)mod2^{SF}]\frac{k}{2^{SF}}}</script><p>这个信号可以看做是一个chirp信号被移动了一下初始相位，我们可以把它补偿回来以此来分离出chirp信号</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}e^{j2\pi[(s(nT_s)+k)mod2^{SF}+k-k]\frac{k}{2^{SF}}}</script><p>这里$+k-k$并不影响函数结果，但是我们却可以分离出一个$+k$出来</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}(e^{j2\pi \frac{k^2}{2^{SF}}})e^{j2\pi[(s(nT_s)+k)mod2^{SF}-k]\frac{k}{2^{SF}}}</script><p>在$(s(nT_s)+k)mod2^{SF}-k$中，这个取模运算是为了处理$(s(nT_s)+k)$超过了$f_H$的情况而使用的。但是这里整个时间尺度被-k之后，控制频率的分量将永远在$s(nT_s)$的范围内，不会超过$2^{SF}$,因此无需再取模计算。去掉mod画简后式子如下：</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}(e^{j2\pi \frac{k^2}{2^{SF}}})e^{j2\pi[(s(nT_s)]\frac{k}{2^{SF}}}</script><p>此时，基础chirp信号被分离出来了。在这个例子中这里这是一个up chirp信号。只需要将现在的接收信号乘上它自己的基础chirp信号的共轭$e^{-j2\pi \frac{k^2}{2^{SF}}}$，就可以把这个chirp信号消除掉。up chirp的共轭恰好为down chirp, down chirp的共轭为up chirp。消除后信号为：</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}e^{j2\pi[(s(nT_s)]\frac{k}{2^{SF}}}</script><p>此时接收信号的频率只与我们调入的信息$s(nT_s)$相关了，对这个函数进行FFT，然后寻找FFT结果的峰值位置，即可解调出$s(nT_s)$内包含的信息。</p><p>因此，LoRa的解调只需要将收到的信号与其基础chirp信号的共轭相干，就可以分离出调入了信息的信号。</p><div class="note warning simple"><p>LoRa的调制和解调详细过程是SEMTECH闭源的，<strong>但是可以确定的是SF确实直接对应一个symbol能调几个bit，以及LoRa采用初始频率的shift去调制</strong>。其他的细节仅摘自论文，里面有很多只能看个大概的地方，就比如那个论文[1]里提及讲Ts离散化的时候，间隔时间T=1/B，这是不符合奈奎斯特采样定律的。看个大概就好……</p></div><h1 id="LoRa的时钟同步"><a href="#LoRa的时钟同步" class="headerlink" title="LoRa的时钟同步"></a>LoRa的时钟同步</h1><p>LoRa的时钟同步原理官方并未披露，现有的各种文章各执一词，但是大体都是前面有一段Preamble发送标准的up-chirp信号来进行同步。下图是对LoRa的信号进行捕获得到的。</p><p>个人猜测LoRa配置的同步字(sync word)是作用于header的位置的(吧……)</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240118000915052.png" alt="image-20240118000915052"></p><h1 id="emmmm"><a href="#emmmm" class="headerlink" title="emmmm"></a>emmmm</h1><p>研究了几十个小时，啃了十来篇文章，LoRa有太多东西是SEMTECH闭源的了，每个文章都是点逆向工程又讲得不明不白的。下面[3]这个youtube视频算是所有不明不白的文章的一个核心思想吧，但是每篇文章细节是有差异的。</p><p>搞了这么多，只想说好奇心害死猫，这玩意只能别人告诉你怎么用你就怎么用就行了╮(╯﹏╰）╭</p><p>所以说，有些东西没人搞，那必然是有没人搞的理由吧哎……活该干不过NB-IOT</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li>[1] L. Vangelista, “Frequency Shift Chirp Modulation: The LoRa Modulation,” in IEEE Signal Processing Letters, vol. 24, no. 12, pp. 1818-1821, Dec. 2017, doi: 10.1109/LSP.2017.2762960.</li><li>[2]  <a href="http://wiki.lahoud.fr/lib/exe/fetch.php?media=an1200.22.pdf">AN1200_22_Semtech_LoRa_Basics_v2_STD (lahoud.fr)</a></li><li>[3] <a href="https://www.youtube.com/watch?v=jHWepP1ZWTk">How LoRa Modulation really works - long range communication using chirps - YouTube</a></li><li>[4] H. Mroue, A. Nasser, B. Parrein, S. Hamrioui, E. Mona-Cruz and G. Rouyer, “Analytical and Simulation study for LoRa Modulation,” 2018 25th International Conference on Telecommunications (ICT), Saint-Malo, France, 2018, pp. 655-659, doi: 10.1109/ICT.2018.8464879.</li><li>[5] <a href="https://cea.hal.science/cea-02280910v2/document">Low Complexity LoRa Frame Synchronization for Ultra-Low Power Software-Defined Radios (hal.science)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LoRa定位开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -频带通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩频通信简介</title>
      <link href="/posts/76361032.html"/>
      <url>/posts/76361032.html</url>
      
        <content type="html"><![CDATA[<div class="note warning simple"><p>本篇文章涉及通信原理知识，需要掌握一定通信原理基础，了解基带调制，频带调制，相干解调，码元(符号)传输速率，Power Spectrum Density 等</p></div><p><strong>有三种基本的扩频方式：</strong></p><ul><li>跳频扩频(Frequency-hopping speread spectrum)</li><li>直接序列扩频(Direct-sequence spread spectrum)</li><li>啁啾扩频/线性调频扩频(Chirp Spread Spectrum)</li></ul><h1 id="跳频技术-FHSS"><a href="#跳频技术-FHSS" class="headerlink" title="跳频技术(FHSS)"></a>跳频技术(FHSS)</h1><p>传统的无线通信系统，发射机和接收机工作在单次通信过程中，载频一般是保持不变；例如通信频率是900MHz, 那么通信将一直使用这个频率进行。</p><p>跳频（Frequency Hopping)系统则在单次通信中，载频在多个频率上跳变。如901MHz, 902MHz etc.</p><h2 id="跳频系统的调制与解调"><a href="#跳频系统的调制与解调" class="headerlink" title="跳频系统的调制与解调"></a>跳频系统的调制与解调</h2><p>跳频的调制发生在频带调制之前。如下图所示，原始数据D(t)经过信息调制器后变成基带信号；同时产生一个伪随机序列来控制载波信号按照一定的规律跳变。接收端需要使用产生本振信号(local oscillator)进行相干，产生一个中频信号，中频信号再进行检波/解调。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114232032360.png" alt="image-20240114232032360"></p><p>伪随机序列控制下的载波频率如下图所示，在不同频段间跳跃，这个图被称为跳频图案，通信双方可根据实时参数及密钥推算得到当前跳频图案</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114233026923.png" alt="image-20240114233026923" style="zoom:50%;" /></p><p>对于产生跳频，有如下要求：</p><ul><li>(同一跳频图案具有良好的自相关性(类似冲激函数)</li><li>不同跳频图案具有良好的互相关性(相关值趋近于0</li><li>跳频图案具有良好的随机性，足够大的线性复杂度(抗截获和抗破译)</li><li>周期长和图案多(减小系统中各用户间的频点碰撞概率</li></ul><p>跳频可以分为快跳频和慢跳频：</p><ul><li><p><strong>快跳频</strong>：跳频周期小于符号周期(是Ts的约数)，一个符号传输需要多个频率</p></li><li><p><strong>慢跳频</strong>：跳频周期大于符号周期(是Ts的倍数)，一个频率传输多个符号</p></li></ul><p><strong>跳频通信可以带来很强的抗干扰能力的原因：</strong></p><ul><li>在同一时刻，干扰信号频率只有与跳频信号所在<strong>频率相同</strong>，且干扰信号能量足够大时，才能造成严重的影响</li><li>由于跳频图案具有<strong>伪随机性，其周期可长达数十年甚至更长</strong>，跳变的频率可达成千上万个，因此可以有效地躲避干扰。因此除非破译跳频图案，否则仅在某一频率或<strong>某几个频率上长时间施放干扰是无济于事的</strong>。而在整个频段长时间施放干扰难度很大</li></ul><h2 id="多址通信"><a href="#多址通信" class="headerlink" title="多址通信"></a>多址通信</h2><p> 多址技术是指把处于不同地点的多个用户接入一个公共传输媒质，实现各用户之间通信的技术。</p><p>例如，常见的多址技术有频分多址（<a href="https://baike.baidu.com/item/FDMA?fromModule=lemma_inlink">FDMA</a>）、时分多址（<a href="https://baike.baidu.com/item/TDMA?fromModule=lemma_inlink">TDMA</a>）、码分多址（<a href="https://baike.baidu.com/item/CDMA?fromModule=lemma_inlink">CDMA</a>）。</p><ul><li>FDMA：不同用户使用不同的频率</li><li>TDMA：不同用户发送时刻不同，以不同时隙实现通信</li><li>CDMA：以不同的代码序列来实现通信，码分多址的基本思想是靠不同的地址码来区分的地址。每个配有不同的地址码，用户所发射的载波既受基带数字信号调制，又受地址码调制。</li></ul><p><strong>跳频技术可以实现跳频多址：</strong>不同的用户使用不同的跳频图案，这样可以实现共享频段资源进行通信。下图就是不同用户以不同图案通信时的跳频图案。跳频有一定几率碰撞(两个发射器使用了同一个频率)，就是下图绿色的点点。通过对伪随机码进行设计，可以把跳频碰撞的概率控制得很小。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114234609263.png" alt="image-20240114234609263" style="zoom:80%;" /></p><hr><h1 id="直接序列扩频-（DSSS）"><a href="#直接序列扩频-（DSSS）" class="headerlink" title="直接序列扩频 （DSSS）"></a>直接序列扩频 （DSSS）</h1><h2 id="DSSS信号的调制与解调"><a href="#DSSS信号的调制与解调" class="headerlink" title="DSSS信号的调制与解调"></a>DSSS信号的调制与解调</h2><p>直接序列扩频使用扩频码(又称扩频序列、PN序列)，直接对基带信号进行频域扩宽。如下图就是一个对Bipolar NRZ信号扩频调制的例子。绿色的是频率更高的扩频码，由扩频序列产生器产生。将基带信号与扩频码相异或，即可得到扩频信号。解调时，在本振信号相干得到中频信号后，再使用同样的扩频信号相干（这个过程称为解扩），即可恢复基带信号。</p><p><table>    <tr>        <td><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114235653121.png"></td>        <td><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114235840911.png"></td>    </tr></table><br>扩频的时域、频域对应图像如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240117192815452.png" alt="image-20240117192815452"></p><p>一个完整的扩频、解扩过程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240115000300778.png" alt="image-20240115000300778"></p><h2 id="扩频增益-扩频因子-Spreading-Factor"><a href="#扩频增益-扩频因子-Spreading-Factor" class="headerlink" title="扩频增益/扩频因子  Spreading Factor"></a>扩频增益/扩频因子  Spreading Factor</h2><p>下列定义式中，Rc为直扩码速率；Rb为信息码速率。T是其对应单的持续时间（$T=1/f$）。</p><script type="math/tex; mode=display">G=10lg(\frac{扩频后的信号频率}{原始信号频率})=10lg(\frac{R_C}{R_b})=10lg(\frac{T_b}{T_C})</script><p><strong>G就是扩频增益。Rc/Rb即为扩频因子也称扩频码长度、带宽扩展因子</strong></p><p>例如，原始信号频率为1MHz，扩频后为128MHz，则扩频因子$SF=128$ <em>(<strong>部分地方直接认为扩频因子就是增益G</strong>，其实就是是否取对数的区别)</em></p><p>一般来说，扩频序列越长，扩频倍数越大，扩频增益越大</p><h2 id="直扩信号优点和及其原理"><a href="#直扩信号优点和及其原理" class="headerlink" title="直扩信号优点和及其原理"></a>直扩信号优点和及其原理</h2><h3 id="直扩通信抗窄带干扰的原理"><a href="#直扩通信抗窄带干扰的原理" class="headerlink" title="直扩通信抗窄带干扰的原理"></a>直扩通信抗窄带干扰的原理</h3><ul><li><p>一个原始的窄带信号，在经历扩频序列扩频之后，其能量不变(频域面积不变)，而频域展宽。</p></li><li><p>在传输时叠加了窄带噪声信号（例如来自其他通信系统的通信信号）</p></li><li>解调时再次用扩频码相干，延展频域扩频信号的恢复成窄带信号，而对叠加的窄带噪声信号，则是进行了一个扩频的过程。</li><li>在经历Bandpass filter的时候，噪声信号大部分功率可被滤除掉</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/1705249284302.jpg" alt="1705249284302" style="zoom:50%;" /></p><h3 id="直扩通信抗多径效应的原理"><a href="#直扩通信抗多径效应的原理" class="headerlink" title="直扩通信抗多径效应的原理"></a>直扩通信抗多径效应的原理</h3><p>受多径效应影响，接受到的信号由多个不同时延和相位的原始信号构成（来自不同传输路径）</p><ul><li>在单一解扩支路的情况下，通过调整解扩码的同步，可以只解扩振幅最强的一路信号，其他路径的信号在通过滤波器时就会被滤除</li><li>在多个解扩支路的情况下，接收端解扩码分别和来自不同路径的信号对齐，将其解扩分离。最后再将解扩出的多路信号相位时延对齐后叠加，恢复原始信号。</li></ul><h3 id="直扩信号抗劫获的原理"><a href="#直扩信号抗劫获的原理" class="headerlink" title="直扩信号抗劫获的原理"></a>直扩信号抗劫获的原理</h3><p>直扩信号频带很宽，功率谱密度很低。如果在接收机输入端，直扩信号的功率谱密度低于或与接收机热噪声功率谱密度相当，则接收机一般发现不了直扩信号(隐藏在噪声中)。</p><h3 id="直扩信号的保密性"><a href="#直扩信号的保密性" class="headerlink" title="直扩信号的保密性"></a>直扩信号的保密性</h3><p>接收端只有采用与发射端相同且同步的扩频序列，才能实现对直扩信号的解扩，恢复出发送信号而扩频序列具有随机特性，破译难度大直接序列扩频技术首先应用于军事通信</p><h2 id="直接序列扩频下的码分多址"><a href="#直接序列扩频下的码分多址" class="headerlink" title="直接序列扩频下的码分多址"></a>直接序列扩频下的码分多址</h2><p>不同用户采用不同的扩频序列，<strong>而这个扩频序列恰好就充当了码分多址里面地址码的作用。对某一个用户来说，他的接收机只能解扩对应扩频序列的信号，而其他用户的信号因为扩频序列不同，无法解扩，类似噪声。</strong>所以虽然看起来直扩通信每个用户看似占用频率很宽，但由于是共享不是独享，所以频谱利用率也很高的</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240115004032089.png" alt="image-20240115004032089"></p><h2 id="扩频序列（扩频码）"><a href="#扩频序列（扩频码）" class="headerlink" title="扩频序列（扩频码）"></a>扩频序列（扩频码）</h2><p>由前面介绍的直扩信号可以看出，我们希望扩频序列：</p><ul><li>近似于随机信号有良好的自相关特性（可有效提取自身信号），很小的互相关特性（不同扩频序列间干扰小）</li><li>有尽可能多的码(序列个数，就是不重复的码长度)<br>下面是常见的扩频序列</li></ul><h3 id="m序列"><a href="#m序列" class="headerlink" title="m序列"></a>m序列</h3><p>m序列又称<strong>最长线性反馈移位寄存器序列</strong>，它是由<strong>多级移位寄存器</strong>通过线性反馈(就是下图这些摩尔加的抽头)产生的最长的码序列</p><p><strong>对于n级的移位寄存器发生器所能产生的最大长度的码序列为$2^n -1$位</strong>（没有全0状态，因为一旦去了全0状态就无法游动到其他状态）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240115005914227.png" alt="image-20240115005914227"></p><p><strong>不同初始状态的移位寄存器，只会产生不同相位的扩频序列，无法产生不同的扩频序列；不同的扩频序列需要通过改变抽头结构来产生。</strong>而且并不是所有抽头组合都能产生m序列，只有特殊的组合才可以。</p><p><strong>m序列有良好的自相关性，较小的互相关性的优点</strong></p><p>对于n位的m序列，它能产生的序列个数可由如下公式计算：(其中$\Phi$是欧拉数)</p><script type="math/tex; mode=display">\frac{\Phi(2^n-1)}{n}</script><p>计算可以发现，5级移位寄存器产生的$2^5 -1=31$位长度的m序列，只有6个。</p><p>因此，<strong>m序列具有数量较少的缺点</strong></p><center><strong>总结：m序列，优点：有良好的自相关性，较小的互相关性；缺点：m序列具有数量较少的缺点</strong></center><h3 id="M序列"><a href="#M序列" class="headerlink" title="M序列"></a>M序列</h3><p>m序列又称<strong>最长非线性反馈移位寄存器序列</strong>。M序列在m序列的基础上，加入了全0状态检测器，使其离开全0状态。</p><p>对于n个移位寄存器，可以产生$2^n$位的M序列</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240115011351277.png" alt="image-20240115011351277"></p><p>n级M序列的个数可以用如下公式来计算</p><script type="math/tex; mode=display">2^{2^{n-1}-n}</script><p>在同为5级的时候，M序列可以产生2048个。<strong>因此M序列序列数量远大于m序列，但M序列的自相关性和互相关性又不如m序列</strong></p><h3 id="Gold序列"><a href="#Gold序列" class="headerlink" title="Gold序列"></a>Gold序列</h3><p>Gold序列将两个m序列作为优选对，把两个m序列的输出结果进行摩尔加。</p><p><strong>它具有良好的自相关性，不明显的互相关性，构造简单</strong>因此获得广泛应用</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240115011757069.png" alt="image-20240115011757069"></p><hr><h1 id="啁啾扩频-线性调频扩频-CSS"><a href="#啁啾扩频-线性调频扩频-CSS" class="headerlink" title="啁啾扩频/线性调频扩频(CSS)"></a>啁啾扩频/线性调频扩频(CSS)</h1><h2 id="啁啾-zh-overline-ou-ji-overline-u"><a href="#啁啾-zh-overline-ou-ji-overline-u" class="headerlink" title="啁啾($zh\overline ou ji\overline u$)"></a>啁啾($zh\overline ou ji\overline u$)</h2><p>啁啾是频率随时间增加（up-chirp）或减少（down-chirp）的信号，其基本定义式如下：</p><script type="math/tex; mode=display">x(t)=sin(\phi(t))</script><p>可以看到啁啾使用相位的移动来控制震荡频率，其相位是一个与 $t$ 有关的函数。在这个表达式下，瞬时角频率 $\omega$ 也就成了$\phi$ 的变化速率，即对$\phi(t)$求导。</p><script type="math/tex; mode=display">\omega(t)=\frac{d\phi(t)}{dt}</script><p>再根据 $\omega$ 和 $f$ 的关系，可以写出频率表达式：</p><script type="math/tex; mode=display">f(t)=\frac{\omega(t)}{2\pi}</script><p>类似于“角加速度”的概念，定义一个瞬时角啁啾系数(instantaneous angular chirpyness) $\gamma(t)$，单位：$rad/s^2$</p><script type="math/tex; mode=display">\gamma(t)=\frac{d^2\phi(t)}{dt}=\frac{d\omega(t)}{dt}</script><p>instantaneous angular chirpyness 定义的是瞬时角频率的变化率，将角频率转化为频率，就得到的 instantaneous ordinary chirpyness $c(t)$ (定义为瞬时频率的变化率)</p><script type="math/tex; mode=display">c(t)=\frac{\gamma(t)}{2\pi}=\frac{df(t)}{2\pi}</script><h3 id="线性啁啾"><a href="#线性啁啾" class="headerlink" title="线性啁啾"></a>线性啁啾</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240116114246398.png" alt="image-20240116114246398"></p><p>线性啁啾是指的瞬时频率$f(t)$随时间呈线性变化，下式中c是啁啾率(chirp rate)，是一个常数，表达式为$c=\frac{f_1-f_0}{T}=\frac{\Delta f}{\Delta t}$</p><script type="math/tex; mode=display">f(t)=ct+f_0</script><p>转化成基本定义式中的相位的表达形式:</p><script type="math/tex; mode=display">\phi(t)=\phi_0+2\pi\int_0^tf(\tau)d\tau=\phi_0+2\pi(\frac{c}{2}t^2+f_0t)</script><p>其中$\phi_0$表示初始相位</p><h3 id="指数啁啾"><a href="#指数啁啾" class="headerlink" title="指数啁啾"></a>指数啁啾</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240116120520930.png" alt="image-20240116120520930"></p><p>指数啁啾的定义为：</p><script type="math/tex; mode=display">f(t)=f_0k^{\frac{t}{T}}</script><p>它具有如果$t_1$和$t_2$间时间间隔$T=t_2-t_1$是常数，$f_2(t)/f_1(t)$也是常数的性质。</p><p>相位表达式如下：</p><script type="math/tex; mode=display">\phi(t)=\phi_0+2\pi\int_0^tf(\tau)d\tau=\phi_0+2\pi f_0(\frac{k^{\frac{t}{T}}-1}{ln(k)})</script><h3 id="双曲啁啾"><a href="#双曲啁啾" class="headerlink" title="双曲啁啾"></a>双曲啁啾</h3><p>双曲啁啾定义为：</p><script type="math/tex; mode=display">f(t)=\frac{f_0f_1T}{(f_0-f_1)t+f_1T}</script><p>其相位表达式为：</p><script type="math/tex; mode=display">\phi(t)=\phi_0+2\pi\int_0^tf(\tau)d\tau=\phi_0+2\pi \frac{-f_0f_1T}{f_1-f_0}ln(1-\frac{f_1-f_0}{f_1T}t)</script><p>除此之外，还有对数啁啾，二次(^2)啁啾等，都是指的其频率的变化呈现对数、二次的关系。</p><h2 id="啁啾扩频"><a href="#啁啾扩频" class="headerlink" title="啁啾扩频"></a>啁啾扩频</h2><p>由上方啁啾信号得知，啁啾信号频率随时间变化，也就是说，在频域来看，这个信号自带“扫频/扩频” 的特性。</p><p><strong>如果说使用这个信号来作为载波，调制信号，那么这么信号的带宽也就被扩宽了。这就是啁啾扩频的原理。</strong>啁啾扩频利用了其频率在整个带宽上线性变化的正弦脉冲信号来传输信息，因此不需要任何伪随机序列。</p><p>举个例子，下图这个调制模块（802.15.4a中定义的超带宽UWB调制，Chirp-UWB）：二进制信号先转化为差分信号后进行QPSK调制，再对QPSK信号进行进行啁啾调制来扩频得到QCSK信号。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240116124709497.png" alt="image-20240116124709497"></p><p>在这个例子中，调后的一个啁啾符号（Chirp Symbol）由4个啁啾脉冲（subchirp）构成，每个啁啾脉冲又可以携带一个QPSK信号。从而一个啁啾符号可以携带4个QPSK码字。</p><p>由于不能让这个啁啾信号占用无限的带宽，所以会对这个啁啾载频规定一个频率上限$f_H$和一个频率下限$f_L$，以up-chirp为例，它由起始频率$f_0$开始，随时间攀升，如果在自身持续周期内超过了$f_H$，那它将回到$f_L$,再继续爬升如下图所示(下图横坐标为时间$t$,纵坐标为频率$f$)。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240117184131604.png" alt="image-20240117184131604"></p><hr><center> ---CHAPTER END--- </center>]]></content>
      
      
      <categories>
          
          <category> LoRa定位开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 频带通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1-CH3-数字电路的化简</title>
      <link href="/posts/37477dca.html"/>
      <url>/posts/37477dca.html</url>
      
        <content type="html"><![CDATA[<h1 id="最小化策略"><a href="#最小化策略" class="headerlink" title="最小化策略"></a>最小化策略</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>包含名词：</strong></p><ul><li><p><strong>Literal:</strong> 字符，也就是有几个输入变量</p></li><li><p><strong>Implicant:</strong> 蕴含项，输入变量的不同组合,也就是卡诺图里面的圈，一个圈就是一种蕴含项。</p></li><li><p><strong>Prime implicant:</strong> 质蕴含项就是不能与其它蕴含项合并的蕴含项, 也就是，这个卡诺图的圈无法被更大的圈包裹.</p></li><li><p><strong>Cover:</strong> cover是不同implicant的组合，就是不同卡诺图的圈组合成的完整的表达式。</p></li><li><p><strong>Cost:</strong> 电路中所有 门的数量 + 门的输入信号的数量</p></li><li><p><strong>Essential prime implicant:</strong>  若函数的一个质蕴涵项包含有不被函数的其他任何质蕴涵项所包含的最小项，则此质蕴涵项被称为必要质蕴涵项。</p></li></ul><p><em>举个例子：</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114192019432.png" alt="image-20240114192019432"  /></p><p>$\overline x_2  x_3$就是一个essential prime implicant, 因为$m_{11}$没有被其他任何质蕴涵项包含。同理还有$x_3 \overline x_4$ 和$x_2 \overline x_3 x_4$.<br>在最少的cost的布尔方程里面，必要质蕴涵项是必须被包含的。写出必要质蕴涵项之后，发现$m_7$还没有被包含到。$m_7$可以被$\overline x_1  x_3$或者$\overline x_1  x_2 x_4$包含，取其最小成本$\overline x_1 x_3$,所以这个布尔函数最小cost是：</p><script type="math/tex; mode=display">f=\overline x_2  x_3 + x_3 \overline x_4+x_2 \overline x_3 x_4+\overline x_1 x_3</script><p><strong><em>因此，寻找最小cost电路的步骤是：</em></strong></p><ol><li><strong>写出$f$的所有质蕴含项*</strong></li><li><strong><em>找到所有必要质蕴涵项</em></strong></li><li><strong><em>如果必要质蕴含项就包含了函数的所有1状态，那这就是最小cost，如果没有，则需要添加cost最小的非必要质蕴涵项来覆盖所有1状态</em></strong></li></ol><hr><h1 id="多输出电路（Multiple-Output-circuits）"><a href="#多输出电路（Multiple-Output-circuits）" class="headerlink" title="多输出电路（Multiple-Output circuits）"></a><em>多输出电路（Multiple-Output circuits）</em></h1><p>在具有多个输出的电路中，让电路共享一些逻辑门可以有效减少cost</p><p>这要求在卡诺图化简中<strong>并不一定按照质蕴涵项去画圈，而是查看更多蕴含项，寻找相同的蕴含项</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114193447675.png" alt="image-20240114193447675"></p><p>如上图就有两个蕴含项可以被共享。CAD工具将会自动执行这个共享的过程。在人工设计（考试）的时候，多输出电路也可以通过尽量圈出可以共享的圈圈来减少cost</p><hr><h1 id="多级综合（Multilevel-Synthesis）—不考"><a href="#多级综合（Multilevel-Synthesis）—不考" class="headerlink" title="多级综合（Multilevel Synthesis）—不考"></a><em>多级综合（Multilevel Synthesis）—不考</em></h1><ul><li><p><strong>Fan-in (扇入):</strong> 一个逻辑门输入的数量</p></li><li><p><strong>Fan-out(扇出):</strong> 是指该模块直接调用的下级模块的个数。也就是一个逻辑门的输出连了几个下一级门。</p></li></ul><p>通常来说，使用CMOS制造的芯片存在扇入限制。通常希望AND门扇入小于5。可以使用分配率，把一层极的计算化成多个层级。下图就是两个例子</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114193819266.png"/></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114193752663.png"/></center></td>    </tr></table><hr><h1 id="立体表示法（Cubical-Representation）"><a href="#立体表示法（Cubical-Representation）" class="headerlink" title="立体表示法（Cubical Representation）"></a><em>立体表示法（Cubical Representation）</em></h1><p>卡诺图能表示的函数大小受到限制，为了处理更大的函数，需要使用立方体表示。</p><h2 id="构造立方体"><a href="#构造立方体" class="headerlink" title="构造立方体"></a>构造立方体</h2><p>有几个变量，就需要构造一个几维的立方体。立方体的顶点代表不同变量组合，立方体的边必须是含有一个x的组合，x代表0或者1。而面是含有两个x的组合。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114194225368.png" alt="image-20240114194225368"></p><p><em>以这个三维的cube为例，</em>首先标注顶点，000为顶点开始的三条边（三个变量所以三条边，x在三条边上换3个位置）需要分别为00x,0x0,x00,这三条边连接的另一个顶点将会是001,010,100（也就是x取和000相反的情况）。然后将新的顶点以同样的规则向外延伸，直至构成立方体。</p><h2 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h2><p>$f={000,010,100,101,110}$,将函数表达出来，并在顶点处标注出来。上图中的顶点围成了一个面和一条线，这个面是xx0，这条线是10x,所以这个函数可以被化简成</p><script type="math/tex; mode=display">f=\overline x_3 +x_1x_2</script><h2 id="四维立方体："><a href="#四维立方体：" class="headerlink" title="四维立方体："></a>四维立方体：</h2><p>四维立方体可以画成在一个大立方体内囊括了一个小立方体。这样每个顶点都有4条支路，可以安装上面的方法标注顶点了。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114194642317.png" alt="image-20240114194642317"></p><hr><h1 id="表格法化简（Quine-McCluskey-法）"><a href="#表格法化简（Quine-McCluskey-法）" class="headerlink" title="表格法化简（Quine-McCluskey 法）"></a><strong>表格法化简（Quine-McCluskey 法）</strong></h1><h3 id="Step1-–-计算质蕴涵项"><a href="#Step1-–-计算质蕴涵项" class="headerlink" title="Step1 – 计算质蕴涵项"></a>Step1 – 计算质蕴涵项</h3><ol><li>首先，把minterm表达式的项按只含0个“1”，只含1个“1”，只含2个“1”，…，只含n个“1”（n为变量个数）划分为不同的Group，并按“1”的数量排列（升序或降序均可）成表</li><li>准备一张新表。从含有最少数量的“1”的Group开始依次向下，将当前Group中的每一项与下一个Group的每一项比较。若两者只有一个变量不同，则将两项提取出来，并将不同的变量处用x标记，生成一个新的项。如果新的项在新表中已存在，则不执行动作；若不存在，则将这个新的项放到新表中的相应Group中。最后，在原表的两个Group中将提取的两项对应的“Subcube Covered”打上标记（打√）</li><li>在新生成的表中，重复2，直到新表中不存在只有一个变量不同的项为止</li><li><strong>所有未被打√的项，就是质蕴涵项。</strong></li></ol><p>例如：$f_{(x_1,…x_4)}=\sum m(0,4,8,10,11,12,13,15)$</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114195340907.png" alt="image-20240114195340907"></p><p>所以这个表达式的质蕴涵项就是</p><script type="math/tex; mode=display">P={10x0,101x,110x,1x11,11x1,xx00}</script><h3 id="Step2-–-找到必要质蕴含项"><a href="#Step2-–-找到必要质蕴含项" class="headerlink" title="Step2 – 找到必要质蕴含项"></a>Step2 – 找到必要质蕴含项</h3><p>把step1中找到的质蕴涵项列成表,如下图。发现0和4只有xx00表达了，所以xx00是必要质蕴涵项。把$P_6$挑出来</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114195622722.png" alt="image-20240114195622722"></p><h3 id="Step3-–-找到最小成本非必要质蕴涵项"><a href="#Step3-–-找到最小成本非必要质蕴涵项" class="headerlink" title="Step3 – 找到最小成本非必要质蕴涵项"></a>Step3 – 找到最小成本非必要质蕴涵项</h3><p>移除p6和被p6表达的0,4,8,12(被挑走了)，得到下表</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114195726090.png" alt="image-20240114195726090"></p><p>可以看到p1和p2的cost是相同的（他们都只有一个x），但是p1只能表述10, p2可以表述10，11，因此称p2支配 (dominates) p1。因此在这里选择p2。同理，可以选择p5。可以看到p4已经被p2和p5表达，因此这是不必要的。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114195754979.png" alt="image-20240114195754979"></p><h3 id="Step4-–-完成化简"><a href="#Step4-–-完成化简" class="headerlink" title="Step4 – 完成化简"></a>Step4 – 完成化简</h3><p>取step2的必要质蕴含项，step3选取的之蕴含项，<br>所以，化简后：$C={p_2,p_5,p_6 },f=x_1\overline x_2 x_3+x_1 x_2 x_4+\overline x_1 \overline x_3$</p><hr><center> ---CHAPTER END--- </center>]]></content>
      
      
      <categories>
          
          <category> 大三上 </category>
          
          <category> 数字电路设计与可靠性工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅思写作</title>
      <link href="/posts/7ea537cf.html"/>
      <url>/posts/7ea537cf.html</url>
      
        <content type="html"><![CDATA[<h1 id="通用句子"><a href="#通用句子" class="headerlink" title="通用句子"></a>通用句子</h1><h2 id="太多啦"><a href="#太多啦" class="headerlink" title="太多啦"></a>太多啦</h2><ul><li>be flooded with 被淹没</li><li>be drowning in 被淹没</li><li>with the development of the technology =  we cannot deny the development of the technology</li></ul><h2 id="重要的"><a href="#重要的" class="headerlink" title="重要的"></a>重要的</h2><ul><li>compousory(adj. 义务的) 替换 important</li></ul><h2 id="形容人"><a href="#形容人" class="headerlink" title="形容人"></a>形容人</h2><ul><li>humble adj. 谦逊的</li><li>down to earth 接地气</li><li>entrepreneur n. 企业家  /ˌɒn.trə.prəˈnɜːr/； entrepreneurial adj. 具有企业家特质的;  </li></ul><h1 id="聊生活"><a href="#聊生活" class="headerlink" title="聊生活"></a>聊生活</h1><ul><li>cater to me 合我的口味</li><li>fishbone 鱼刺</li><li>promotional flyer 传单</li><li>cold calling 广告电话</li><li>rise the interesting 提高兴趣</li><li>slow pace life 慢节奏生活</li><li>be addicted to sth   对sth. 成瘾; addiction</li></ul><h1 id="聊工作，聊未来"><a href="#聊工作，聊未来" class="headerlink" title="聊工作，聊未来"></a>聊工作，聊未来</h1><ul><li>technics n.技术</li></ul><h2 id="工作职位"><a href="#工作职位" class="headerlink" title="工作职位"></a>工作职位</h2><ul><li>a man work for government 公务员</li><li>salesman 销售人员</li><li></li></ul><h1 id="自然环境"><a href="#自然环境" class="headerlink" title="自然环境"></a>自然环境</h1><h3 id="旅游景点"><a href="#旅游景点" class="headerlink" title="旅游景点"></a>旅游景点</h3><ul><li>scenic spot </li><li>tourist traction </li></ul><h1 id="答题技法"><a href="#答题技法" class="headerlink" title="答题技法"></a>答题技法</h1><h2 id="精细对比"><a href="#精细对比" class="headerlink" title="精细对比"></a>精细对比</h2><p>如果题目中有过去-现在；男-女；年轻-老；这类一定要分人群分两段作答。</p>]]></content>
      
      
      <categories>
          
          <category> 雅思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅思写作</title>
      <link href="/posts/7ea537cf.html"/>
      <url>/posts/7ea537cf.html</url>
      
        <content type="html"><![CDATA[<p>[施工中..]</p><h1 id="写作评分标准"><a href="#写作评分标准" class="headerlink" title="写作评分标准"></a>写作评分标准</h1><h1 id="Task1-小作文"><a href="#Task1-小作文" class="headerlink" title="Task1 小作文"></a>Task1 小作文</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h2><p>所有类型的小作文都遵循：</p><ul><li>第一段：一句话重述题目 + overall 开启图表概括。</li><li>body段：一般2-3段，根据图表聚类分段</li></ul><p>也就是总分结构</p><p>第一段的例文：</p><p><em>The diagram shows the different stages in the life cycle of a salmon. Overall, the cycle takes almost ten years and comprises three main stages, each of which takes place in a different aquatic environment.</em></p><h2 id="适用于所有类型小作文的注意事项"><a href="#适用于所有类型小作文的注意事项" class="headerlink" title="适用于所有类型小作文的注意事项"></a>适用于所有类型小作文的注意事项</h2><h3 id="数字的写法"><a href="#数字的写法" class="headerlink" title="数字的写法"></a>数字的写法</h3><p>数字1-9最好使用英文形式，10及以上的可以用数字（有两个数字组成的）</p><h2 id="流程图小作文-（flow-chart-process-tasks）"><a href="#流程图小作文-（flow-chart-process-tasks）" class="headerlink" title="流程图小作文 （flow chart / process tasks）"></a>流程图小作文 （flow chart / process tasks）</h2><p>顾名思义，流程图小作文会给一个工业加工流程、生物生长流程、机械运作流程等等流程，要求总结流程图中的信息（summarise the information），然后写出主要的流程（selecting and reporting the main features），并在相似的的地方呈现出比较。下图是一个例子</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240303103536846.png" alt="image-20240303103536846" style="zoom:50%;" /></p><h3 id="段落构建"><a href="#段落构建" class="headerlink" title="段落构建"></a>段落构建</h3><ul><li>首先需要根据流程图将步骤（steps）分为几个阶段（stages），然后根据处理的流程中的变化，将阶段聚类分类成几个主要的阶段（main stages）。</li></ul><p><em>举个例子，这个流程图:</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240303104910497.png" alt="image-20240303104910497" style="zoom:50%;" /></p><p><em>其整体可以分为在农田里面的，和进入工厂榨汁的两个main stages, 因此聚类步骤1-2在一起，3-7在一起。这些 main stages 使用能概括这个流程的上义词（umbrella terms）来概括</em></p><ul><li><p>使用首段结构：重述题目+overview概括流程。在此处概括时，需要包含：</p><ol><li><p><strong>有多少个步骤(这个可以用总的步骤时长代替，例如三文鱼的life cycle 总时长, 如果这里的步骤太多，则使说包含多少个main stages)</strong> </p></li><li><p><strong>流程对作用物的主要改变（如果前面说的时有几个步骤，这一步可以用一句话概括，如果上面说的main stages，则这里分别陈述main stages）；</strong></p></li></ol></li></ul><p>  <em>例如，main stages写法的例子：上例的两个main stage可以写为：the growing and harvesting of sugar cane &amp; the processing of the juice to produce sugar。因此，Overview可以写为：</em></p><p>  <em>另一个例子，使用有几个步骤+一句话概括：Overall, a geothermal power plant operates by using water as a medium to convert geothermal energy into electricity（流程对作用物的主要改变 ）, and the whole process consists of five steps.（有多少个步骤）</em></p><ul><li><p>根据 main stages 分出body段 （一般为2段）：</p><p>body段需要注意句首多样性：表明每个流程的连接词尽量变换位置，不能总是在句首。常用的变换方法在下方详细介绍。</p></li></ul><h2 id="饼图-Pie-chart"><a href="#饼图-Pie-chart" class="headerlink" title="饼图 (Pie chart)"></a>饼图 (Pie chart)</h2><h3 id="段落构建-1"><a href="#段落构建-1" class="headerlink" title="段落构建"></a>段落构建</h3><ul><li>横向对比，寻找时间维度数据差异；纵向对比，寻找对象尺度数据差异；</li><li>Body段，两个对象的饼分开讲。分为两段，一个对象占一段。在描述第一段时，</li></ul><h2 id="常用积累"><a href="#常用积累" class="headerlink" title="常用积累"></a>常用积累</h2><h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><ul><li>be expected to do - 预计如何（发展）<em>e.g. is expected to change considerably 预期有巨大的变化</em></li><li>remainder - (n. 剩余物) 数据余下的部分 <em>e.g. Australia used coal as the electricity source (50 units) and the remiander was produced from natural gas</em></li><li>have developed into main xxx - 在xxx中爬升到主导地位 <em>e.g. Oil have developed into main sources 石油能源中占比爬升到了主导地位</em></li><li>led the sector 在同类别中处于领先地位</li><li>prediction = projection；（projection有特指数据的拟合，预测之意）</li><li>gradually adv. 渐渐的，用于修饰小幅度数据变化</li></ul><p><strong>数据波动</strong></p><ul><li>increased from xx to xx, despite several falls 波动上升</li><li>fluctuation n. 波动；</li></ul><p><strong>数据上升</strong></p><p><strong>数据下降</strong></p><ul><li>downward adj. 下降；<em>e.g. The country’s economy is on a downward spiral.</em></li></ul><h3 id="生命周期相关"><a href="#生命周期相关" class="headerlink" title="生命周期相关"></a>生命周期相关</h3><ul><li>begin life as xxx (e.g. begin life as an egg) - 以xxx开启一段生命</li><li>Once it has xxx - 一旦达到xxx(条件)</li><li>feeds on sth. - 以sth.为食物</li></ul><h3 id="衔接相关"><a href="#衔接相关" class="headerlink" title="衔接相关"></a>衔接相关</h3><ul><li>notably, +引出峰值/关键点（垃圾食品可用）</li><li>in both sectors, +xxx 用于代指两个并行陈述的数据</li></ul><h3 id="age-group"><a href="#age-group" class="headerlink" title="age group"></a>age group</h3><ul><li>aged xx to xx</li><li></li></ul><h1 id="Task2-大作文"><a href="#Task2-大作文" class="headerlink" title="Task2 大作文"></a>Task2 大作文</h1><p>不同于小作文，大作文需要陈述自己的观点，自己的观点可以完全站A, 完全站B，也可以认为双边都要。观点表述要清晰。</p><h2 id="常用积累-1"><a href="#常用积累-1" class="headerlink" title="常用积累"></a>常用积累</h2><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><ul><li>combination of factors - 多因素的结合</li><li>alternative - n. 替代品；</li><li>renewable(s) n.可再生物（环境保护）</li><li>recyclable(s) n. 可回收物（环境保护）</li><li>additive n. 添加剂（垃圾食品可用）</li><li>staple diet n. 主要的饮食（垃圾食品/健康可用）</li><li>it is not surprising that xxx; xxx也不足为奇</li><li>the last resort 最后的措施</li><li>surely + 你觉得怎么去做的陈述句+？ 想必+……</li><li>this is not  the case 并非如此</li><li>approach the issue 解决问题</li><li>addressing these need 关注（解决）这些需求</li><li>earning a(n) + (adj.) + living 过上xxx的生活</li><li>many aspects of modern-day life 当代生活的方方面面</li><li>excessive (adj.) / go too far 过度了</li><li></li></ul><h3 id="发展，教育类"><a href="#发展，教育类" class="headerlink" title="发展，教育类"></a>发展，教育类</h3><ul><li>be taken too far - 操之过急</li><li>well-rounded - 全面发展的</li></ul><h2 id="问题解决讨论类"><a href="#问题解决讨论类" class="headerlink" title="问题解决讨论类"></a>问题解决讨论类</h2><p>作文题目提出一个问题，讨论/评价其解决的方法。</p><p>通常来说，这个解决方法一般是部分否认的，在可以在一开始去肯定这个观点正确（有效果）的地方。后续分析问题本质，来否认这个观点</p><h3 id="要聚焦于题目抛出的问题。"><a href="#要聚焦于题目抛出的问题。" class="headerlink" title="要聚焦于题目抛出的问题。"></a>要聚焦于题目抛出的问题。</h3><p><em>举个例子：</em></p><p><em>Some people say that the best way to improve public health is by increasing the number of sports facilities. Others, however, say that this would have little effect on public health and that other measures arerequired.<br>Discuss both these views and give your own opinion.</em></p><p><em>在这个题目中，<strong>不要被 sports 局限，需要聚焦于 public health</strong>，首先应当阐释 public health 差的<strong>原因</strong>才是重点，然后从产生这个问题的<strong>原因出发</strong>，<strong>去评价</strong> increasing the number of sports facilities 这个解决方案。最后导出自己的观点</em></p><h2 id="问多大程度同意-不同意"><a href="#问多大程度同意-不同意" class="headerlink" title="问多大程度同意/不同意"></a>问多大程度同意/不同意</h2><h3 id="表明同意程度的词"><a href="#表明同意程度的词" class="headerlink" title="表明同意程度的词"></a>表明同意程度的词</h3><p><strong>部分同意</strong></p><ul><li>partly agree</li></ul><p><strong>完全同意</strong></p><p><strong>完全不同意</strong></p>]]></content>
      
      
      <categories>
          
          <category> 雅思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
