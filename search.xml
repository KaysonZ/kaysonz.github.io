<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test1</title>
      <link href="/posts/8ab2dce2.html"/>
      <url>/posts/8ab2dce2.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> private </category>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> default </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32的SPI控制器</title>
      <link href="/posts/a3cf4757.html"/>
      <url>/posts/a3cf4757.html</url>
      
        <content type="html"><![CDATA[<p>[施工中..]</p><h1 id="SPI控制器"><a href="#SPI控制器" class="headerlink" title="SPI控制器"></a>SPI控制器</h1><h2 id="SPI控制器原理"><a href="#SPI控制器原理" class="headerlink" title="SPI控制器原理"></a>SPI控制器原理</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240421140451956.png" alt="image-20240421140451956"></p><p>上图展示了STM32F4系列的SPI控制器框图。由波特率发生器产生时间信号，逻辑控制器进行MOSI和MISO控制，并产生片选信号。同时由Tx Rx两个缓冲寄存器+移位寄存器构成发送模块。控制寄存器主要有SPI_CR1，SPI_CR2，BR。</p><h3 id="发送流程"><a href="#发送流程" class="headerlink" title="发送流程"></a>发送流程</h3><ol><li>数据写入Tx Buffer</li><li>Tx Buffer内的的数据填入移位寄存器</li><li>移位寄存器逐个bit发至MOSI线</li><li>发送完毕，SPI_SR TXE寄存器置位</li></ol><h3 id="接收流程"><a href="#接收流程" class="headerlink" title="接收流程"></a>接收流程</h3><ol><li>数据写入移位寄存器</li><li>移位寄存器写入 Rx Buffer</li><li>接收完成，SPI_SR EXNE置位</li><li>读取Rx Buffer内的内容</li></ol><h3 id="片选信号"><a href="#片选信号" class="headerlink" title="片选信号"></a>片选信号</h3><p>在SPI_CR1寄存器中的SSI信号即是该控制器内的片选信号发生器。可通过配置SPI_CR1 SSM寄存器来决定该信号是否对外输出。以此实现不同的片选效果。在NSS对外输出时，配置SPI_CR1 SSOE寄存器又可定义两种不同的硬件管理模式</p><p>STM32的SPI控制器支持三种片选模式：</p><ul><li>软件管理：（SSM=1）外部NSS引脚空闲，可复用其他功能。自定义GPIO通过写高低电平实现片选</li><li>硬件管理（输出使能模式，SSM=0 SSOE=1）:STM32此时为通信主机。当主器件开始通信时，NSS 信号驱动  为低电平，并保持到 SPI 被关闭为止。</li><li>硬件管理（输出禁止模式，SSM=0 SSOE=0）：若STM32此时作为从机模式，则NSS引脚为从机片选输入。若STM32此时作为主机模式，此模式是多主机配置，多主多从SPI极少使用，此处不详细介绍。</li></ul><h2 id="时钟极性CPOL"><a href="#时钟极性CPOL" class="headerlink" title="时钟极性CPOL"></a>时钟极性CPOL</h2><ul><li>0：SCK在空闲时低电平，第一边沿为由低变高</li><li>1：SCK在空闲时高电平，第一边沿为由高变低</li></ul><h2 id="时钟相位CPHA"><a href="#时钟相位CPHA" class="headerlink" title="时钟相位CPHA"></a>时钟相位CPHA</h2><ul><li>0：SCK在第一（奇数）边沿进行采样</li><li>1：SCK在第二（偶数）边沿进行采样</li></ul><div class="note info flat"><p>时钟极性和相位通常使用00（CPOL=0,CPHA=0）或11的组合。</p></div><div class="note danger flat"><p>在使用SPI时，必须讲对应GPIO的引脚设置为复用模式。当在MspInit中进行设置。</p></div><h1 id="SPI相关寄存器"><a href="#SPI相关寄存器" class="headerlink" title="SPI相关寄存器"></a>SPI相关寄存器</h1><h2 id="SPI-CR1寄存器"><a href="#SPI-CR1寄存器" class="headerlink" title="SPI_CR1寄存器"></a>SPI_CR1寄存器</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240421143259090.png" alt="image-20240421143259090"></p><h3 id="位-15-BIDIMODE：双向通信数据模式使能-Bidirectional-data-mode-enable"><a href="#位-15-BIDIMODE：双向通信数据模式使能-Bidirectional-data-mode-enable" class="headerlink" title="位 15 BIDIMODE：双向通信数据模式使能 (Bidirectional data mode enable)"></a>位 15 BIDIMODE：双向通信数据模式使能 (Bidirectional data mode enable)</h3><ul><li>0：选择双线单向通信数据模式 </li><li>1：选择单线双向通信数据模式 </li></ul><h3 id="位-14-BIDIOE：双向通信模式下的输出使能-Output-enable-in-bidirectional-mode"><a href="#位-14-BIDIOE：双向通信模式下的输出使能-Output-enable-in-bidirectional-mode" class="headerlink" title="位 14 BIDIOE：双向通信模式下的输出使能 (Output enable in bidirectional mode)"></a>位 14 BIDIOE：双向通信模式下的输出使能 (Output enable in bidirectional mode)</h3><p>此位结合 BIDIMODE 位，用于选择双向通信模式下的传输方向 </p><ul><li>0：禁止输出（只接收模式）  </li><li>1：使能输出（只发送模式） </li></ul><p><em>注意：在主模式下，使用 MOSI 引脚；在从模式下，使用 MISO 引脚</em></p><h3 id="位-13-CRCEN：硬件-CRC-计算使能-Hardware-CRC-calculation-enable"><a href="#位-13-CRCEN：硬件-CRC-计算使能-Hardware-CRC-calculation-enable" class="headerlink" title="位 13 CRCEN：硬件 CRC 计算使能 (Hardware CRC calculation enable)"></a>位 13 CRCEN：硬件 CRC 计算使能 (Hardware CRC calculation enable)</h3><ul><li><p>0：禁止 CRC 计算 </p></li><li><p>1：使能 CRC 计算 </p></li></ul><p>注意：为确保正确操作，只应在禁止 SPI（SPE =“0”）时对此位执行写操作 </p><h3 id="位-12-CRCNEXT：下一次传输-CRC-CRC-transfer-next"><a href="#位-12-CRCNEXT：下一次传输-CRC-CRC-transfer-next" class="headerlink" title="位 12 CRCNEXT：下一次传输 CRC (CRC transfer next)"></a>位 12 CRCNEXT：下一次传输 CRC (CRC transfer next)</h3><ul><li><p>0：数据阶段（无 CRC 阶段）</p></li><li><p>1：下一次传输为 CRC（CRC 阶段） </p></li></ul><p>注意：当 SPI 配置为全双工或只发送模式时，只要最后一个数据写入 SPI_DR 寄存器，就必须对 CRCNEXT 执行写操作。  当 SPI 配置为只接收模式时，必须在接收到倒数第二个数据之后将 CRCNEXT 置 1。  当传输由 DMA 管理时，此位应保持清零状态。 </p><h3 id="位-11-DFF：数据帧格式-Data-frame-format"><a href="#位-11-DFF：数据帧格式-Data-frame-format" class="headerlink" title="位 11 DFF：数据帧格式 (Data frame format)"></a>位 11 DFF：数据帧格式 (Data frame format)</h3><ul><li><p>0：为发送/接收选择 8 位数据帧格式 </p></li><li><p>1：为发送/接收选择 16 位数据帧格式 </p></li></ul><p>注意：为确保正确操作，只应在禁止 SPI（SPE =“0”）时对此位执行写操作 </p><h3 id="位-10-RXONLY：只接收-Receive-only"><a href="#位-10-RXONLY：只接收-Receive-only" class="headerlink" title="位 10 RXONLY：只接收 (Receive only)"></a>位 10 RXONLY：只接收 (Receive only)</h3><p>此位结合 BIDIMODE 位，用于选择双线单向模式下的传输方向。此位也适用于多从模式系   统，在此类系统中，不会访问特定从器件，也不会损坏访问的从器件的输出。</p><ul><li><p>0：全双工（发送和接收） </p></li><li><p>1：关闭输出（只接收模式） </p></li></ul><h3 id="位-9-SSM：软件从器件管理-Software-slave-management"><a href="#位-9-SSM：软件从器件管理-Software-slave-management" class="headerlink" title="位 9 SSM：软件从器件管理 (Software slave management)"></a>位 9 SSM：软件从器件管理 (Software slave management)</h3><p>当 SSM 位置 1 时，NSS 引脚输入替换为 SSI 位的值。 </p><ul><li><p>0：禁止软件从器件管理 </p></li><li><p>1：使能软件从器件管理 </p></li></ul><h3 id="位-8-SSI：内部从器件选择-Internal-slave-select"><a href="#位-8-SSI：内部从器件选择-Internal-slave-select" class="headerlink" title="位 8 SSI：内部从器件选择 (Internal slave select)"></a>位 8 SSI：内部从器件选择 (Internal slave select)</h3><p>仅当 SSM 位置 1 时，此位才有效。此位的值将作用到NSS引脚上，并忽略 NSS 引脚的 IO 值。 </p><h3 id="位-7-LSBFIRST：帧格式-Frame-format"><a href="#位-7-LSBFIRST：帧格式-Frame-format" class="headerlink" title="位 7 LSBFIRST：帧格式 (Frame format)"></a>位 7 LSBFIRST：帧格式 (Frame format)</h3><ul><li><p>0：先发送 MSB </p></li><li><p>1：先发送 LSB </p></li></ul><p>注意：正在通信时不应更改此位。 </p><h3 id="位-6-SPE：SPI-使能-SPI-enable"><a href="#位-6-SPE：SPI-使能-SPI-enable" class="headerlink" title="位 6 SPE：SPI 使能 (SPI enable)"></a>位 6 SPE：SPI 使能 (SPI enable)</h3><ul><li><p>0：关闭外设 </p></li><li><p>1：使能外设 </p></li></ul><p>注意：2- 关闭 SPI 时，需按照后续介绍的指定步骤操作。</p><h3 id="位-5-3-BR-2-0-：波特率控制-Baud-rate-control"><a href="#位-5-3-BR-2-0-：波特率控制-Baud-rate-control" class="headerlink" title="位 5:3 BR[2:0]：波特率控制 (Baud rate control)"></a>位 5:3 BR[2:0]：波特率控制 (Baud rate control)</h3><ul><li>000: fPCLK/2</li><li>100: fPCLK/32</li><li>001: fPCLK/4</li><li>010: fPCLK/8</li><li>011: fPCLK/16</li><li>101: fPCLK/64</li><li>110: fPCLK/128</li><li>111: fPCLK/256 </li></ul><p>注意：正在通信时不应更改这些位。 </p><h3 id="位-2-MSTR：主模式选择-Master-selection"><a href="#位-2-MSTR：主模式选择-Master-selection" class="headerlink" title="位 2 MSTR：主模式选择 (Master selection)"></a>位 2 MSTR：主模式选择 (Master selection)</h3><ul><li><p>0：从配置 </p></li><li><p>1：主配置 </p></li></ul><p>注意：正在通信时不应更改此位。</p><h3 id="位1-CPOL：时钟极性-Clock-polarity"><a href="#位1-CPOL：时钟极性-Clock-polarity" class="headerlink" title="位1 CPOL：时钟极性 (Clock polarity)"></a>位1 CPOL：时钟极性 (Clock polarity)</h3><ul><li><p>0：空闲状态时，SCK保持低电平 </p></li><li><p>1：空闲状态时，SCK保持高电平 </p></li></ul><h3 id="位-0-CPHA：时钟相位-Clock-phase"><a href="#位-0-CPHA：时钟相位-Clock-phase" class="headerlink" title="位 0 CPHA：时钟相位 (Clock phase)"></a>位 0 CPHA：时钟相位 (Clock phase)</h3><ul><li><p>0：从第一个时钟边沿开始采样数据 </p></li><li><p>1：从第二个时钟边沿开始采样数据 注意：正在通信时不应更改此位。</p></li></ul><h2 id="SPI-CR2寄存器"><a href="#SPI-CR2寄存器" class="headerlink" title="SPI_CR2寄存器"></a>SPI_CR2寄存器</h2><h1 id="配置SPI的步骤"><a href="#配置SPI的步骤" class="headerlink" title="配置SPI的步骤"></a>配置SPI的步骤</h1><h2 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h2><h2 id="从机"><a href="#从机" class="headerlink" title="从机"></a>从机</h2>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>飞控MAVLink协议</title>
      <link href="/posts/5ba34228.html"/>
      <url>/posts/5ba34228.html</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>MAVLink（Micro Air Vehicle Link）是一种非常轻量级的消息传输协议, 用于地面控制终端（地面站）与无人机之间 (以及机载无人机组件之间) 进行通信的上层（非物理层/链路层）协议。</p><p>MAVLink有V1和V2两个版本。MAVLink 1每个数据包只有8个字节的开销, 包括起始标志和数据包丢弃检测。 MAVLink 2只有14个字节的开销 (但它是一个更安全且可扩展的协议)。 </p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240415111826666.png" alt="image-20240415111826666"></p>]]></content>
      
      
      <categories>
          
          <category> 各种折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH340系列+ISP烧录使用指南(以CH340为例)</title>
      <link href="/posts/a6c91d9a.html"/>
      <url>/posts/a6c91d9a.html</url>
      
        <content type="html"><![CDATA[<h1 id="CH430X使用指南"><a href="#CH430X使用指南" class="headerlink" title="CH430X使用指南"></a>CH430X使用指南</h1><h2 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240409131159622.png" alt="image-20240409131159622"></p><p>CH340X引脚如上图。其中：</p><ul><li>UD+ &amp; UD- : USB差分信号（CH340的USB收发器按USB2.0全内置设计，UD+和UD-引脚建议不要额外串接电阻）</li><li>RXD &amp; TXD: 串口接收、发送信号</li><li>V3：用于CH340内部供电电路退耦，<strong>在3.3V时时连接VCC输入外部电源，在5V时固定串联0.1uF电容后接地</strong>。</li><li>VCC：电源输入，<strong>需外接0.1uF退耦电容</strong></li><li>RTS#：（输出信号）Request To Send，用于告知接收端数据准备发送。</li><li>CTS#：（输入信号）Clear To Send，用于告知发送端 接收端已准备好接收 可以发送。</li><li>TNOW：（输出信号）串口正在发送的状态指示引脚，高电平表示正在发送。</li><li>DTR#：（输出信号）Data Terminal Ready，它用于告知接收端数据终端已经准备好进行通讯。</li></ul><p>其中，引脚6可复用为TNOW或DTR模式：</p><ol><li>如果为引脚6外接4.7KΩ下拉电阻到GND，那么将进入开源DTR增强模式，引脚6自动切换为开源驱动的DTR#，用于连接MCU的BOOT模式引脚，默认DTR#为不输出，被外部电阻保持为低电平， 但可以由应用程序设置DTR#引脚输出高电平或不输出，用于DTR#默认低电平的多模式MCU下载。 </li><li>如果在6#引脚与5#引脚之间接4.7KΩ电阻，那么将进入推挽DTR增强模式，6#引脚自动切 换为推挽驱动的DTR#用于连接MCU的控制引脚，可以由应用程序设置DTR#引脚输出高电平或低电平， 用于DTR#默认高电平的多模式MCU下载。</li><li>如果引脚6无外部下拉/上拉电阻，则工作为TNOW模式。</li></ol><p><strong>其中，DTR，RTS等MODEM通讯信号，是可以由计算机上的上位机通过软件更改其状态的。例如Windows下调用 <code>SETRTS</code> API，就可以执行Sends the RTS (request-to-send) signal</strong></p><p>因此，诸如MCUISP等软件，支持对RST和DTR引脚进行不同的操作，以引导MCU进入ISP烧录模式。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240409163227165.png" alt="image-20240409163227165" style="zoom: 50%;" /></p><h2 id="CH340X使用案例"><a href="#CH340X使用案例" class="headerlink" title="CH340X使用案例"></a>CH340X使用案例</h2><p>下图是南京沁恒给出的一个CH340 STM32自动下载电路的使用案例。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/6rGAjBbclrc6aBCFG2kPU72ix9d3Q5Ru3WdUvelS.jpeg" alt="img"></p><p><strong>对于CH340C电路来说，MCUISP需选择“DTR低电平复位，RST高电平进BootLoader”：</strong></p><ol><li>首先MCUISP会让DTR引脚写低电平，那这里DTR#（NOT DTR）就会变成高电平，使得Q1导通，RESET电平与RTS#相等。而一开始RTS是低电平（RTS#高电平），因此并没有复位。</li><li>MCUISP会将RTS引脚写高电平，此时RTS#变为低电平，RESET引脚拉低复位。同时BOOT0上方Q2导通，BOOT0被上拉至VCC，逻辑1。</li><li>延时100毫秒等待稳定。</li><li>DTR变为高电平，DTR#变为低电平，Q1关断，RESET重新被拉高，复位完成。RTS维持高电平，RST#保持低电平，使得Q2持续导通，BOOT0继续保持逻辑1。</li><li>成功进入Bootloader模式，释放BOOT0和RESET并开始进行ISP烧写。</li></ol><p><strong>对于CH340X免外围电路来说，MCUISP需选择“RTS高电平复位，DTR低电平进BootLoader”：</strong></p><ol><li>首先MCUISP使得RTS写高电平，RTS#变为低电平拉低RESET，开始复位。</li><li>将DTR置低，使DTR#为高电平，BOOT0为逻辑1。</li><li>延时100毫秒，等待稳定。</li><li>RTS变低电平，RTS#重新拉高RESET，复位完成。此时BOOT0仍然保持逻辑1。</li><li>成功进入BootLoader，释放BOOT0和RESET并开始进行ISP烧写。</li></ol><p>CH340X不需要外围电路，而CH340C需要的原因是</p>]]></content>
      
      
      <categories>
          
          <category> 各种折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32核心板设计</title>
      <link href="/posts/ce38ed7e.html"/>
      <url>/posts/ce38ed7e.html</url>
      
        <content type="html"><![CDATA[<h1 id="HSE时钟电路——皮尔斯-Pierce-震荡器"><a href="#HSE时钟电路——皮尔斯-Pierce-震荡器" class="headerlink" title="HSE时钟电路——皮尔斯(Pierce)震荡器"></a>HSE时钟电路——皮尔斯(Pierce)震荡器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单片机上常见的HSE时钟——一个无源晶振配合两个电容的时钟电路，就是使用的皮尔斯振荡电路，其完整电路如下图，由两个电容 ($C_1\&amp;C_2$) ，一个晶体振荡器 ($X_1$)，一个反馈电阻 ($R_1$) 和一个反相放大器 ($U_1$) 组成。$U_1$和$R_1$一般集成在芯片内部，因此这就是在STM32中选择HSE（外部晶体振荡器）时钟时，有两个引脚 <code>RCC_OSCIN</code> 和 <code>RCC_OSC_OUT</code> 被占用的原因。</p><h2 id="石英晶振的等效电路"><a href="#石英晶振的等效电路" class="headerlink" title="石英晶振的等效电路"></a>石英晶振的等效电路</h2><p><table><br>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/8601a18b87d6277ff030a1392a381f30e924fc95"></center></td>          <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240407090244851.png"></center></td>    </tr></p><p>在分析电路如何震荡之前，需要先了解石英的一个物理特性。</p><ul><li>压电效应：当对压电材料施以压力时，能产生电；反过来，当给压电材料通电，能产生形变；因此，在石英晶体的两端施加持续变化的交流电压，即可让石英音叉形变“震荡”起来，物理的形变又回反过来改变电压，从某种意义上来说这也是一个储能元件。在计算上可以把晶振等效为一个RLC电路，如下图所示。其中$C_0$是石英晶体两脚间产生的寄生电容（一般取3-5pF），其余部分是晶振本身的等效RLC，也称为其“运动（Motional）参数”。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/OIP-C.YHRlityi3tRfzIyrz41DjAHaFK" alt="晶振的等效电路"></p><h2 id="皮尔斯振荡器"><a href="#皮尔斯振荡器" class="headerlink" title="皮尔斯振荡器"></a>皮尔斯振荡器</h2><h3 id="如何进行选频"><a href="#如何进行选频" class="headerlink" title="如何进行选频"></a>如何进行选频</h3><p>我们知道，振荡器会在反馈电路的谐振频率上进行振荡，这本质是反馈回路是一个滤波器，而谐振频率是反馈回路中电抗最小的时候。因此会将该频率进行无限放大，最后在此频率上震荡。</p><p>从上面等效电路我们可以看到，晶振有两个谐振频率：一个是$R_1,L_1,C_1$ 三个串联谐振的频率，称之为$f_s$；另一个是$R_1,L_1,C_1$ 与 $C_0$ 并联形成的电路的谐振频率，称之为$f_p$。</p><p>$f_s$频率就是串联电路感抗和容抗抵消，即：$2\pi f_sL_1=\frac{1}{2\pi f_s C_1}$，可解得：</p><script type="math/tex; mode=display">f_s=\frac{1}{2\pi \sqrt{L_1C_1}}</script><p>$f_p$是串联电路感抗大于容抗，整个电路等效于一个电感的时候，和$C_0$发生谐振：</p><script type="math/tex; mode=display">f_p=\frac{1}{2\pi \sqrt{L_1C_1}}\times \sqrt{1+\frac{C_1}{C_0}}=f_s\times \sqrt{1+\frac{C_1}{C_0}}</script><p>可以看出，当频率小于$f_s$时，$L_1$容抗非常小，整个电路的储能由$C_1$主导，因此呈容性（电压领先电流）。在$f_s-f_d$区间内，电路储能由$L_1$主导，因此呈感性（电压滞后电流）。而在频率大于$f_d$后，由于$C_0$支路电抗变小，因此主导支路变成了$C_0$而非$R_1C_1L_1$，再次呈现感性。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240408171430933.png" alt="image-20240408171430933"></p><p>对不同频率呈现出不同的阻值，这就是一个滤波器。可以看出，这个滤波器对$f_s$附近的频率和$&gt;&gt;f_p$的频率通过性较好。</p><h3 id="如何满足相位"><a href="#如何满足相位" class="headerlink" title="如何满足相位"></a>如何满足相位</h3><p>在电子系统-振荡器一节中，我们提到，巴克豪森振荡准则是系统起振的必要不充分条件。那么皮尔斯振荡器是如何满足这个条件的呢？</p><p>观察下图，其可以被改写为另一种形式：</p><p><table><br>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/8601a18b87d6277ff030a1392a381f30e924fc95"></center></td>          <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240408173101903.png"></center></td>    </tr></p><p>其中$R_1$可以被理解为一个很小的等效电阻（当然也可以实际加一个电阻在这里）。</p><ol><li>首先，反向放大器让信号相位旋转了180°。</li><li>$R_1,C_1$让信号相位旋转了90°之间的任意一个值（取决于$R_1, C_1$的大小）。</li><li>如果晶振此时呈现感性（即，振荡频率满足$f_s<f<f_p$），那么加上电容$C_2$其会让相位旋转>90°。那么此时，总有一个频率会让相位一共旋转360°，满足巴克豪森震荡准则。</li><li>但是，如果振荡频率$f<f_s$或是$f>f_p$，晶振都将呈容性，那么相当于串联了一个电容，在加上电容$C_2$，整体相位移动会为0°。处于$f_s$时，晶振呈纯阻性，相位移动位于0-90°。</li></ol><p><strong>因此，一定有一个频率位于$f_s&lt;f&lt;f_p$之间，可让系统震荡。这也就是晶振震荡的频率。</strong></p><p>至此，我们已经讨论了它滤波选频的原理和满足巴克豪森振荡准则的原理。</p><h2 id="如何计算匹配电容"><a href="#如何计算匹配电容" class="headerlink" title="如何计算匹配电容"></a>如何计算匹配电容</h2><p>我们注意到，$C_1$和$C_2$两个电容是会影响相位的，而根据巴克豪森振荡准则，反只有相位为满足 $2n\pi$ 的信号才会起振，因此，$C_1,C_2$两个电容是会轻微影响震荡频率的（之所以是轻微影响，是因为它的影响范围在$f_s$到$f_p$之间，这个范围本就很小）。 </p><p>晶振的供应商会给一个“负载电容” $C_L$，$C_L$的值是晶振本身决定的，当晶振外部等效电容等于$C_L$时，其输出的频率最准确。因此代入皮尔斯震荡电路，可以得到如下公式：</p><script type="math/tex; mode=display">C_L=\frac{C_1\times C_2}{C_1+C_2}+C_s</script><p>其中:</p><ul><li>$C_s$为电路板杂散电容和晶振引脚间电容，经验值取3-5pF.</li></ul><p>如果让$C_1=C_2$的话：</p><script type="math/tex; mode=display">C_1=C_2=2(C_L-C_s)</script><p>至此便可计算$C_1$和$C_2$的值。</p><hr><h1 id="Boot选择器"><a href="#Boot选择器" class="headerlink" title="Boot选择器"></a>Boot选择器</h1><h2 id="三种Boot模式"><a href="#三种Boot模式" class="headerlink" title="三种Boot模式"></a>三种Boot模式</h2><p>stm32有三种boot模式，分别使用boot0 和boot1引脚进行控制</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/20210423125742719.png" alt="img"></p><h3 id="主闪存启动"><a href="#主闪存启动" class="headerlink" title="主闪存启动"></a>主闪存启动</h3><ul><li>启动地址：0x08000000 </li><li>BOOT0: 0;  BOOT1: X</li></ul><p>这是STM32内置的Flash，一般使用JTAG或者SWD模式下载程序时，会写入到该区域内，重启后也直接从这启动程序。基本上都是采用这种模式。</p><h3 id="系统存储器启动"><a href="#系统存储器启动" class="headerlink" title="系统存储器启动"></a>系统存储器启动</h3><ul><li>启动地址：0x1FFF0000</li><li>BOOT0: 1;  BOOT1: 0</li></ul><p>系统存储器是芯片内部一块特定的区域，STM32在出厂时，由ST在这个区域内部预置了一段BootLoader。ST公司的这一段Bootloader中提供了使用串口下载程序的固件。可以通过这个BootLoader将程序下载到系统的Flash中。通过串口下载程序步骤如下：</p><p>电脑通过 USB 转串口线连接 STM32 的 USART1，并打开电脑端的上位机；</p><ul><li>接 BOOT0 为高电平，BOOT1 为低电平（选择 System Memory 启动）；</li><li>复位单片机使其进入 bootloader 模式，此时串口可读取；</li><li>接回 BOOT0 低电平，BOOT1 低电平（选择 Flash启动）；</li><li>复位单片机即可启动用户代码，正常运行；</li></ul><h3 id="SRAM启动"><a href="#SRAM启动" class="headerlink" title="SRAM启动"></a>SRAM启动</h3><ul><li>启动地址： 0x20000000</li><li>BOOT0: 1;  BOOT1: 1</li></ul><p>SRAM没有存储程序的能力，一般用于程序调试。如果程序只进行了小修改，然后完全刷入flash，这个过程非常费时。而SRAM读写速度很快，可以在调试的时候使用。</p><h2 id="Boot选择电路"><a href="#Boot选择电路" class="headerlink" title="Boot选择电路"></a>Boot选择电路</h2><h3 id="手动选择电路"><a href="#手动选择电路" class="headerlink" title="手动选择电路"></a>手动选择电路</h3><p>一般来说，我们用不到SRAM启动。因此通常BOOT1通过一个10K电阻下拉接地。</p><p>当然，也可以用跳线让用户自由选择，如正点原子的STM32战舰v3开发版。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/20210516104650598.png" alt="STM32"></p><p>这便是STM32的启动模式手动选择电路。</p><h3 id="自动下载电路"><a href="#自动下载电路" class="headerlink" title="自动下载电路"></a>自动下载电路</h3><p>STM32可使用CH340配合MCUISP进行ISP烧写，这其中的步骤是到以System Memory模式启动，烧录程序，再切换到Flash模式运行程序。通过CH340上的MODEM通讯引脚，可实现该操作。其原理请参考 <em>CH340X+ISP烧录使用指南</em>。</p><p>CH340与单片机连接如下，同时BOOT1通过一个10K电阻下拉接地。<img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/6rGAjBbclrc6aBCFG2kPU72ix9d3Q5Ru3WdUvelS.jpeg" alt="img"></p><p>配合MCUISP软件，该电路可以实现自动对Boot模式进行选择，然后通过串口下载程序。</p><p><strong>此时CH340的RX需和STM32的USART1的TX（PA9）和USART1的RX（PA10）连接</strong>。</p><h2 id="新版本：flash配置boot（以STM32L4-系列为例）"><a href="#新版本：flash配置boot（以STM32L4-系列为例）" class="headerlink" title="新版本：flash配置boot（以STM32L4+系列为例）"></a>新版本：flash配置boot（以STM32L4+系列为例）</h2><div class="note info flat"><p>参考文档：<a href="https://www.st.com/resource/en/application_note/an4555-getting-started-with-stm32l4-series-and-stm32l4-series-hardware-development-stmicroelectronics.pdf">Getting started with STM32L4 Series and STM32L4+ Series hardware development - Application note</a></p></div><p>ST公司在部分产品上引入了一种全新的boot模式：仅使用一个实体BOOT引脚，配合FLASH内的配置比特来进行boot选择。这样可以实现程序自己切换boot模式。</p><p>首先，引入了如下几个比特：</p><ul><li>Main Flash empty：该比特由系统检测输出，用于判断用户的flash是否经过读写。flash空为1，flash有程序为0；</li><li>nSWBOOT0 FLASH_OPTR：BOOT0引脚由实体引脚值决定还是flash内配置引脚值决定的选择比特。1：实体引脚决定，0：flash内nBOOT0值决定;</li><li>nBOOT0 FLASH_OPTR：BOOT0引脚的flash内配置值。注意，<strong>其为NOT BOOT0（BOOT0取反）</strong>，也就是该bit配置为1相当于实体引脚接0，该比特0相当于实体引脚接1；</li><li>nBOOT1 FLASH_OPTR：BOOT1引脚的flash内配置值。注意，<strong>其为NOT BOOT1（BOOT1取反）</strong>，也就是该bit配置为1相当于实体引脚接0，该比特0相当于实体引脚接1；</li></ul><p>在<code>nSWBOOT0</code>为1时，BOOT0的值由实体引脚决定，此时：</p><ul><li>若<code>Main Flash empty</code>为1（即，flash内没有程序），且BOOT0配置为0（从flash启动），<strong>则不会遵循配置，而会强制从System Memory启动</strong></li><li>其余时候遵循上面三种模式的BOOT表</li></ul><p>官方给出的BOOT选择表如下：（一定要注意 nBOOT 是实体引脚值取反！）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240411235115178.png" alt="image-20240411235115178"></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240411235124165.png" alt="image-20240411235124165"></p><hr><h1 id="复位电路"><a href="#复位电路" class="headerlink" title="复位电路"></a>复位电路</h1><p>STM32复位引脚为<code>NRST</code>，其复位引脚低电平有效，<strong>内部集成上拉电阻，因此无需外部上拉</strong></p><p>官方推荐的复位电路如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240409191441516.png" alt="image-20240409191441516"></p><p>可以看到，外部仅连接一个手动复位的按键和上电自动复位的电容。</p><hr><h1 id="SWD下载电路"><a href="#SWD下载电路" class="headerlink" title="SWD下载电路"></a>SWD下载电路</h1><p>通常某宝买的盗版ST-Link，就是使用的SWD烧写。这种烧写方式只需要4根接线。 分别为<strong>VCC，GND，SWCLK, SWDIO。其中，SWCLK和SWDIO分别对应STM32上PA14和PA13引脚。</strong></p><p>其中：</p><ul><li><strong>SW协议规定，对于SWDIO，必须在电路板上进行上拉（ARM建议100KΩ）</strong>（虽然大部分板子都采用10KΩ上拉）。</li><li>对于SWCLK，芯片内部集成下拉，没有规定一定需要外部下拉。但是部分开发版依旧给了10K电阻的下拉。</li></ul><p>因此，下载电路如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240409190601883.png" alt="image-20240409190601883"></p><p>其中SWDCLK的下拉电阻可有可无，因为芯片内部已集成下拉。</p><h1 id="通信电平转换电路"><a href="#通信电平转换电路" class="headerlink" title="通信电平转换电路"></a>通信电平转换电路</h1><p>由于STM32使用的是3.3V CMOS电平，需要通过UART,I2C等协议与TTL设备（5V）通信时，尝尝需要进行通信电平转换。</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-4月口语题库</title>
      <link href="/posts/51012.html"/>
      <url>/posts/51012.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><h2 id="必考题"><a href="#必考题" class="headerlink" title="必考题"></a>必考题</h2><hr><h3 id="work-or-study"><a href="#work-or-study" class="headerlink" title="work or study"></a>work or study</h3><ol><li>What subjects are you studying?</li><li>Do you like your subject?</li><li>Why did you choose to study that subject?</li><li>Do you think that your subject is popular in your country?</li><li>Do you have any plans for your studies in the next five years?</li><li>What are the benefits of being your age?</li><li>Do you want to change your major?</li><li>Do you prefer to study in the mornings or in the afternoons?</li><li>How much time do you spend on your studies each week?</li><li>Are you looking forward to working?</li><li>What technology do you use when you study?</li><li>What changes would you like to see in your school?</li><li>What work do you do?</li><li>Why did you choose to do that type of work (or that job)?</li><li>Do you like your job?</li><li>What requirements did you need to meet to get your current job?</li><li>Do you have any plans for your work in the next five years?</li><li>What do you think is the most important at the moment?</li><li>Do you want to change to another job?</li><li>Do you miss being a student?</li><li>What technology do you use at work?</li><li>Who helps you the most? And how?</li><li>Do you like chatting with friends?</li></ol><hr><h3 id="hometown"><a href="#hometown" class="headerlink" title="hometown"></a>hometown</h3><ol><li>Where is your hometown?</li><li>Is that a big city or a small place?</li><li>Please describe your hometown a little.</li><li>How long have you been living there?</li><li>Do you think you will continue living there for a long time?</li><li>Do you like your hometown?</li><li>Do you like living there?</li><li>What do you like (most) about your hometown?</li><li>Is there anything you dislike about it?</li><li>What’s your hometown famous for?</li><li>Did you learn about the history of your hometown at school?</li><li>Are there many young people in your hometown?</li><li>Is your hometown a good place for young people to pursue their careers?</li></ol><hr><h3 id="Home-amp-Accommodation"><a href="#Home-amp-Accommodation" class="headerlink" title="Home &amp; Accommodation"></a>Home &amp; Accommodation</h3><ol><li>What kind of house or apartment do you want to live in in the future?</li><li>Are the transport facilities to your home very good?</li><li>Do you prefer living in a house or an apartment?</li><li>Please describe the room you live in.</li><li>What part of your home do you like the most?</li><li>How long have you lived there?</li><li>Do you plan to live there for a long time?</li><li>What’s the difference between where you are living now and where you have lived in the past?</li><li>Can you describe the place where you live?</li><li>What room does your family spend most of the time in?</li><li>What’s your favorite room in your apartment or house?</li><li>What makes you feel pleasant in your home?</li><li>Do you think it is important to live in a comfortable environment?</li><li>Do you live in an apartment or a house?</li><li>Who do you live with?</li><li>What do you usually do in your apartment?</li><li>What kinds of accommodation do you live in?</li></ol><hr><h2 id="新题"><a href="#新题" class="headerlink" title="新题"></a>新题</h2><ol><li><strong>Is there an advertisement that made an impression on you when you were a child?</strong></li><li><strong>Do you see a lot of advertising on trains or other transport?</strong></li><li><strong>Do you like advertisements?</strong></li><li><strong>What kind of advertising do you like?</strong></li><li><strong>Do you like to eat cakes or other sweet foods?</strong></li><li><strong>Did you like to eat cakes as a child?</strong></li><li><strong>Can you make cakes?</strong></li><li><strong>Are there any traditional Chinese cakes?</strong></li><li><strong>Do you like to have some desserts after meals?</strong></li><li>Do you collect things?</li><li>Are there any things you keep from childhood?</li><li>Would you keep old things for a long time? Why?</li><li>Where do you usually keep things you need?</li><li><strong>What’s your favorite colour?</strong></li><li><strong>What’s the colour you dislike? Why?</strong></li><li><strong>What colours do your friends like most?</strong></li><li><strong>What colour makes you uncomfortable in your room?</strong></li><li><strong>Is the city where you live crowded?</strong></li><li><strong>Is there a crowded place near where you live?</strong></li><li><strong>Do you like crowded places?</strong></li><li><strong>Do most people like crowded places?</strong></li><li><strong>When was the last time you were in a crowded place?</strong></li><li><strong>Do you often feel bored?</strong></li><li><strong>When would you feel bored?</strong></li><li><strong>What do you do when you feel bored?</strong></li><li><strong>Do you think childhood is boring or adulthood is boring?</strong></li><li><strong>Are you good at memorising things?</strong></li><li><strong>Have you ever forgotten something important?</strong></li><li><strong>What do you need to remember in your daily life?</strong></li><li><strong>How do you remember important things?</strong></li><li><strong>Do you prefer to save money or spend money?</strong></li><li><strong>How do you save money?</strong></li><li><strong>What do you think about payment apps or mobile payments?</strong></li><li><strong>Do you use a credit card to buy things?</strong></li><li><strong>Do you think cash will still be popular in the future?</strong></li><li><strong>Who is your favourite celebrity in your country?</strong></li><li><strong>What kind of famous people do you often see in the news?</strong></li><li><strong>Do you pay attention to famous people in the news?</strong></li><li><strong>Do you believe that the news about famous people in the media is true?</strong></li><li><strong>Would you like to be a famous person in the news?</strong></li><li><strong>Do you like singing? Why?</strong></li><li><strong>Have you ever learnt how to sing?</strong></li><li><strong>Who do you want to sing for?</strong></li><li><strong>Do you think singing can bring happiness to people?</strong></li><li><strong>When did you start using social media?</strong></li><li><strong>Do you think you spend too much time on social media?</strong></li><li><strong>Do your friends use social media?</strong></li><li><strong>What do people often do on social media?</strong></li><li><strong>Do you often wear sunglasses?</strong></li><li><strong>Do you spend a lot of money on sunglasses?</strong></li><li><strong>Do you give sunglasses as gifts?</strong></li><li><strong>Have you ever lost your sunglasses?</strong></li><li><strong>Do you play video games?</strong></li><li><strong>Would you watch others play video games?</strong></li><li><strong>Do you think people spend too much time playing video games?</strong></li><li><strong>Do you prefer playing video games alone or with others?</strong></li></ol><h2 id="老题"><a href="#老题" class="headerlink" title="老题"></a>老题</h2><ol><li>What kind of house or apartment do you want to live in in the future?</li><li>Are the transport facilities to your home very good?</li><li>Do you prefer living in a house or an apartment?</li><li>Please describe the room you live in.</li><li>What part of your home do you like the most?</li><li>How long have you lived there?</li><li>Do you plan to live there for a long time?</li><li>What’s the difference between where you are living now and where you have lived in the past?</li><li>Can you describe the place where you live?</li><li>What room does your family spend most of the time in?</li><li>What’s your favorite room in your apartment or house?</li><li>What makes you feel pleasant in your home?</li><li>Do you think it is important to live in a comfortable environment?</li><li>Do you live in an apartment or a house?</li><li>Who do you live with?</li><li>What do you usually do in your apartment?</li><li>What kinds of accommodation do you live in?</li><li>Do you like the area that you live in?</li><li>Where do you like to go in that area?</li><li>Do you know any famous people in your area?</li><li>What are some changes in the area recently?</li><li>Do you know any of your neighbours?</li><li>What do you usually chat about with friends?</li><li>Do you prefer to chat with a group of people or with only one friend?</li><li>Do you prefer to communicate face-to-face or via social media?</li><li>Do you argue with friends?</li><li><strong>What kind of clothes do you like to wear?</strong></li><li><strong>Do you prefer to wear comfortable and casual clothes or smart clothes?</strong></li><li><strong>Do you like wearing T-shirts?</strong></li><li><strong>Do you spend a lot of time choosing clothes?</strong></li><li>What films do you like?</li><li>Did you often watch films when you were a child?</li><li>Did you ever go to the cinema alone as a child?</li><li>Do you often go to the cinema with your friends?</li><li>Do you think going to the cinema is a good way to spend time with friends?</li><li>Is fishing popular in your country?</li><li>Do you like eating fish?</li><li>Have you ever been to a place where there are lots of fish around you?</li><li>Have you seen any movies with lots of fish?</li><li>How do you like geography?</li><li>Do you think geography is useful?</li><li>Have you ever learned geography?</li><li>Do you want to be a geography teacher?</li><li>Will you learn more about the geography of other countries?</li><li>Have you ever sent handmade gifts to others?</li><li>Have you ever received a great gift?</li><li>What do you consider when choosing a gift?</li><li>Do you think you are good at choosing gifts?</li><li>What gift have you received recently?</li><li>Do you usually help people around you?</li><li>How do you help people around you, such as neighbours, family and friends?</li><li>Do your parents teach you how to help others?</li><li>Did your parents help you a lot when you were young?</li><li>What have you done to help the elderly?</li><li><strong>Do you often use maps?</strong></li><li><strong>Do you use paper maps?</strong></li><li><strong>How often do you use maps on your phone?</strong></li><li><strong>Do you have maps at home?</strong></li><li><strong>When was the last time you used a map?</strong></li><li><strong>Have you ever learned to play a musical instrument?</strong></li><li><strong>What musical instruments do you enjoy listening to the most?</strong></li><li><strong>Do you think children should learn to play an instrument at school?</strong></li><li><strong>Do you think music education is important to children?</strong></li><li><strong>Do a lot of people like music?</strong></li><li><strong>Do schools in your country have music lessons?</strong></li><li>Do you like to stay in a place with a lot of noise?</li><li>What kinds of noises are there in the area where you live?</li><li>Do you want to move to a quieter place?</li><li>Do you think there is too much noise in today’s world?</li><li>Is making noise one of people’s rights?</li><li>Are robots important?</li><li>Would robots affect people’s lives?</li><li>Have you ever watched a movie about robots?</li><li>Should we let a robot drive for us for long journeys?</li><li>What can robots do for you at home?</li><li>Do you go running a lot?</li><li>Where do you usually go running?</li><li>When was the last time you went running?</li><li>What do you think of running as a sport?</li><li>Do people like tea and coffee nowadays?</li><li>Do you prefer to use tea or coffee to serve your guests?</li><li>When was the last time you had a cup of coffee or tea?</li><li>Do you usually buy your coffee in a coffee shop?</li><li>Do you enjoy inviting friends to your home for tea or coffee?</li><li>How do you go to work/school?</li><li>What’s the most popular means of transportation in your hometown?</li><li>How far is it from your home to work/school?</li><li>Do you think people will drive more in the future?</li><li><strong>Do you like travelling?</strong></li><li><strong>How often do you go travelling?</strong></li><li><strong>Where do you usually travel?</strong></li><li><strong>How do you feel when you are travelling?</strong></li></ol><h1 id="Part2-amp-Part3"><a href="#Part2-amp-Part3" class="headerlink" title="Part2&amp;Part3"></a>Part2&amp;Part3</h1><h2 id="帮助他人"><a href="#帮助他人" class="headerlink" title="帮助他人"></a>帮助他人</h2><h3 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a time when you helped someone You should say:</p><ul><li><p>Where you helped him/her Why you helped</p></li><li><p>How you helped</p></li><li><p>And explain how you felt about it</p></li></ul><h3 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h3><ol><li><p>Should people be very kind when they help others?</p></li><li><p>Should children be taught to be kind to others?</p></li><li><p>Should parents help their kids with their homework?</p></li><li><p>What kind of advice should parents give to their children?</p></li><li><p>Should parents give children advice? Why?</p></li><li><p>Can kids provide any help to parents?</p></li></ol><hr><h2 id="不喜欢做的工作"><a href="#不喜欢做的工作" class="headerlink" title="不喜欢做的工作"></a>不喜欢做的工作</h2><h3 id="Part2-1"><a href="#Part2-1" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a job that youwould not like to do in the future</p><ul><li><p>You should say: What it is</p></li><li><p>How you know about the job Whether the job is difficult or not</p></li><li><p>And explain why you would not like to do it</p></li></ul><h3 id="Part3-1"><a href="#Part3-1" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What kind of jobs do young Chinese people like to do?</li><li>Do youn,g Chinese  people prefer to choose an interesting job or a job  with a high salary?</li><li>Do you think it is easier to get a job now than in the past?</li><li>Is it important to be successful in a job?</li><li>Do you think Al will take over many jobs?</li><li>Can Al improve people’s lives? If so, how?</li></ol><hr><h2 id="不寻常假期"><a href="#不寻常假期" class="headerlink" title="不寻常假期"></a>不寻常假期</h2><h3 id="Part2-2"><a href="#Part2-2" class="headerlink" title="Part2"></a>Part2</h3><p>Describe an unusual holiday/vacation you had You should say:</p><ul><li><p>When and where you went Who you went with</p></li><li><p>What you did there</p></li><li><p>And explain why it was unusual</p></li></ul><h3 id="Part3-2"><a href="#Part3-2" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Do you think people in your country have long enough holidays?</li><li>Which holidays are popular in your country?</li><li>Are there any popular places for holidays in your country?</li><li>What are the differences between old and young people when spending their holidays?</li><li>Do you think having holidays help people learn other countries’ cultures?</li><li>Why do some people dislike holidays?</li></ol><hr><h2 id="超有共鸣的电影"><a href="#超有共鸣的电影" class="headerlink" title="超有共鸣的电影"></a>超有共鸣的电影</h2><h3 id="Pat2"><a href="#Pat2" class="headerlink" title="Pat2"></a>Pat2</h3><p>Describe a movie/film that youfelt strongly about You should say:</p><ul><li><p>What it is about When you watched it Where you watched it</p></li><li><p>And explain why you felt strongly about it</p></li></ul><h3 id="Pat3"><a href="#Pat3" class="headerlink" title="Pat3"></a>Pat3</h3><ol><li>Do most people prefer to watch movies at home or in a cinema? Why?</li><li>What are the advantages of going to the cinema with friends?</li><li>Is going to the cinema still popular?</li><li>What kind of movies do you think need to be seen in the cinema to be fully appreciated?</li><li>What can cinemas do to attract more audiences?</li><li>Do you think people can learn new cultures through movies?</li></ol><hr><h2 id="给力队友"><a href="#给力队友" class="headerlink" title="给力队友"></a>给力队友</h2><h3 id="Part2-3"><a href="#Part2-3" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a time when someone who did quite well in a team (e.g. schoolwork or a community)</p><ul><li><p>You should say: Who this person is</p></li><li><p>When you worked together What he/she did in the team</p></li><li><p>And explain why you think he/she was a great team player</p></li></ul><h3 id="Part3-3"><a href="#Part3-3" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What qualities should a leader have?</li><li>What should people do without a good team leader?</li><li>Does a team’s best player make a good leader?</li><li>Why do some people dislike teamwork?</li><li>Do you think young people are good team players?</li><li>What are the advantages of working as part of a team?</li></ol><hr><h2 id="家中重要物品"><a href="#家中重要物品" class="headerlink" title="家中重要物品"></a>家中重要物品</h2><h3 id="Part2-4"><a href="#Part2-4" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a useful object in your home that you cannot live without</p><ul><li><p>You should say: What it is</p></li><li><p>How long you have had it What you can do with it How often you use it</p></li><li><p>And explain why you cannot live without it</p></li></ul><h3 id="Part3-4"><a href="#Part3-4" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What equipment do you find difficult to use?</li><li>What can you do with a laptop?</li><li>What are the benefits of using technology in the workplace?</li><li>Why do some people in the workplace dislike technology?</li><li>Why do people buy a lot of household appliances?</li><li>What do people often do with electronic devices?</li></ol><hr><h2 id="捡到失物"><a href="#捡到失物" class="headerlink" title="捡到失物"></a>捡到失物</h2><h3 id="Part2-5"><a href="#Part2-5" class="headerlink" title="Part2"></a>Part2</h3><p>Please describe a time when you picked up an item that someone else lost</p><ul><li><p>You should say: What the item was</p></li><li><p>When and where you found it What you did after finding it</p></li><li><p>And explain how you felt about the experience</p></li></ul><h3 id="Part3-5"><a href="#Part3-5" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What kind of people tend to lose things more often than others?</li><li>What kind of things do people often lose?</li><li>Why do some people find lost things easier than others?</li><li>What do you think are the reasons why some people pick up lost things and don’t give them back?</li><li>Should parents teach their children to return things lost by others?</li><li>Why do some people enjoy collecting antiques or second- hand items?</li></ol><hr><h2 id="改善的公共设施"><a href="#改善的公共设施" class="headerlink" title="改善的公共设施"></a>改善的公共设施</h2><h3 id="Part2-6"><a href="#Part2-6" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a public facility (e.g. a museum, a library) that has been renovated and improved</p><ul><li><p>You should say: What the facility is</p></li><li><p>When it was renovated and improved</p></li><li><p>What has been renovated and improved And explain how you feel about it</p></li></ul><h3 id="Part3-6"><a href="#Part3-6" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What are the benefits of public facilities?</li><li>Why are some public transport methods popular, such as the subway?</li><li>Why are some public transport methods unpopular?</li><li>What kind of transport do young people and old people prefer?</li><li>Do you think people would feel happier when they are in a park or a coffee shop? Why?</li><li>Is a public park necessary in every area? Why?</li></ol><hr><h2 id="能说会道的人"><a href="#能说会道的人" class="headerlink" title="能说会道的人"></a>能说会道的人</h2><h3 id="Part2-7"><a href="#Part2-7" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a person you know who likes to talk a lot You should say:</p><ul><li><p>Who this person is</p></li><li><p>How you knew this person What he/she usually talks about</p></li><li><p>And explain how you felt about him/her</p></li></ul><h3 id="Part3-7"><a href="#Part3-7" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What communication skills does a talkative person have?</li><li>Is it good to be talkative?</li><li>How should parents encourage their children to talk more?</li><li>How should people encourage children to express themselves when being asked questions that they are afraid to answer?</li><li>On what occasion do you think a child should talk less than usual?</li><li>What jobs need employees to be talkative?</li></ol><hr><h2 id="年少学艺"><a href="#年少学艺" class="headerlink" title="年少学艺"></a>年少学艺</h2><h3 id="Part2-8"><a href="#Part2-8" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a useful skill that youlearned as a teenager</p><ul><li><p>You should say: What the skill is</p></li><li><p>When and how you learned it Who you learned it from Why you learned it</p></li><li><p>And explain how you felt about learning it</p></li></ul><h3 id="Part3-8"><a href="#Part3-8" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Where do children learn skills in your country?</li><li>What are the differences between learning skills on your own and from others?</li><li>What important skills should a child learn?</li><li>What skills do you think teenagers should have?</li><li>Who should teach teenagers skills?</li><li>What are the differences between children learning skills and adults learning skills?</li></ol><hr><h2 id="想去放松之地"><a href="#想去放松之地" class="headerlink" title="想去放松之地"></a>想去放松之地</h2><h3 id="Part2-9"><a href="#Part2-9" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a place you would like to go to relax You should say:</p><ul><li><p>Where it is</p></li><li><p>When you would like to go there What you would do there</p></li><li><p>And explain why you would like to go to this place to relax</p></li></ul><h3 id="Part3-9"><a href="#Part3-9" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Do people have enough places to relax in your country?</li><li>What do people usually do when they are relaxed?</li><li>Is physical activity good for relaxation?</li><li>Do you think that spending time in front of a screen helps people relax?</li><li>Do people have to spend a lot of money to relax?</li><li>Do people nowadays have more ways to relax than in the past?</li></ol><hr><h2 id="小学活动"><a href="#小学活动" class="headerlink" title="小学活动"></a>小学活动</h2><h3 id="Part2-10"><a href="#Part2-10" class="headerlink" title="Part2"></a>Part2</h3><p>Describe an interesting activity that youremember enjoying most in your primary school</p><ul><li><p>You should say:</p></li><li><p>What the activity was</p></li><li><p>How often you did the activity Who you did it with</p></li><li><p>And explain why you enjoyed doing it</p></li></ul><h3 id="Part3-10"><a href="#Part3-10" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What activities do children often do in your country?</li><li>At what time do children often have activities?</li><li>What are the differences between activities at home and at school?</li><li>Why do some people like to participate in activities?</li><li>What activities do people do in their free time?</li><li>Does technology affect children’s activities? If so, how?</li></ol><hr><h2 id="一次非常忙碌的经历"><a href="#一次非常忙碌的经历" class="headerlink" title="一次非常忙碌的经历"></a>一次非常忙碌的经历</h2><h3 id="Part2-11"><a href="#Part2-11" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a time you were very busy You should say:</p><ul><li><p>When it happened Where you were What you did</p></li><li><p>And explain why you were busy</p></li></ul><h3 id="Part3-11"><a href="#Part3-11" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Are you often busy?</li><li>What are the advantages and disadvantages when people keep busy?</li><li>Do you think children should learn through playing games or under pressure?</li><li>What kind of pressure people may experience at work?</li><li>How does technology help with time management?</li><li>Does technology distract people?</li></ol><hr><h2 id="长久目标"><a href="#长久目标" class="headerlink" title="长久目标"></a>长久目标</h2><h3 id="Part2-12"><a href="#Part2-12" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a long- term goal you would like to achieve</p><ul><li><p>You should say:</p></li><li><p>How long you have had this goal What the goal is</p></li><li><p>How you will achieve it</p></li><li><p>And explain why you set this goal</p></li></ul><h3 id="Part3-12"><a href="#Part3-12" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What goals should a society have?</li><li>Do people need to have goals?</li><li>What goals do people at your age have?</li><li>Is it necessary to give advice to children?</li><li>What goals do young people usually have?</li><li>What should people do to achieve their goals?</li></ol><hr><h2 id="制服"><a href="#制服" class="headerlink" title="制服"></a>制服</h2><h3 id="Part2-13"><a href="#Part2-13" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a uniform you wear (e.g. at school, at work)</p><ul><li><p>You should say:</p></li><li><p>Where you wear the uniform How long you need to wear it What it looks like</p></li><li><p>Who bought it for you</p></li><li><p>And explain how you feel about it</p></li></ul><h3 id="Part3-13"><a href="#Part3-13" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Why should students wear uniforms?</li><li>Why should people at work wear uniforms?</li><li>What are the advantages and disadvantages of wearing a uniform?</li><li>Can people tell a person’s personality by his or her clothes?</li><li>On what occasion sho uld people wear uniforms?</li><li>Should companies ask for employees’opinions about the design of uniforms?</li></ol><hr><h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><h3 id="Part2-14"><a href="#Part2-14" class="headerlink" title="Part2"></a>Part2</h3><p>Describe an occasion when you used a map (e.g. a paper map, an electronic map) that was useful You should say:</p><ul><li><p>When and where you used the map What it was like</p></li><li><p>How useful it was Why you used it</p></li><li><p>And explain how you felt about the experience</p></li></ul><h3 id="Part3-14"><a href="#Part3-14" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What do people usually do when they get lost?</li><li>What are the differences between paper and digital maps?</li><li>What do you think of in- car GPS navigation systems?</li><li>What do people often do with a map?</li><li>Why do most people prefer to use a paper map?</li><li>How does learning to read a map help you learn more about your country?</li></ol><hr><h2 id="对学习工作有助的事情"><a href="#对学习工作有助的事情" class="headerlink" title="对学习工作有助的事情"></a>对学习工作有助的事情</h2><h3 id="Part2-15"><a href="#Part2-15" class="headerlink" title="Part2"></a>Part2</h3><p>Describe something you do to help you study or work</p><ul><li><p>You should say: What it is</p></li><li><p>How you learn it When you do it</p></li><li><p>And how you feel about the method</p></li></ul><h3 id="Part3-15"><a href="#Part3-15" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Do you think everyone’s routine is different?</li><li>Which jobs need a morning routine?</li><li>Is a daily routine important?</li><li>How do people organize their routines after getting up in the morning and after work?</li><li>Do you think children need to have a routine too?</li><li>Do you think routine is important for companies?</li></ol><hr><h2 id="好客之人"><a href="#好客之人" class="headerlink" title="好客之人"></a>好客之人</h2><h3 id="Part2-16"><a href="#Part2-16" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a person who is good at making people feel welcome in his/her home</p><ul><li><p>You should say: Who this person is</p></li><li><p>How you knew him/her</p></li><li><p>How he/she makes you feel welcome</p></li><li><p>And explain why you think he/she is good at making people feel welcome</p></li></ul><h3 id="Part3-16"><a href="#Part3-16" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Do people in your country often invite others to their homes? Why?</li><li>What do you think of serving food to visitors?</li><li>What kind of people do you think are more likely to invite others to their homes?</li><li>Who are more likely to invite others to their homes, people in the countryside or people in the city?</li><li>Are tourist attractions in the countryside more popular than those in the cities?</li><li>What facilities are there in the tourist attractions in your country?</li></ol><hr><h2 id="和老人的有趣谈话"><a href="#和老人的有趣谈话" class="headerlink" title="和老人的有趣谈话"></a>和老人的有趣谈话</h2><h3 id="Part2-17"><a href="#Part2-17" class="headerlink" title="Part2"></a>Part2</h3><p>Describe an interesting conversation you had with a very old person</p><ul><li><p>You should say: Who this person is</p></li><li><p>When and where you had the conversation What you talked about</p></li><li><p>And explain why you think it was interesting</p></li></ul><h3 id="Part3-17"><a href="#Part3-17" class="headerlink" title="Part3"></a>Part3</h3><ol><li>How do people have a conversation with an elderly person?</li><li>What can young people learn from old people?</li><li>Do you think old people can work better than young people?</li><li>What are the advantages of having people of different ages living in the same house?</li><li>Has old people’s life quality improved when compared to the past?</li><li>Do old people share the same interest with young people?</li></ol><hr><h2 id="户外活动"><a href="#户外活动" class="headerlink" title="户外活动"></a>户外活动</h2><h3 id="Part2-18"><a href="#Part2-18" class="headerlink" title="Part2"></a>Part2</h3><p>Describe an outdoor activity you did You should say:</p><ul><li><p>What the activity was When and where you did it Who you did it with</p></li><li><p>And explain why you enjoyed it</p></li></ul><h3 id="Part3-18"><a href="#Part3-18" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Is having outdoor activities important to people?</li><li>Do people go outdoors more or less now than in the past?</li><li>What can people do outdoors besides exercising?</li><li>When do people usually go outdoors to get close to nature?</li><li>What can people do to get close to nature?</li><li>Do people like doing outdoor activities in the winter time?</li></ol><hr><h2 id="速战速决的事"><a href="#速战速决的事" class="headerlink" title="速战速决的事"></a>速战速决的事</h2><h3 id="Part2-19"><a href="#Part2-19" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a time you had to finish something quickly</p><ul><li><p>You should say: What it was</p></li><li><p>When it happened How you finished it</p></li><li><p>Why you had to finish it quickly And explain how you felt about it</p></li></ul><h3 id="Part3-19"><a href="#Part3-19" class="headerlink" title="Part3"></a>Part3</h3><ol><li>On what occasions do people have to do things in a hurry?</li><li>Why do some people spend a long time on having a meal?</li><li>Would people feel more satisfied if they finished doing something quickly?</li><li>What kinds of jobs need to be done quickly?</li><li>What are some examples of work that needs to be done quickly?</li><li>What might make some people more productive than others in completing tasks?</li></ol><hr><h2 id="投诉"><a href="#投诉" class="headerlink" title="投诉"></a>投诉</h2><h3 id="Part2-20"><a href="#Part2-20" class="headerlink" title="Part2"></a>Part2</h3><p>Describe an occasion when you heard someone complaining about something in a restaurant/store or other business places</p><ul><li><p>You should say:</p></li><li><p>When and where it happened What he/she complained about What the result was</p></li><li><p>And explain how you felt about the experience</p></li></ul><h3 id="Part3-20"><a href="#Part3-20" class="headerlink" title="Part3"></a>Part3</h3><ol><li>How do companies train their staff to deal with complaints?</li><li>What do people usually complain about?</li><li>How do most people complain, in writing or by other methods?</li><li>How do people often respond to poor customer service?</li><li>How would you react if you received a poor service at a restaurant?</li><li>Who are more likely to make complaints, older people or younger people?</li></ol><hr><h2 id="延期旅行"><a href="#延期旅行" class="headerlink" title="延期旅行"></a>延期旅行</h2><h3 id="Part2-21"><a href="#Part2-21" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a travel you were looking forward to but was delayed</p><ul><li><p>You should say:</p></li><li><p>Where you planned to travel to Why you were looking forward to it Why it had to be delayed</p></li><li><p>And explain how you felt about the experience</p></li></ul><h3 id="Part3-21"><a href="#Part3-21" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What are the main means of transport in your country?</li><li>What can the government do to improve transport in your country?</li><li>Do you think travelling was better in the past than it is now?</li><li>Do you think that tourist attractions help people learn about new cultures?</li><li>What difficulties do people often face when travelling?</li><li>Do you think technology makes travelling more difficult?</li></ol><hr><h2 id="噪音"><a href="#噪音" class="headerlink" title="噪音"></a>噪音</h2><h3 id="Part2-22"><a href="#Part2-22" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a time when some people near you made a lot of noise</p><ul><li><p>You should say:</p></li><li><p>When and where it happened Who made the noise</p></li><li><p>How you reacted to the noise</p></li><li><p>And explain how you felt about the noise</p></li></ul><h3 id="Part3-22"><a href="#Part3-22" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What kinds of places should be noise- free?</li><li>On what occasions do people need to be quiet?</li><li>Can people bring children to these noise- free places?</li><li>Why can’t people make noise in places like libraries and museums?</li><li>What public morals should people follow in your country?</li><li>Do you think we should allow children to make noise in public places?</li></ol><hr><h2 id="街市购物"><a href="#街市购物" class="headerlink" title="街市购物"></a>街市购物</h2><h3 id="Part2-23"><a href="#Part2-23" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a time you bought something from a street (or outdoor) market</p><ul><li><p>You should say: When it was</p></li><li><p>Where the market was What you bought</p></li><li><p>And how you felt about it</p></li></ul><h3 id="Part3-23"><a href="#Part3-23" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What kinds of markets are there in China?</li><li>Do you think small markets will disappear in the future?</li><li>Have people1s shopping habits changed in recent years?</li><li>What are the differences between shopping in street markets and big shopping malls?</li><li>Do you think the goods sold at discount stores do not have good values or qualities?</li><li>Why do some people like to buy expensive goods?</li></ol><hr><h2 id="成功商人"><a href="#成功商人" class="headerlink" title="成功商人"></a>成功商人</h2><h3 id="Part2-24"><a href="#Part2-24" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a successful businessperson you know (e.g. running a family business)</p><ul><li><p>You should say: Who this person is</p></li><li><p>How you knew him/her What business he/she does</p></li><li><p>And explain why he/she is successful</p></li></ul><h3 id="Part3-24"><a href="#Part3-24" class="headerlink" title="Part3"></a>Part3</h3><ol><li>What factors lead to success?</li><li>What do people need to sacrifice for success?</li><li>Which is more likely to be successful, family businesses or large corporations?</li><li>Is it easy for a business to be successful without affecting the environment</li><li>Can you provide some examples of family businesses in your country?</li><li>What qualities should be considered when recruiting employees?</li></ol><hr><h2 id="城里的公园或花园"><a href="#城里的公园或花园" class="headerlink" title="城里的公园或花园"></a>城里的公园或花园</h2><h3 id="Part2-25"><a href="#Part2-25" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a park or a garden in your city You should say:</p><ul><li><p>How often you go there Where it is</p></li><li><p>Who you often go there with What it is like</p></li><li><p>And explain why you like to visit it</p></li></ul><h3 id="Part3-25"><a href="#Part3-25" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Do young people like to go to parks?</li><li>What do old people like to do in parks?</li><li>What benefits can parks bring to a city?</li><li>What are the benefits of going to the park for young people and old people?</li><li>Why do some people like planting flowers?</li><li>Would you say people should help maintain public parks and gardens?</li></ol><hr><h2 id="等待美好事情"><a href="#等待美好事情" class="headerlink" title="等待美好事情"></a>等待美好事情</h2><h3 id="Part2-26"><a href="#Part2-26" class="headerlink" title="Part2"></a>Part2</h3><p>Describe an occasion when you waited a long time for a nice thing</p><ul><li><p>You should say: When it happened</p></li><li><p>What the nice thing was How long you waited</p></li><li><p>Why you waited for a long time</p></li><li><p>And explain how you felt about the experience</p></li></ul><h3 id="Part3-26"><a href="#Part3-26" class="headerlink" title="Part3"></a>Part3</h3><ol><li>On what occasions do people have to wait for a long time?</li><li>What do people do while waiting?</li><li>Are most people patient while waiting?</li><li>Do you like to wait for a long time? Why?</li><li>Why do most children have difficulties waiting for a long time?</li><li>Do people queue consciously while waiting for the subway train?</li></ol><hr><h3 id="电脑罢工"><a href="#电脑罢工" class="headerlink" title="电脑罢工"></a>电脑罢工</h3><h3 id="Part2-27"><a href="#Part2-27" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a time when you had a problem with using the computer</p><ul><li><p>You should say: When it happened Where it happened</p></li><li><p>What the problem was</p></li><li><p>And explain how you solved the problem at last</p></li></ul><h3 id="Part3-27"><a href="#Part3-27" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Why do people often have problems when using new products?</li><li>How do people use digital devices to help them with their studies?</li><li>Do people spend too much time looking at digital screens? Why?</li><li>Do you think that parents should limit the time that their children spend using the mobile phones?</li><li>What do people do with mobile phones?</li><li>What do you think of people who are addicted to playing computers?</li></ol><hr><h2 id="感觉累的活动"><a href="#感觉累的活动" class="headerlink" title="感觉累的活动"></a>感觉累的活动</h2><h3 id="Part2-28"><a href="#Part2-28" class="headerlink" title="Part2"></a>Part2</h3><p>Describe an activity that made you feel tired You should say:</p><ul><li><p>When and where it took place Why you took part in it</p></li><li><p>What the activity was</p></li><li><p>And explain why it made you feel tired</p></li></ul><h3 id="Part3-28"><a href="#Part3-28" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Does studying and learning make people tired today?</li><li>When do people usually feel tired?</li><li>What do you think about striving for learning and striving for sports?</li><li>Do people have fewer holidays now than in the past?</li><li>What are the differences between feeling tired after studying and after exercising?</li><li>How can people solve the problem of old people easily getting tired?</li></ol><hr><h2 id="感兴趣的科学领域"><a href="#感兴趣的科学领域" class="headerlink" title="感兴趣的科学领域"></a>感兴趣的科学领域</h2><h3 id="Part2-29"><a href="#Part2-29" class="headerlink" title="Part2"></a>Part2</h3><p>Describe an area of science (biology, robotics, etc.) that youareinterested in and would like to learn more about</p><ul><li><p>You should say: Which area it is</p></li><li><p>When and where you came to know this area How you get information about this area</p></li><li><p>And explain why you are interested in this area</p></li></ul><h3 id="Part3-29"><a href="#Part3-29" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Why do some children not like learning science at school?</li><li>Is it important to study science at school?</li><li>Which science subject is the most important for children to learn?</li><li><p>Should people continue to study science after graduating from school?</p></li><li><p>How do you get to know about scientific news?</p></li><li>Should scientists explain the research process to the public?</li></ol><hr><h2 id="好的人生变化"><a href="#好的人生变化" class="headerlink" title="好的人生变化"></a>好的人生变化</h2><h3 id="Part2-30"><a href="#Part2-30" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a time that something changed your life in good ways</p><ul><li><p>You should say:</p></li><li><p>When and where it happened What happened</p></li><li><p>How you felt about it</p></li><li><p>And explain how it changed your life in good ways</p></li></ul><h3 id="Part3-30"><a href="#Part3-30" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Do you like new things or changes in life?</li><li>Why do some people quit and change jobs?</li><li>How do you adapt to changes in life?</li><li>Who can adapt better to changes, children or adults?</li><li>When things like getting married or moving home happen, what kinds of things would you consider?</li><li>What are the disadvantages when people keep making changes?</li></ol><hr><h2 id="好建议"><a href="#好建议" class="headerlink" title="好建议"></a>好建议</h2><h3 id="Part2-31"><a href="#Part2-31" class="headerlink" title="Part2"></a>Part2</h3><p>Describe a piece of good advice that yougave to someone</p><ul><li><p>You should say:</p></li><li><p>Who you gave the advice to What the advice was</p></li><li><p>Why you gave the advice</p></li><li><p>And explain how he/she followed your advice</p></li></ul><h3 id="Part3-31"><a href="#Part3-31" class="headerlink" title="Part3"></a>Part3</h3><ol><li>Do you think parents should give their children advice?</li><li>Should teachers give students advice?</li><li>Do you think it is necessary for us to listen to friends’advice?</li><li>How do people give young people and old people advice?</li><li>Who are more willing to listen to advice? And who are less willing?</li><li>Have you ever received any advice from professional people, like a doctor, a lawyer or a teacher?</li></ol><hr><h2 id="聚会"><a href="#聚会" class="headerlink" title="聚会"></a>聚会</h2><h3 id="Par2"><a href="#Par2" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a party that you enjoyed You should say:</p><ul><li><p>When and where the party was held Who attended the party</p></li><li><p>What kind of party it was What you did in the party</p></li><li><p>And explain why you enjoyed this party</p></li></ul><h3 id="Part2-32"><a href="#Part2-32" class="headerlink" title="Part2"></a>Part2</h3><ol><li>Why do people like parties?</li><li>Why do some people not like going to parties?</li><li>Do you think those who tend to stay at home are less healthy than those who often attend parties?</li><li>Do you think music and dancing are a must at a party?</li><li>What would you do if you were disturbed by a neighbour’s party?</li><li>What are the differences between holding a party at home and in a public place?</li></ol><hr><h2 id="克服困难而自豪"><a href="#克服困难而自豪" class="headerlink" title="克服困难而自豪"></a>克服困难而自豪</h2><h3 id="Par2-1"><a href="#Par2-1" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a difficult task that youcompleted at work/study that youfelt proud of</p><ul><li><p>You should say: What the task was</p></li><li><p>How you completed it Why the task was diff icult</p></li><li><p>Why you were proud of the completion of the task</p></li></ul><h3 id="Part2-33"><a href="#Part2-33" class="headerlink" title="Part2"></a>Part2</h3><ol><li>What are the things that make people feel proud?</li><li>Do people often feel proud of themselves when they complete a difficult task?</li><li>What challenges do young people face today?</li><li>How do young people handle difficult or challe nging tasks?</li><li>What kinds of rewards do people receive from work?</li><li>What are the most difficultjobs that people do?</li></ol><hr><h2 id="美丽城市"><a href="#美丽城市" class="headerlink" title="美丽城市"></a>美丽城市</h2><h3 id="Par2-2"><a href="#Par2-2" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a beautiful city You should say:</p><ul><li><p>Where the city is</p></li><li><p>How you knew about the city What buildings the city has What it is famous for</p></li><li><p>And explain why you think this city is beautiful</p></li></ul><h3 id="Part2-34"><a href="#Part2-34" class="headerlink" title="Part2"></a>Part2</h3><ol><li>What are the differences between modern towns and modern cities?</li><li>Why do some people like to visit historical sites?</li><li>How can people preserve historic cities and historic buildings?</li><li>Is it the government’s responsibility to preserve historic cities and historic buildings?</li><li>Does historic preservation contradict economic development?</li><li>What do you think will happen to historic places or buildings in the future? Why?</li></ol><hr><h2 id="钦佩的运动员"><a href="#钦佩的运动员" class="headerlink" title="钦佩的运动员"></a>钦佩的运动员</h2><h3 id="Par2-3"><a href="#Par2-3" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a successful sportsperson you admire You should say:</p><p>Who he/she is</p><p>What you know about him/her What he/she is like in real life</p><p>What achievement he/she has made And explain why you admire him/her</p><h3 id="Par3"><a href="#Par3" class="headerlink" title="Par3"></a>Par3</h3><ol><li>Should students have physical education and do sports at school?</li><li>What qualities should an athlete have?</li><li>Is talent important in sports?</li><li>Is it easy to identify children’s talents?</li><li>What is the most popular sport in your country?</li><li>Why are there so few top athletes?</li></ol><hr><h2 id="让你开心的照片"><a href="#让你开心的照片" class="headerlink" title="让你开心的照片"></a>让你开心的照片</h2><h3 id="Par2-4"><a href="#Par2-4" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a photo that makes you feel happy You should say:</p><ul><li><p>When and where you took the photo What the photo is like</p></li><li><p>How often you look at the photo</p></li><li><p>And explain why it makes you feel happy</p></li></ul><h3 id="Part2-35"><a href="#Part2-35" class="headerlink" title="Part2"></a>Part2</h3><ol><li>Do you think people are taking too many photos these days?</li><li>What kinds of photos do people like to take?</li><li>Do you think people take more photos now than in the past?</li><li>Do you think equipment is important for photography?</li><li><p>Do you think being a professional photographer is a good job? Why?</p></li><li><p>Why do some people like to post their photos on social media?</p></li></ol><hr><h2 id="擅长说中文的外国人"><a href="#擅长说中文的外国人" class="headerlink" title="擅长说中文的外国人"></a>擅长说中文的外国人</h2><h3 id="Par2-5"><a href="#Par2-5" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a foreigner who speaks Chinese very well You should say:</p><ul><li><p>Who this person is Where he/she is from</p></li><li><p>How he/she learns Chinese</p></li><li><p>And explain why he/she can speak Chinese well</p></li></ul><h3 id="Part2-36"><a href="#Part2-36" class="headerlink" title="Part2"></a>Part2</h3><ol><li>What foreign languages do Chinese children learn?</li><li>Why do Chinese children learn English?</li><li>Why are so many people learning English?</li><li>How can you help children learn English?</li><li>Do you think the way people learn English today is the same as in the past?</li><li>What are the benefits of the Internet for people’s learning?</li></ol><hr><h2 id="喜欢烹妊的人"><a href="#喜欢烹妊的人" class="headerlink" title="喜欢烹妊的人"></a>喜欢烹妊的人</h2><h3 id="Par2-6"><a href="#Par2-6" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a person who enjoys cooking for others You should say:</p><ul><li><p>Who this person is</p></li><li><p>What he/she likes to cook Who he/she cooks for</p></li><li><p>And explain why he/she enjoys cooking</p></li></ul><h3 id="Part2-37"><a href="#Part2-37" class="headerlink" title="Part2"></a>Part2</h3><ol><li>What do we need to prepare when we need to cook?</li><li>Do you agree that food is an important part of Chinese festivals and ceremonies?</li><li>Which dishes are a must at festivals?</li><li>Should students learn to cook at school?</li><li>Do you think cooking should be a compulsory or an elective course? Why?</li><li>Are there any differences between cooking today and in the past?</li></ol><hr><h2 id="想法有趣的人"><a href="#想法有趣的人" class="headerlink" title="想法有趣的人"></a>想法有趣的人</h2><h3 id="Par2-7"><a href="#Par2-7" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a person who always has interesting ideas or opinions</p><ul><li><p>You should say: Who this person is</p></li><li><p>What this person does How you knew him/her</p></li><li><p>And explain why you think his/her ideas or opinions are interesting</p></li></ul><h3 id="Part2-38"><a href="#Part2-38" class="headerlink" title="Part2"></a>Part2</h3><ol><li>When do you think children start to have their own opinions?</li><li>Are children’s opinions influenced by their parents?</li><li>Who are likely to influence smart children?</li><li>How do inventors or philosophers come up with new ideas?</li><li>Do you think ideas from books or writers in the past are all outdated?</li><li>What kind of people have lots of great ideas in your country?</li></ol><hr><h2 id="想见的有趣的人"><a href="#想见的有趣的人" class="headerlink" title="想见的有趣的人"></a>想见的有趣的人</h2><h3 id="Par2-8"><a href="#Par2-8" class="headerlink" title="Par2"></a>Par2</h3><p>Describe an interesting person that youhave not met in person and would like to know more about You should say:</p><ul><li><p>Who this person is How you knew him/her</p></li><li><p>What interesting things he/she has done</p></li><li><p>And explain what you would like to know more about him/her</p></li></ul><h3 id="Part2-39"><a href="#Part2-39" class="headerlink" title="Part2"></a>Part2</h3><ol><li>Are there any differences in the relationship between you and your friends and between you and other people?</li><li>Do people feel lonely in crowded cities?</li><li>Where and how can people get to know new people?</li><li>Can clothing tell and reveal a person’s personality?</li><li>Why do individuals from the same family have different personalities?</li><li>How does society influence a person·s personality?</li></ol><hr><h2 id="学校／工作中的重要规则"><a href="#学校／工作中的重要规则" class="headerlink" title="学校／工作中的重要规则"></a>学校／工作中的重要规则</h2><h3 id="Par2-9"><a href="#Par2-9" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a rule that is important in your school or at work</p><ul><li><p>You should say:</p></li><li><p>What the rule is about</p></li><li><p>What happens when people break the rule Why you think it is an important rule</p></li><li><p>And explain how you feel about the rule</p></li></ul><h3 id="Part2-40"><a href="#Part2-40" class="headerlink" title="Part2"></a>Part2</h3><ol><li>What rules should children follow at home in your country?</li><li>On what occasions can children be forgiven if they don’t follow some rules?</li><li>What rules should people follow when using public transport?</li><li>What kinds of rules do people need to follow in public places?</li><li>What are the reasons that cause people to break rules?</li><li>When people break rules, how would they be punished in your country?</li></ol><hr><h2 id="一幅画"><a href="#一幅画" class="headerlink" title="一幅画"></a>一幅画</h2><h3 id="Par2-10"><a href="#Par2-10" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a drawing/painting that youlike You should say:</p><ul><li><p>When you first saw this painting What the painting is about</p></li><li><p>Who drew/painted it</p></li><li><p>And explain why you like this drawing/painting</p></li></ul><h3 id="Part2-41"><a href="#Part2-41" class="headerlink" title="Part2"></a>Part2</h3><ol><li>What are the differences between painting and drawing?</li><li>Why do some people keep a painting for a long time?</li><li>How does building style affect people’s lives?</li><li>Should children learn to draw and paint? Why?</li><li>How do young people share arts with others?</li><li>Do you think the objects we use in our daily lives should be beautifully designed?</li></ol><hr><h2 id="有趣的地方"><a href="#有趣的地方" class="headerlink" title="有趣的地方"></a>有趣的地方</h2><h3 id="Par2-11"><a href="#Par2-11" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a place in your country that youthink is interesting</p><ul><li><p>You should say: Where it is</p></li><li><p>How you knew it</p></li><li><p>What special features it has</p></li><li><p>And explain why you think it is interesting</p></li></ul><h3 id="Part2-42"><a href="#Part2-42" class="headerlink" title="Part2"></a>Part2</h3><ol><li>How can people access travel information?</li><li>Do people have different personalities in different regions of your country?</li><li>What causes the differences between different regions of your country?</li><li>Is it just youngsters who like to try new things, or do people of your parents· age also like to try new things?</li><li>Is a great tourist destination also a good place to live?</li><li>Why do people who go to live in small towns think these towns are more interesting than the big cities?</li></ol><hr><h2 id="有用的广告"><a href="#有用的广告" class="headerlink" title="有用的广告"></a>有用的广告</h2><h3 id="Par2-12"><a href="#Par2-12" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a good advertisement that youthink is useful</p><ul><li><p>You should say:</p></li><li><p>Where you can see it What it shows</p></li><li><p>Why you think it is useful</p></li><li><p>And explain how you feel about it</p></li></ul><h3 id="Part2-43"><a href="#Part2-43" class="headerlink" title="Part2"></a>Part2</h3><ol><li>What do you think of online advertising?</li><li>Are there any great online advertisements?</li><li>What do people usually buy?</li><li>Why does buying new things make people happy?</li><li>Do people watch useless advertisements in this day and age?</li><li>Do you think there is too much advertising in our daily lives?</li></ol><hr><h2 id="糟糕服务"><a href="#糟糕服务" class="headerlink" title="糟糕服务"></a>糟糕服务</h2><h3 id="Par2-13"><a href="#Par2-13" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a bad service you received in a restaurant/shop</p><ul><li><p>You should say:</p></li><li><p>When and where it happened What happened</p></li><li><p>How you reacted</p></li><li><p>And explain how you felt about the experience</p><h3 id="Part2-44"><a href="#Part2-44" class="headerlink" title="Part2"></a>Part2</h3></li></ul><ol><li>How do most people respond to bad services?</li><li>Do you think services are better now than in the past?</li><li>What kind of services are bad services?</li><li>Why do some people choose to remain silent when they receive bad services?</li><li>Who should be responsible for bad services?</li><li>What can employers do to improve the service that their employees provide?</li></ol><hr><h2 id="一起学习／工作的成功人士"><a href="#一起学习／工作的成功人士" class="headerlink" title="一起学习／工作的成功人士"></a>一起学习／工作的成功人士</h2><h3 id="Par2-14"><a href="#Par2-14" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a successful person who you once studied or worked with</p><ul><li><p>You should say: Who this person is</p></li><li><p>When you studied/worked with this person What you did together</p></li><li><p>What this person did to become successful And explain how you felt about studying or working with this person</p></li></ul><h3 id="Part2-45"><a href="#Part2-45" class="headerlink" title="Part2"></a>Part2</h3><ol><li>Is money the only measure of success in your country?</li><li>How do you define whether one is a successful person?</li><li>What is the standard of success in your country?</li><li>Is there a contradiction between success and happiness?</li><li>Is it easy to succeed in the national tests in your country?</li><li>What are the factors that influence students’ grades at school?</li></ol><hr><h2 id="一同参加的兴奋活动"><a href="#一同参加的兴奋活动" class="headerlink" title="一同参加的兴奋活动"></a>一同参加的兴奋活动</h2><h3 id="Par2-15"><a href="#Par2-15" class="headerlink" title="Par2"></a>Par2</h3><p>Describe an exciting activity that youexperienced with someone else</p><ul><li><p>You should say:</p></li><li><p>What the activity was Who you were with</p></li><li><p>When and where it happened Why you went for it</p></li><li><p>And explain how you felt about it</p></li></ul><h3 id="Part2-46"><a href="#Part2-46" class="headerlink" title="Part2"></a>Part2</h3><ol><li>What kinds of activities do young people like to do?</li><li>Why do some young people like adventurous activities?</li><li>Do you think old people would like to have changes?</li><li>Why can exciting activities relieve people’s stress?</li><li>Can you give some (other) examples of adventurous or risky activities?</li><li>What skills do people need to take part in adventurous activities?</li></ol><hr><h2 id="历史时期"><a href="#历史时期" class="headerlink" title="历史时期"></a>历史时期</h2><h3 id="Par2-16"><a href="#Par2-16" class="headerlink" title="Par2"></a>Par2</h3><p>Describe a historical period/moment you would like to learn more about</p><ul><li><p>You should say:</p></li><li><p>What you are interested in When it happened</p></li><li><p>What you know about it</p></li><li><p>And why you would like to learn more</p></li></ul><h3 id="Part2-47"><a href="#Part2-47" class="headerlink" title="Part2"></a>Part2</h3><ol><li>Should everyone know history?</li><li>In what ways can children learn history?</li><li>What are the differences between learning history from books and from videos?</li><li>Is it difficult to protect and preserve historic buildings?</li><li>Who should be responsible for protecting historic buildings?</li><li>Who should pay for the preservation of historic buildings?</li></ol>]]></content>
      
      
      <categories>
          
          <category> 雅思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于拉氏变换的连续系统分析</title>
      <link href="/posts/5018.html"/>
      <url>/posts/5018.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> default </category>
          
      </categories>
      
      
        <tags>
            
            <tag> default </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拉普拉斯变换</title>
      <link href="/posts/50307.html"/>
      <url>/posts/50307.html</url>
      
        <content type="html"><![CDATA[<p>[施工中..]</p><h1 id="引入——为什么有拉普拉斯变换"><a href="#引入——为什么有拉普拉斯变换" class="headerlink" title="引入——为什么有拉普拉斯变换"></a>引入——为什么有拉普拉斯变换</h1><p>傅里叶变换将时域信号转化到了频域，傅里叶逆变换又实现了频域到时域的过程。根据傅里叶变换的性质，我们发现，使用傅里叶来处理微分方程时，可以消除其中的微分项（时域微分性质）。那如果我们将一个信号从时域变换到频域，在频域处理完后再逆变换回去，那便可以跳过微分项的计算，从而简化计算过程。</p><p>然而，要对一串信号作用傅里叶变换，它就必须要遵循狄利克雷收敛条件。这个条件不利于我们处理一些信号。为了使得更多的信号绝对可积，在傅里叶变换的变换对的基础上给信号施加一个<strong>衰减因子</strong>，又不影响其可以跳过微分的性质，那么我们便可以更轻易地处理系统函数了和求解微分方程。因此，产生了拉普拉斯变换</p><p>因此，我们定义了一个$e^{-\sigma t}$ 做为衰减因子，作用于傅里叶变换的基础上，成为拉氏变换。</p><h1 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="双边拉普拉斯变换"><a href="#双边拉普拉斯变换" class="headerlink" title="双边拉普拉斯变换"></a>双边拉普拉斯变换</h3><p>拉普拉斯变换对的定义如下（双边）</p><ul><li><strong>正变换</strong></li></ul><script type="math/tex; mode=display">F(s)=L[f(t)]=\int_{-\infty}^{\infty}f(t)e^{-st}dt, s=\sigma+j\omega</script><ul><li><strong>逆变换</strong></li></ul><script type="math/tex; mode=display">f(t)=L^{-1}[F(s)]=\frac{1}{2\pi j}\int_{\sigma -j\infty}^{\sigma+j\infty} F(s)e^{st}ds</script><p>正如引入中所介绍，傅里叶变换的定义式是：</p><script type="math/tex; mode=display">F(\omega)=F[f(t)]=\int_{-\infty}^{\infty}f(t)e^{-j\omega t}dt</script><p>如果将傅里叶变换定义中的$e^{-j\omega t}$ 乘上衰减因子$e^{-\sigma t}$，它就变成了$e^{-j\omega t}\times e^{-\sigma t}=e^{-(j\omega+\sigma)t}$， 记复数$j\omega + \sigma =s$，就可以写成$e^{-st}$，这就变成了拉普拉斯变换</p><p>这个衰减因子的 $\sigma$ 是做为常数存在的，也就是可以通过控制 $\sigma$ 来控制衰减的大小。</p><h3 id="单边拉普拉斯变换"><a href="#单边拉普拉斯变换" class="headerlink" title="单边拉普拉斯变换"></a>单边拉普拉斯变换</h3><p>双边拉普拉斯变换中，把 $t&lt;0$ 的范围也算进去了。在现实中，可以将信号开始产生的时刻记为 $t = 0$, 那么$t&lt;0$时没有信号因此$f(t)= 0, t&lt;0$。因此，只需要对$[0, +\infty]$ 区间内的信号进行处理即可。这也就成了单边拉普拉斯变换。(这个$0^-$表示从左侧无限趋近于0开始，从工程的角度解释，就是包含了电感电容等储能元件在 t=0 时的初始条件)</p><ul><li><strong>正变换</strong></li></ul><script type="math/tex; mode=display">F(s)=L[f(t)]=\int_{0^-}^{\infty}f(t)e^{-st}dt, s=\sigma+j\omega</script><p>（逆变换同双边变换，因为逆变换的积分是作用于 s 上的，所以不受 t 的影响）</p><p><strong>在分析实际的系统时，一般都使用单边拉普拉斯变换，因为实际系统具有信号开始产生的 t=0 时刻，t&lt;0 时信号为0，下方所有的讨论也都是适用于单边拉普拉斯变换的</strong></p><h2 id="收敛域（Range-of-Convergence-ROC）"><a href="#收敛域（Range-of-Convergence-ROC）" class="headerlink" title="收敛域（Range of Convergence ROC）"></a>收敛域（Range of Convergence ROC）</h2><p>纵然乘上了个$e^{-\sigma t}$，也只是增加了$f(t)$收敛的可能性，仍不能保证其收敛。因此拉普拉斯变换存在收敛范围，仅在收敛范围内时，$F(s)$ 存在</p><p>那么对于一个施加了衰减因素的信号 $f(t)e^{-\sigma t}$, 其收敛就是当 $t \rightarrow \infty$ 时，$\lim_{t\rightarrow\infty}f(t)e^{-\sigma t}=0$ </p><p>假设存在一个$\sigma_0$, 当$\sigma &gt; \sigma_0$时（也就是衰减速度比$\sigma_0$控制的衰减速度更大时），$\lim_{t\rightarrow\infty}f(t)e^{-\sigma t}=0$ ；  $\sigma &gt; \sigma_0$这个区间便被称为拉普拉斯变换的收敛域，记作$Rs[s] = \sigma &gt; \sigma_0$</p><p><em>举个例子</em></p><p><em>$f(t)=e^{-2t}, t&gt;0$ 求收敛域</em></p><script type="math/tex; mode=display">f(t)e^{-\sigma t}= e^{-2t}e^{-\sigma t}=e^{-(2+\sigma)t}</script><script type="math/tex; mode=display">\lim_{t\rightarrow\infty}e^{-(2+\sigma)t}=0</script><p><em>故$(2+\sigma) &gt; 0$</em>，<em>因此拉氏变换敛域是$\sigma &gt; -2$</em></p><h2 id="典型信号的拉普拉斯变换"><a href="#典型信号的拉普拉斯变换" class="headerlink" title="典型信号的拉普拉斯变换"></a>典型信号的拉普拉斯变换</h2><div class="note danger flat"><p>下面这些都是五星级的，拉普拉斯变换的计算通常使用变换对，下面这些都是常用的变换对</p></div><h3 id="单位阶跃信号（step-signal）"><a href="#单位阶跃信号（step-signal）" class="headerlink" title="单位阶跃信号（step signal）"></a>单位阶跃信号（step signal）</h3><p>信号$f(t) = u(t)$</p><p>因为单边拉式变换从0开始，单位阶跃信号 u(t) 在 $[0,+\infty]$ 范围内都是1，所以下式直接带1</p><script type="math/tex; mode=display">\int_{0}^{\infty}1\times e^{-st}dt=-\frac{1}{s}e^{-st}\bigg|_{0}^{\infty} =\frac{1}{s}</script><h3 id="指数信号-exponential-signal"><a href="#指数信号-exponential-signal" class="headerlink" title="指数信号 (exponential signal)"></a>指数信号 (exponential signal)</h3><p>信号$f(t) = e^{-(\alpha+j\beta)t}$</p><script type="math/tex; mode=display">\int_{0}^{\infty}e^{-(\alpha+j\beta)t}\times e^{-st}dt=\frac{e^{-(s+\alpha+j\beta)t}}{-(s+\alpha+j\beta)}\bigg|^{\infty}_{0}= \frac{1}{(s+\alpha+j\beta)}</script><p>如果$\beta= 0 $，即这是一个实数指数：</p><script type="math/tex; mode=display">F(s)=\frac{1}{(s+\alpha)}, (\sigma > \alpha)</script><p>其中$(\sigma &gt; \alpha )$ 是其收敛域</p><h3 id="单位冲击信号（unit-sample-signal）"><a href="#单位冲击信号（unit-sample-signal）" class="headerlink" title="单位冲击信号（unit sample signal）"></a>单位冲击信号（unit sample signal）</h3><p>信号$f(t) = \delta (t)$</p><script type="math/tex; mode=display">\int_{0^-}^{\infty}\delta(t)\times e^{-st}dt= 1</script><p>如果有时移时：</p><script type="math/tex; mode=display">\int_{0^-}^{\infty}\delta(t-t_0)\times e^{-st}dt= e^{-st_0}</script><h3 id="斜坡信号-ramp-signal"><a href="#斜坡信号-ramp-signal" class="headerlink" title="斜坡信号 (ramp signal)"></a>斜坡信号 (ramp signal)</h3><p>$f(t)= r(t)=t\times u(t)$，在$t&gt;0$时可写成$f(t)=t$</p><p>(下面用了分部积分)</p><script type="math/tex; mode=display">\int_{0^-}^{\infty} t \times e^{-st}dt= -\frac{1}{s}\int_{0}^{\infty}t\ d{e^{-st}}= -\frac{1}{s}\bigg[ t\cdot e^{-st}\bigg|^{\infty}_{0}- \int_{0}^{\infty}e^{-st}dt \bigg]=\frac{1}{s^2}</script><h2 id="拉普拉斯变换的性质"><a href="#拉普拉斯变换的性质" class="headerlink" title="拉普拉斯变换的性质"></a>拉普拉斯变换的性质</h2><div class="note danger flat"><p>下面这些都是五星级的，证明请参考Dr. Ruiheng Wu 的 PPT 或是百度，方法千奇百怪的，这里不再赘述。</p></div><h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><p>若：</p><script type="math/tex; mode=display">L[f_1(t)]=F_1(s), L[f_2(t)]=F_2(s)</script><p>有：</p><script type="math/tex; mode=display">L[k_1f_1(t)+k_2f_2(t)]=k_1F_1(s)+k_2F_2(s)</script><h3 id="时移"><a href="#时移" class="headerlink" title="时移"></a>时移</h3><p>若：</p><script type="math/tex; mode=display">L[f(t)]=F(s)</script><p>有：</p><script type="math/tex; mode=display">L[f(t-t_0)]=F(s)e^{-st_0}</script><h3 id="频移"><a href="#频移" class="headerlink" title="频移"></a>频移</h3><p>若：</p><script type="math/tex; mode=display">L[f(t)]=F(s)</script><p>有：</p><script type="math/tex; mode=display">L[f(t)e^{-\alpha t}]=F(s+\alpha)</script><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>若：</p><script type="math/tex; mode=display">L[f(t)]=F(s)</script><p>有：</p><script type="math/tex; mode=display">L[f(at)]=\frac{1}{a}F(\frac{s}{a}), a>0</script><p><em>如果同时时移和缩放：</em></p><script type="math/tex; mode=display">L[f(at-b)u(at-b)]=\frac{1}{a}F(\frac{s}{a})e^{-s\frac{b}{a}}</script><h3 id="时域微分（一重和二重必记）"><a href="#时域微分（一重和二重必记）" class="headerlink" title="时域微分（一重和二重必记）"></a>时域微分（一重和二重必记）</h3><p>一重</p><script type="math/tex; mode=display">L\bigg[\frac{df(t)}{dt}\bigg]=sF(s)-f(0_-)</script><p>二重</p><script type="math/tex; mode=display">L\bigg[\frac{df^2(t)}{dt}\bigg]=s^2F(s)-sf(0_-)-sf^{'}(0_-)</script><p>通式</p><script type="math/tex; mode=display">L\bigg[\frac{df^n(t)}{dt}\bigg]=s^nF(s)-\sum ^{n-1}_{r=0}s^{n-r-1}f^{r}(0_-)</script><h3 id="初值定理（时域趋近于0时的s域）"><a href="#初值定理（时域趋近于0时的s域）" class="headerlink" title="初值定理（时域趋近于0时的s域）"></a>初值定理（时域趋近于0时的s域）</h3><script type="math/tex; mode=display">\lim_{t\rightarrow0^+}f(t)=f(0_+)=\lim_{s\rightarrow\infty}sF(s)</script><h3 id="终值定理（时域趋近于无穷时的s域）"><a href="#终值定理（时域趋近于无穷时的s域）" class="headerlink" title="终值定理（时域趋近于无穷时的s域）"></a>终值定理（时域趋近于无穷时的s域）</h3><script type="math/tex; mode=display">\lim_{t\rightarrow \infty}f(t)=\lim_{s\rightarrow0}sF(s)</script><h3 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h3><script type="math/tex; mode=display">L[f_1(t)*f_2(t)]=F_1(s)\cdot F_2(s)</script><h3 id="s域微分"><a href="#s域微分" class="headerlink" title="s域微分"></a>s域微分</h3><script type="math/tex; mode=display">L[t^nf(t)]=(-1)^n\frac{d^nF(s)}{ds^n}</script><h3 id="s域积分"><a href="#s域积分" class="headerlink" title="s域积分"></a>s域积分</h3><script type="math/tex; mode=display">L\bigg[\frac{f(t)}{t}\bigg]=\int_{s}^{\infty}F(s)ds</script><h1 id="拉普拉斯反变换"><a href="#拉普拉斯反变换" class="headerlink" title="拉普拉斯反变换"></a>拉普拉斯反变换</h1><h2 id="变换的两种方法"><a href="#变换的两种方法" class="headerlink" title="变换的两种方法"></a>变换的两种方法</h2><p>要从F(s)变回f(t)，通常来说有两种方法：</p><ul><li>部分分式展开法</li><li>留数定理计算</li></ul><p>正如前面提及，拉普拉斯变换常用变换对进行计算，将f(t)或F(s)往变换对上凑，以此来简便计算实现变换。而部分分式展开法就是为此而设计的，该课程仅介绍该方法。</p><p>下面是常用的拉普拉斯变换对：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/3695f24fdd864ef5a57ac31601b2168b.png" alt="img"></p><h2 id="部分分式展开法"><a href="#部分分式展开法" class="headerlink" title="部分分式展开法"></a>部分分式展开法</h2><p>对于任意一个式子，都可以写成分数的形式，无论是真分数还是假分数，总之它是可以的。也就是说，我们可以把F(s)拆分成分母和分子两部分</p><script type="math/tex; mode=display">F(s)=\frac{A(s)}{B(s)}=\frac{a_ms^m+a_{m-1}s^{m-1}+...+a_{1}s+a_0}{b_ns^n+b_{n-1}s^{n-1}+...+b_{1}s+b_0}</script><h3 id="F-s-为真分式"><a href="#F-s-为真分式" class="headerlink" title="F(s)为真分式"></a>F(s)为真分式</h3><p>若F(s)为真分式，即，其分子的次数低于分母的次数，那么可作如下处理：</p><p>$B(s)$ 这一组多项式可以被因式分解<em>（因式分解就是：多项式$3x^2-2x-1 = (3x+1)(x-1)$）</em></p><p>因此F(s)可以被写成：</p><script type="math/tex; mode=display">F(s)=\frac{A(s)}{(s-p_1)(s-p_2)...(s-p_n)}</script>]]></content>
      
      
      <categories>
          
          <category> 信号与系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟信号分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1-Filter</title>
      <link href="/posts/a7a0e2d0.html"/>
      <url>/posts/a7a0e2d0.html</url>
      
        <content type="html"><![CDATA[<h1 id="滤波器基本参数"><a href="#滤波器基本参数" class="headerlink" title="滤波器基本参数"></a>滤波器基本参数</h1><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226174510849.png" alt="image-20240226174510849"></p><p>上图展示了滤波器通带、阻带、过渡带。</p><h3 id="特征角频率和特征频率-f-0-f-n-pole-frequency-nature-frequency"><a href="#特征角频率和特征频率-f-0-f-n-pole-frequency-nature-frequency" class="headerlink" title="特征角频率和特征频率($f_0/f_n$) pole frequency/ nature frequency"></a>特征角频率和特征频率($f_0/f_n$) pole frequency/ nature frequency</h3><p>它只与滤波用的电阻和电容元件的参数有关，通常对于带通(带阻）滤波器，称为带通(带阻）滤波器的中心角频率或中心频率$f_0$，是通带(阻带）内电压增益最大(最小）点的频率。<br>滤波器的截止频率（$f_c$）cut-off frequency</p><h3 id="滤波器的截止频率（-f-c-）cut-off-frequency"><a href="#滤波器的截止频率（-f-c-）cut-off-frequency" class="headerlink" title="滤波器的截止频率（$f_c$）cut-off frequency"></a>滤波器的截止频率（$f_c$）cut-off frequency</h3><p>一般地是指幅度响应比通带低3 dB时的频率。无论是什么样的滤波器，截止频率一般都是指-3db的位置，也就是说从滤波器的通带的增益算起，下降-3db的位置。</p><p><strong>Chenqiao原话：但是一些文献里面认为$f_0$就是截止频率$ f_c $，截止频率不一定需要在-3dB point。这里需要根据实际情况讨论。</strong></p><hr><h1 id="无源滤波器-Passive-Filter"><a href="#无源滤波器-Passive-Filter" class="headerlink" title="无源滤波器(Passive Filter)"></a>无源滤波器(Passive Filter)</h1><p>电容、电抗和阻抗的关系：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226174753964.png" alt="image-20240226174753964"></p><p>所有滤波器的公式都是将电容和电抗表现成阻抗的形式，代入电路得出的。</p><h2 id="一阶无源滤波器"><a href="#一阶无源滤波器" class="headerlink" title="一阶无源滤波器"></a>一阶无源滤波器</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226174630689.png" alt="image-20240226174630689"></p><h3 id="低通"><a href="#低通" class="headerlink" title="低通:"></a>低通:</h3><p>一阶低通滤波器：输出的电压等于夸在电容两端的电压，输出信号的相位</p><script type="math/tex; mode=display">\psi=\phi_0-arctan⁡(R/X_C )=\phi_0-arctan⁡(2πfRC)。</script><p><strong>因此，当到达截止频率$X_C=R$时，相位移动为-45°</strong></p><h3 id="高通："><a href="#高通：" class="headerlink" title="高通："></a>高通：</h3><p>输出的电压等于夸在电阻两端的电压，相位：</p><script type="math/tex; mode=display">\psi=\phi_0+π/2-arctan⁡(2πfRC)</script><p><strong>因此，当到达截止频率$X_C=R$时，相位移动为+45°</strong></p><h2 id="二阶滤波器"><a href="#二阶滤波器" class="headerlink" title="二阶滤波器"></a>二阶滤波器</h2><p>对于高阶滤波器，可以看成多个一阶串联，因此相位移动是叠加的。例如二阶高通滤波器截止频率的相位移动就是+90°</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175143051.png" alt="image-20240226175143051"></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175159970.png" alt="image-20240226175159970"></p><h3 id="增益下降slope比较"><a href="#增益下降slope比较" class="headerlink" title="增益下降slope比较"></a>增益下降slope比较</h3><p>二阶滤波器可以看做两个一阶滤波器串联。因此假设对于某一频率，一个二阶滤波器由两个同样的一阶滤波器串联而成。一阶滤波器的slope=-20dB/Decade, 那么二阶滤波器slope就是一阶滤波器的平方也就是-40dB/ Decade. (Decade=f/fc(3dB))</p><p>对于二阶带通滤波器而言，两端的slope是两个独立的一阶滤波器，因此还是-20dB/ Decade.</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175308020.png" alt="image-20240226175308020"></p><hr><h1 id="有源滤波器-Active-Filter"><a href="#有源滤波器-Active-Filter" class="headerlink" title="有源滤波器(Active Filter)"></a>有源滤波器(Active Filter)</h1><p>有源滤波器带有运放，因此可以实现增益大于1（0dB）。且提供更好的输入输出阻抗。</p><h2 id="有源低通滤波器"><a href="#有源低通滤波器" class="headerlink" title="有源低通滤波器"></a>有源低通滤波器</h2><table>    <tr>        <td><center><img src= "https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175432892.png"></center></td>            <td><center><img src= "https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175447274.png"></center></td></table><p>其截止频率$f=1/2πRC$, </p><p>增益$DC Gain=(1+R_2/R_1 )$,</p><p>如果把低通滤波器的电阻放在反馈电阻上，同样能通过影响不同频率的放大倍数进行滤波。这样可以得到更好的输入阻抗。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175650304.png" alt="image-20240226175650304"></p><p>一阶有源HPF只需要把电容更换位置，放在信号输入端即可（也就是R1前面）。</p><h2 id="有源高通滤波器-二阶"><a href="#有源高通滤波器-二阶" class="headerlink" title="有源高通滤波器(二阶)"></a><strong>有源高通滤波器(二阶)</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175821801.png" alt="image-20240226175821801"></p><p>同无源滤波器分析的一样，有源一阶滤波器的slope斜率为-20dB/Decade, 二阶为-40dB/Decade.</p><h2 id="有源带通滤波器-二阶"><a href="#有源带通滤波器-二阶" class="headerlink" title="有源带通滤波器(二阶)"></a><strong>有源带通滤波器(二阶)</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175903538.png" alt="image-20240226175903538"></p><h2 id="有源带阻滤波器"><a href="#有源带阻滤波器" class="headerlink" title="有源带阻滤波器"></a><strong>有源带阻滤波器</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226175930196.png" alt="image-20240226175930196"></p><p>相当于是一个有源加法器，输入信号为一个高通的输出和一个低通的输出。增益-频率响应为高通和低通的叠加。<br>有源的二阶带通和带阻中心频率计算公式都是</p><script type="math/tex; mode=display">f_0=\sqrt{(f_L⋅f_H)}</script><p>陷波滤波器(Notch Filter) 是带阻滤波器的一种，只不过阻带很窄。（好像不是重点，没考过）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226180019446.png" alt="image-20240226180019446"></p><hr><h1 id="Sallen-Key-滤波器（五星级）"><a href="#Sallen-Key-滤波器（五星级）" class="headerlink" title="Sallen-Key 滤波器（五星级）"></a>Sallen-Key 滤波器（五星级）</h1><p>Sallen-key是设计有源滤波器设计的一种拓扑结构，VCVS（Voltage-controlled voltage-source）滤波器的变种，由麻省理工学院林肯实验室的R. P. Sallen and E. L. Key 在1955所提出。</p><h2 id="Q-Factor"><a href="#Q-Factor" class="headerlink" title="Q Factor"></a>Q Factor</h2><p>用频率定义Q：电路发生谐振的频率 ω0 称为谐振频率谐振峰两边 I ＝ （1/2） Im 处的频率值ω2j 和 ω1j 之间宽度定义为通频带宽度 BW，衡量一个谐振器在电路中性能的好坏。常用品质因数 Q ＝ ω0/ω2j －ω1j 来描述，Q 的物理意义是在谐振频率ω0 附近将具有更强的频率响应；对于偏离 ω0 较远的频率，则响应很弱或不响</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226180243570.png" alt="image-20240226180243570"></p><p>对低通和高通滤波器而言,<strong>Q值等于滤波器电路电压增益（截止频率对应处的增益）模$|A_u |$与通带增益的模之比 $|A_{up}|$；对带通(带阻）滤波器而言，Q值等于中心角频率与通带(阻带）宽度bw之比。</strong></p><h2 id="S-K滤波器的整体模型"><a href="#S-K滤波器的整体模型" class="headerlink" title="S-K滤波器的整体模型"></a>S-K滤波器的整体模型</h2><p>图中电阻根据低通、带通、高通不同要求替换成电容。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226180316035.png" alt="image-20240226180316035"></p><p>计算通式为：</p><script type="math/tex; mode=display">\frac{V_{out}}{V_{in}}=\frac{Z_3\times Z_4}{Z_1\times Z_2 + Z_2\times Z_3 +Z_3 \times Z_4 +Z_1 \times Z_3}</script><h2 id="S-K低通-amp-高通滤波器"><a href="#S-K低通-amp-高通滤波器" class="headerlink" title="S-K低通&amp;高通滤波器"></a>S-K低通&amp;高通滤波器</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226180514237.png" alt="image-20240226180514237"></p><p>以低通滤波器为例：</p><script type="math/tex; mode=display">Z_1=R_1,Z_2=R_2,Z_3=\frac{1}{(sC_1 )},Z_4=\frac{1}{(sC_2 )}, 其中 s=jω</script><script type="math/tex; mode=display">A=\frac{\frac{1}{sC_1}\times \frac{1}{sC_2}}{R_1R_2+R_2\frac{1}{sC_1}+\frac{1}{sC_1}\times \frac{1}{sC_2}+R_1\frac{1}{sC_1}}</script><script type="math/tex; mode=display">=  \frac {1}{R_ {1}R_ {2}C_ {1}C_ {2}s^ {2}+R_ {2}C_ {2}s+1+R_ {1}C_ {2}s}</script><script type="math/tex; mode=display">=  \frac {1}{R_ {1}R_ {2}C_ {1}C_ {2}s^ {2}+C_ {2}s(R_ {1}+R_ {2})+1}</script><h3 id="特征频率"><a href="#特征频率" class="headerlink" title="特征频率:"></a>特征频率:</h3><p>（有时候认为$f_n=f_c$，$f_c$不在-3dB点，所以截止频率也是这个，具体要看题目）</p><script type="math/tex; mode=display">f_n=\frac{1}{(2\pi\sqrt{(R_1 R_2 C_1 C_2 )}}</script><h3 id="品质因子Q："><a href="#品质因子Q：" class="headerlink" title="品质因子Q："></a>品质因子Q：</h3><script type="math/tex; mode=display">Q=\frac{1}{R_1+R_2}(\sqrt{R_1 R_2 \frac{C_1}{C_2} })</script><p>当$R_1=R_2, C_1=C_2$ 时，Q 有：</p><script type="math/tex; mode=display">Q=\frac{1}{3-A}</script><p>其中A为放大电路的放大倍数。</p><h2 id="设计S-K滤波器的例题"><a href="#设计S-K滤波器的例题" class="headerlink" title="设计S-K滤波器的例题"></a>设计S-K滤波器的例题</h2><p>设计一个具有以下特性的二阶高通Sallen-Key滤波器电路：$f_C=200Hz，Q=3$。</p><p>解：</p><p>为简化计算，认为$R_1=R_2,C_1=C_2$</p><p>$f_c=1/2πRC=200Hz$, 选择c=100nF继续计算， R=7957Ω。（这道题认为$f_c=f_0$，PPT上举例原题）</p><script type="math/tex; mode=display">Q=3=\frac{1}{3-A},A=\frac{3Q-1}{Q}=2.667</script><p>所以放大电阻分别取10K和6K</p><h2 id="设计S-K滤波器生成类型的判定："><a href="#设计S-K滤波器生成类型的判定：" class="headerlink" title="设计S-K滤波器生成类型的判定："></a>设计S-K滤波器生成类型的判定：</h2><p>滤波器的类型是看 $\omega_0$ 处有没有bump来判定的，因此使用品质因素Q来判定</p><p>巴特沃夫滤波器没有bump,因此Q<1贝塞尔滤波器Q≈1切比雪夫滤波器Q>1</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240226181523677.png" alt="image-20240226181523677"></p>]]></content>
      
      
      <categories>
          
          <category> 电子系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1-CH4-数字的表达和算数电路</title>
      <link href="/posts/61287.html"/>
      <url>/posts/61287.html</url>
      
        <content type="html"><![CDATA[<h1 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h1><h2 id="半加法器"><a href="#半加法器" class="headerlink" title="半加法器"></a>半加法器</h2><p>半加法器接受两个输入：$x_1,x_2$ 并产生本位和进位两个输出。半加法器的真值表和实现电路如下图所示</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209031411970.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209031506622.png"></center></td>    </tr></table><h2 id="全加法器"><a href="#全加法器" class="headerlink" title="全加法器"></a>全加法器</h2><p>全加法器：输入$x_1,x_2,c$,三位（其中c表示上一位到这一位的进位）计算三位相加产生本位和进位。真值表和电路如下</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209031737291.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209031755498.png"></center></td>    </tr></table><h2 id="串行进位全加法器（Ripple-carry-Adder）"><a href="#串行进位全加法器（Ripple-carry-Adder）" class="headerlink" title="串行进位全加法器（Ripple-carry Adder）"></a>串行进位全加法器（Ripple-carry Adder）</h2><p>讲上述全加法器进行串联，前一个的进位输出连接至下一个的进位输入。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/clip_image002.gif" alt="图表, 箱线图  描述已自动生成" style="zoom:150%;" /></p><div class="note info simple"><p>原码（True form）反码(1’s complement ) 补码(2’s complement) 在 计算机组成与接口 中有更详细的介绍，此处略去。</p></div><h1 id="加法（减法）单元"><a href="#加法（减法）单元" class="headerlink" title="加法（减法）单元"></a>加法（减法）单元</h1><p>在计算机中，设计专门的减法电路划不来，因此使用补码+加法电路来计算减法。补码的求法是原码取反加一，因此设计如下的计算模块</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209032156159.png" alt="image-20240209032156159"></p><ul><li>当Add/Sub control 为0时，$y_i=y_i\oplus0=y_i$, 同时输入的基础进位$c_0$等于0。此时是正常调用全加法器计算加法。</li><li>当Add/Sub control为1时，$y_i=y_i\oplus1=\overline y_i$,同时$c_0=1$。相当于把序列$y$取反后加1（这个加一就是基础进位$c_0$加上来的）算成了补码的形式。故调用全加法器计算减法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字电路设计与可靠性工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1-CH5-组合电路-构建快</title>
      <link href="/posts/5331.html"/>
      <url>/posts/5331.html</url>
      
        <content type="html"><![CDATA[<h1 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h1><p>多路复用器可以使用逻辑门制造，也可以使用Transition Gate 制造。一个多路复用器具有n个输入，那么就需要$log_{2}{n}$路选择信号。考试中最多出现4 to 1多路复用器。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209032918533.png" alt="image-20240209032918533"></p><p>例题：2x2交叉选择器</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209032958296.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209033003100.png"></center></td>    </tr></table><h2 id="使用多路复用器构建逻辑函数-五星级中的五星级"><a href="#使用多路复用器构建逻辑函数-五星级中的五星级" class="headerlink" title="使用多路复用器构建逻辑函数 五星级中的五星级"></a>使用多路复用器构建逻辑函数 <em>五星级中的五星级</em></h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209033354986.png" alt="image-20240209033354986"></p><p>如上图这个情况，使用$w_1,w_2$做为选择信号，可以把输出分为4个case：</p><ul><li>Case 0: $w_1=0,w_2=0$, 输出为0</li><li>Case 1: $w_1=0,w_2=1$, 输出等于$w_3$</li><li>Case 3: $w_1=1,w_2=0$,输出等于$w_3$</li><li>Case 4: $w_1=1,w_2=1$,输出等于1</li></ul><p>这样就实现了用多路复用器来实现基础的逻辑组合。除了简单的电路外，还可以使用逻辑门的输出和多路复用器进行组合，实现更复杂的电路。</p><p><strong>香农拓展定理（Shannon’s Expansion Theorem）</strong></p><p>香农拓展定理的核心理念是：对于一个Boolean function, 可以把它写为分解为$w_1 (…)+ \overline w_1 (…)$，也就是$w_1$和$\overline w_1$下的两种情况。这里的$w_1$为称为辅因子(cofactor). 那么对于一个有$w_n$项的布尔函数，把$w_1$作为辅因子，可以写成如下表达式：</p><script type="math/tex; mode=display">f(  w_ {1}  ,  w_ {2}  ,  \cdots  ,  w_ {n}  )=  \overline {w}_ {1}   \cdot  f(0,  w_ {2}  ,  \cdots  ,  w_ {n}  )+  w_ {1}   \cdot  f(1,  w_ {2}  ,  \cdots  ,  w_ {n}  )</script><p>几个分解的例题：</p><ul><li><strong>例1：</strong></li></ul><script type="math/tex; mode=display">f(  w_ {1}  ,  w_ {2}  ,  w_ {3}  )=  w_ {1}   w_ {2}  +  w_ {1}   w_ {3}  +  w_ {2}   w_ {3}</script><p>可分解为：</p><script type="math/tex; mode=display">f=  w_ {1}   w_ {2}  +  w_ {1}   w_ {3}  +(  w_ {1}  +  \overline {w_ {1}}  )  w_ {2}   w_ {3}  =  w_ {1}  (  w_ {2}  +  w_ {3}  +  w_ {2}   w_ {3}  )+  \overline {w_ {1}}  (  w_ {2}   w_ {3}  )=  w_ {1}  (  w_ {2}  +  w_ {3}  )+  \overline {w_ {1}}  (  w_ {2}   w_ {3}  )</script><ul><li><strong>例2</strong></li></ul><script type="math/tex; mode=display">f=  w_ {1}   \oplus   w_ {2}   \oplus   w_ {3}</script><p>可分解为：</p><script type="math/tex; mode=display">f=\overline w_1(w_ {2}   \oplus   w_ {3}  )+  w_ {1}  (  w_ {2}   \oplus   w_ {3}  )</script><ul><li>例3</li></ul><script type="math/tex; mode=display">f=  \overline {w}_ {1}   \overline {w}_ {3}  +  w_ {1}   w_ {2}  +  w_ {1}   w_ {3}</script><p>使用$w_1$作cofactor：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209034518973.png" alt="image-20240209034518973"></p><p>使用$w_1w_2$做cofactor：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209034545314.png" alt="image-20240209034545314"></p><hr><h1 id="解码器（decoders）"><a href="#解码器（decoders）" class="headerlink" title="解码器（decoders）"></a>解码器（decoders）</h1><p>解码器电路接受$n$个输入，产生$2^n$个输出。其作用是将收到的数据映射到对应的线路上去。举个例子，假设一个2bit decoder受到的数据是11，对应十进制是3（第四个数，从0开始数），那么它会把输出的第4条线置高电平。下面是一个2bit解码器的例子</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209034839045.png" alt="image-20240209034839045"></p><p>使用多路复用器的思路，也可以用两个2 to 4 decoder 合成一个 3 to 8 decoder</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209034926916.png" alt="image-20240209034926916"></p><p>解码器最重要的应用之一是用于存储信息的存储块寻址：</p><p>输入想要访问的存储单元的地址，解码器即可将那一行使能（此处可以b站了解一下NAND闪存或者固态硬盘工作原理）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209035138132.png" alt="image-20240209035138132"></p><hr><h1 id="多路分解器（Demultiplexer）"><a href="#多路分解器（Demultiplexer）" class="headerlink" title="多路分解器（Demultiplexer）"></a>多路分解器（Demultiplexer）</h1><p>Multiplexer使用不同switch输入组合选择输出不同的单条线路。Demultiplexer使用不同的Switch输入组合将单条线路输出到在多个不同的数据输出上。</p><p>Demultiplexer 可以用 Decoder实现，下图就是个例子。右图$w_1 w_2$被用作Switch 信号，En被用作输入信号。$w_1 w_2$控制En信号在那条路上被输出。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209035039471.png" alt="image-20240209035039471"></p><hr><h1 id="编码器-（Encoder）"><a href="#编码器-（Encoder）" class="headerlink" title="编码器 （Encoder）"></a>编码器 （Encoder）</h1><p>编码器是Decoder的逆过程，它接受$2^n$条输入，产生n个输出。n个输出呈现二进制数，用于表示是哪一条输入。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209035340281.png" alt="image-20240209035340281"></p><hr><h1 id="译码器（Code-Converter）"><a href="#译码器（Code-Converter）" class="headerlink" title="译码器（Code Converter）"></a>译码器（Code Converter）</h1><p>把输入翻译成特定的输出。例如用来点亮7为数码管的code converter, 会把二进制数字输入转化成对应的pattern输出。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/clip_image002.jpg" alt="img"></p><hr><h1 id="算术比较电路"><a href="#算术比较电路" class="headerlink" title="算术比较电路"></a>算术比较电路</h1><p>算术比较电路接受两个二进制数输入，记为A和B，比较A和B大小后输出A&gt;B,A=B,A&lt;B三个输出。</p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209035554476.png" alt="image-20240209035554476"></p><p>在这个例子中，定义一个中间信号$i_k=\overline {a_k\oplus b_k}$</p><p>则：A=B可表示为：$AeqB=i_3i_2i_1i_0$，A&gt;B可表示为$AgtB= a_ {3}   \overline {b}_ {3}  +  i_ {3}   a_ {2}   \overline {b}_ {2}  +  i_ {3}   i_ {2}   a_ {1}   \overline {b}_ {1}  +  i_ {3}   i_ {2}   i_ {1}   a_ {0}   \overline {b}_ {0}$ ， A&lt;B可表示为：$AltB=\overline {AeqB+AgtB}$</p><p>算术比较电路也可被分为两类：有符号的，无符号的。</p><ul><li>有符号的：认为输入的数据是以补码的形式输入的，第一位为符号位，这类算术比较电路通常使用加法电路来比较大小</li><li>无符号的：认为输入数据都是原码格式，没有符号位，这类算术比较电路通常直接比较，上图就是无符号的例子</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字电路设计与可靠性工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32的UART通信(Register)</title>
      <link href="/posts/7c92a281.html"/>
      <url>/posts/7c92a281.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本工作原理-F4系列"><a href="#基本工作原理-F4系列" class="headerlink" title="基本工作原理(F4系列)"></a>基本工作原理(F4系列)</h1><p>F4的USART模块支持可编程字长、自定义波特率、单线半双工模式（RX，TX使用一条线，半双工收发）、唤醒MCU、可编程的停止位长度、可启用/禁用/设置模式的就校验位。其硬件模块如下</p><p>F4系列的USART模块还支持IRDA和LIN，这里不会详细介绍</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240205011104190.png" alt="image-20240205011104190"  /></p><p>USART硬件系统可以被拆分成如下几个重要部分：</p><p>控制初始化工作部分</p><ul><li>使能USART：由CR1寄存器UE位(bit13)进行控制，使能后USART模块才会开始工作，不用时失能减少功耗；</li><li>设置数据字长：F4系列支持8bit和9bit两种长度，通过对CR1寄存器M位(bit12)配置进行控制；</li><li>设置波特率：波特率生成器负责生成控制发送速率的时钟，由USART_BRR寄存器控制。</li><li>设置停止位长度：由CR2寄存器中bit[12:13]控制，支持0.5 / 1 / 1.5 / 2四种停止位长度</li><li>设置奇偶校验：CR1寄存器PCE位（bit10）控制。</li></ul><p>控制收发工作部分</p><ul><li>DR(数据寄存器)：用于寄存要发送的数据或者收到的数据。发送时，该寄存器内的值会被逐个读取至TDR，并通过移位寄存器逐个bit发送；接受时，RDR寄存器内的数值会逐个写入该寄存器。TDR和RDR寄存器用户不可交互，仅可以操作DR。</li><li>开始发送：当CR1寄存器中发送使能位（bit4）控制。当置 1 时，发送移位寄存器中的数据在 TX 引脚输出</li><li>在发送开始后，TDR寄存器内的数据会被传输到发送移位寄存器，开始自动传输。</li><li>在发送数据开始时，SCLK会产生时钟脉冲，以兼容同步通信。</li></ul><p>状态指示器部分</p><ul><li>TC(Transmission Complete)：当发送完成，且无新的数据被写入待发送时(即，TXE位为1，且没有新数据写入DR使得TXE置0)，TC位将会被置1表示发送完成；否则由硬件置0。该位可以CR1寄存器配置中断</li><li>TXE：DR寄存器和TDR寄存器均已完成数据交接，现数据在发送移位寄存起内准备发送；DR寄存器支持写入新的数据；<strong>TXE寄存器由硬件置位，超DR寄存器写入来清零</strong>。该位可由CR1寄存器配置中断。</li><li>RXNE：类似于TXE，用于指示接收输入已经传到RDR，接收移位寄存器可以接收下一帧数据。</li></ul><p>中断控制器部分</p><ul><li>中断使能分布在CR寄存器中，可在完成单次接收、完成单次发送、完成传输、出现错误、侦测到空闲等时候触发中断</li></ul><p>硬件流控部分</p><ul><li>nRTS：如果使能 RTS 流控制 (RTSE=1)，只要 USART 接收器准备好接收新数据，便会将 nRTS 变  为有效（输出低电平）。当接收寄存器已满时，会将 nRTS 变为无效（高电平）。</li><li>nCTS：如果使能 CTS 流控制 (CTSE=1)，则发送器会在发送下一帧前检查nCTS。如果 nCTS 有效（收到低电平），则会发送下一数据（假设数据已准备好发送，即 TXE=0）；否则不会进行发送。如果在发送过程中 nCTS 变为无效，则当前发送完成之后，发送器停止。</li></ul><h1 id="UART（F4系列）"><a href="#UART（F4系列）" class="headerlink" title="UART（F4系列）"></a>UART（F4系列）</h1><h2 id="计算波特率和波特率寄存器"><a href="#计算波特率和波特率寄存器" class="headerlink" title="计算波特率和波特率寄存器"></a>计算波特率和波特率寄存器</h2><p>在工作原理图的下方发送器时钟框图部分可以看出，串口时钟信号$f_{ck}$首先经过USARTDIV分频，然后再经过$8\times(2-OVER8)$分频产生，因此波特率计算公式如下：</p><script type="math/tex; mode=display">Baud=\frac{f_{ck}}{8\times(2-OVER8)\times USARTDIV}</script><p>其中USARTDIV这个常数是通过USART_BRR寄存器配置得到的，计算公式如下，这里面的OVER8是超采样的配置（通过USART_CR1寄存器配置，后续介绍），F1系列没有(F1系列默认16倍)。OVER8: “1”=8倍过采样； “0”=16倍过采样。</p><script type="math/tex; mode=display">USARTDIV=DIV\_Mantissa+(DIV\_Fraction/8\times(2-OVER8))</script><p>因此，在已知Baud时，可以算出USARTDIV，又可以根据USARTDIV算出配置USART_BRR寄存器的DIV_Mantissa和DIV_Fraction (整数和小数)部分的值。USART_BRR寄存器结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240205175018208.png" alt="image-20240205175018208"></p><p><strong>它本身有32位，但仅使用16位，高16位保持复位值（全0）。USART的整数部分写入15-4位，小数部分写入3:0位。当过采样设置为8倍（i.e., OVER8=1）时，小数仅使用2:0位，DIV_Fraction3 必须保持为0</strong></p><p>举个例子：要设置波特率为115200，OVER8=0, 串口总线频率$f_{ck}=72MHz$</p><script type="math/tex; mode=display">USARTDIV=\frac{72M}{16\times115200}=39.0625</script><script type="math/tex; mode=display">DIV\_Mantissa=39 (直接取整数部分即可)</script><script type="math/tex; mode=display">DIV\_Fraction=(USARTDIV-DIV\_Mantissa)\times16=0.625\times16=10</script><p>在计算DIV_Fraction部分时，计算出的结果不一定全部是整数，因此需要进行四舍五入。因为是以整形数据进行存储，所以计算出的结果会进行直接去小数操作。因此直接在DIV_Fraction计算值后面+0.5来进行四舍五入。</p><p>设置代码如下(16倍过采样)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fck=72000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Baud=115200</span></span><br><span class="line"><span class="type">uint16_t</span> mantissa;</span><br><span class="line"><span class="type">uint16_t</span> fraction;</span><br><span class="line">mantissa=fck/(<span class="number">16</span>*Baud);</span><br><span class="line">fraction=(fck%(<span class="number">16</span>*Baud))*<span class="number">16</span>+<span class="number">0.5</span>;</span><br><span class="line">USART-&gt;BRR=(mantissa&lt;&lt;<span class="number">4</span>)+fraction;</span><br></pre></td></tr></table></figure><p>不难看出，因为小数部分进行了舍入操作，所以部分波特率会有误差。典型$f_{ck}$下设置波特率的误差在不同芯片的芯片手册中有详细介绍。这里给出一份计算真实波特率的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fck 80000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Baud 100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVER8 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mantissa;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fraction;</span><br><span class="line"><span class="type">float</span> USARTDIV;</span><br><span class="line"><span class="type">float</span> realBaud;</span><br><span class="line"><span class="type">float</span> r_USARTDIV;</span><br><span class="line">USARTDIV = fck/(<span class="number">8</span>*(<span class="number">2</span>-OVER8)*Baud); </span><br><span class="line">mantissa=<span class="type">int</span>(USARTDIV);</span><br><span class="line">fraction=(USARTDIV-mantissa)*(<span class="number">8</span>*(<span class="number">2</span>-OVER8))+<span class="number">0.5</span>;</span><br><span class="line">r_USARTDIV = mantissa + (fraction/<span class="number">16</span>); </span><br><span class="line">realBaud = fck/(<span class="number">16</span>*r_USARTDIV);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mantissa=%d,fraction=%d\n&quot;</span>,mantissa,fraction);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;real USARTDIV = %f, real Baud = %f&quot;</span>,r_USARTDIV,realBaud);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F4系列UART常用功能"><a href="#F4系列UART常用功能" class="headerlink" title="F4系列UART常用功能"></a>F4系列UART常用功能</h2><h3 id="奇偶校验控制"><a href="#奇偶校验控制" class="headerlink" title="奇偶校验控制"></a>奇偶校验控制</h3><p>通过配置CR1寄存器PCE和PS位，可控制奇偶校验使能和模式。启用奇偶校验后，会占用一个数据位填入奇偶校验位。假设数据字长设置为8bit，那么现在7bit是数据位，1bit是奇偶校验位。假设数据字长为9bit，那么8bit是数据位，1bit是就校验位。奇偶校验位填充在原MSB的位置。</p><h3 id="硬件流控制"><a href="#硬件流控制" class="headerlink" title="硬件流控制"></a>硬件流控制</h3><p>分别向 USART_CR3 寄存器中的 RTSE 位和 CTSE 位写入 1，可以分别使能 RTS 和 CTS 流  控制。</p><p>CTS：如果在发送数据时使  nCTS 输入无效，会在停止之前完成发送。如果使 nCTS 有效时数据已写入数据寄存器，则将延迟发送，直到 nCTS 有效。</p><p>RTS：只要 USART 接收器准备好接收新数据，便会将 nRTS 变  为有效（连接到低电平）。当接收寄存器已满时，会将 nRTS 变为无效，表明发送过程会在当前帧结束后停止。</p><h3 id="USART支持的中断事件"><a href="#USART支持的中断事件" class="headerlink" title="USART支持的中断事件"></a>USART支持的中断事件</h3><p>通过配置对应的使能寄存器，在以下事件产生时，可以触发USART中断。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206232412336.png" alt="image-20240206232412336"></p><h2 id="UART（不含USART-LIDAR-LIN）关键寄存器"><a href="#UART（不含USART-LIDAR-LIN）关键寄存器" class="headerlink" title="UART（不含USART,LIDAR,LIN）关键寄存器"></a>UART（不含USART,LIDAR,LIN）关键寄存器</h2><h3 id="状态寄存器（USART-SR）指示的状态"><a href="#状态寄存器（USART-SR）指示的状态" class="headerlink" title="状态寄存器（USART_SR）指示的状态"></a>状态寄存器（USART_SR）指示的状态</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206220951514.png" alt="image-20240206220951514"></p><ul><li><p><strong>位 9 CTS</strong>：CTS 标志 (CTS flag) </p><p>​    如果 CTSE 位置 1，当 nCTS 输入变换时，此位由硬件置 1。0：nCTS 状态线上未发生变化  1：nCTS 状态线上发生变化</p><p>​    通过软件将该位清零（通过向 该位中写入 0）。</p><p>​    如果 USART_CR3 寄存器中 CTSIE=1，则会生成中断。  （<em>注：F4系列UART4、5不适用</em>）</p></li><li><p><strong>位 7 TXE：</strong>发送数据寄存器为空 (Transmit data register empty) </p><p>​    当 TDR 寄存器的内容已传输到移位寄存器时，该位由硬件置 1。0：数据未传输到移位寄存器 1：数据传输到移位寄存器</p><p>​    如果 USART_CR1 寄存器  中 TXEIE 位 = 1，则会生成中断。</p><p>​    通过对 USART_DR 寄存器执行写入操作将该位清零。 </p></li><li><p><strong>位 6 TC</strong>：发送完成 (Transmission complete) </p><p>​    如果已完成对包含数据的帧的发送并且 TXE 置 1，则该位由硬件置 1。 0：传送未完成 1：传送已完成</p><p>​    如果 USART_CR1 寄存  器中 TCIE = 1，则会生成中断。</p><p>​    该位由软件序列清零（读取 USART_SR 寄存器，然后写入  USART_DR 寄存器）。TC 位也可以通过向该位写入‘0’来清零。建议仅在多缓冲区通信  时使用此清零序列。</p></li><li><p><strong>位 5 RXNE：</strong>读取数据寄存器不为空 (Read data register not empty) </p><p>​    当 RDR 移位寄存器的内容已传输到 USART_DR 寄存器时，该位由硬件置 1。0：未接收到数据 1：已准备好读取接收到的数据</p><p>​    如果  USART_CR1 寄存器中 RXNEIE = 1，则会生成中断。</p><p>​    通过对 USART_DR 寄存器执行读入  操作将该位清零。RXNE 标志也可以通过向该位写入零来清零。建议仅在多缓冲区通信时使  用此清零序列。 </p></li><li><p><strong>位 4 IDLE：</strong>检测到空闲线路 (IDLE line detected)</p><p>​     检测到空闲线路时，该位由硬件置 1。0：未检测到空闲线路 1：检测到空闲线路</p><p>​    如果 USART_CR1 寄存器中 IDLEIE = 1，则会生成中 断。</p><p>​    该位由软件序列清零（读入 USART_SR 寄存器，然后读入 USART_DR 寄存器）。 </p><p>​    <em>注意：直到 RXNE 位本身已置 1 时（即，当出现新的空闲线路时）IDLE 位才会被再次置 1。</em></p></li><li><p><strong>位 3 ORE：</strong>上溢错误 (Overrun error)</p><p>​     在 RXNE = 1 的情况下，当移位寄存器中当前正在接收的字准备好传输到 RDR 寄存器时，该  位由硬件置 1。 0：无上溢错误 1：检测到上溢错误</p><p>​    如果 USART_CR1 寄存器中 RXNEIE = 1，则会生成中断。该位由软件序列清零（读入 USART_SR 寄存器，然后读入 USART_DR 寄存器。</p><p>​    <em>注意：当该位置 1 时，RDR 寄存器的内容不会丢失，但移位寄存器会被覆盖。如果 EIE 位置 1，  则在进行多缓冲区通信时会对 ORE 标志生成一个中断。</em></p></li><li><p><strong>位 2 NF：</strong>检测到噪声标志 (Noise detected flag) </p><p>​    当在接收的帧上检测到噪声时，该位由硬件置 1。 0：未检测到噪声  1：检测到噪声</p><p>​    该位由软件序列清零（读入 USART_SR 寄  存器，然后读入 USART_DR 寄存器。</p><p>​     <em>注意：如果 EIE 位置 1，则在进行多缓冲区通信时，该位不会生成中断，因为该位出现的时间与  本身生成中断的 RXNE 位因 NF 标志而生成的时间相同。</em></p><p>​    <em>注意：当线路无噪声时，可以通过将 ONEBIT 位编程为 1 提高 USART 对偏差的容差来禁止  NF 标志</em></p></li><li><p><strong>位 1 FE：</strong>帧错误 (Framing error) </p><p>​    当检测到去同步化、过度的噪声或中断字符时，该位由硬件置 1。0：未检测到帧错误 1：检测到帧错误或中断字符</p><p>​    该位由软件序列清零（读入  USART_SR 寄存器，然后读入 USART_DR 寄存器）。</p><p>​    <em>注意：该位不会生成中断，因为该位出现的时间与本身生成中断的 RXNE 位出现的时间相同。  如果当前正在传输的字同时导致帧错误和上溢错误，则会传输该字，且仅有 ORE 位被  置 1。 如果 EIE 位置 1，则在进行多缓冲区通信时会对 FE 标志生成一个中断。</em></p></li><li><p><strong>位 0 PE：</strong>奇偶校验错误 (Parity error) </p><p>​    当在接收器模式下发生奇偶校验错误时，该位由硬件置 1。0：无奇偶校验错误  1：奇偶校验错误</p><p>​    该位由软件序列清零（读取状态寄存器，然后对 USART_DR 数据寄存器执行读或写访问。</p><p>​    将 PE 位清零前软件必须等待  RXNE 标志被置 1。  如果 USART_CR1 寄存器中 PEIE = 1，则会生成中断。 </p></li></ul><h3 id="数据寄存器-USART-DR"><a href="#数据寄存器-USART-DR" class="headerlink" title="数据寄存器(USART_DR)"></a>数据寄存器(USART_DR)</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206223126595.png" alt="image-20240206223126595"></p><p>该寄存器有32位，但<strong>[31:9]位保留，[8:0]为用于存放待发送或接受的9位或8位数据（9位或8位由设置的字长决定）</strong>这个寄存器其实由TDR和RDR两个寄存器组成，访问的是那个寄存器由读写操作决定。如果是写要发送的数据，则访问的是TDR寄存器。如果是要读已接收的数据，则访问的是RDR寄存器。</p><p>在使能奇偶校验位的情况下（USART_CR1 寄存器中的 PCE 位被置 1）进行发送时，由于  MSB 的写入值（位 7 或位 8，具体取决于数据长度）会被奇偶校验位所取代，因此该值不起任何作用。</p><h3 id="控制寄存器1-USART-CR1"><a href="#控制寄存器1-USART-CR1" class="headerlink" title="控制寄存器1(USART_CR1)"></a>控制寄存器1(USART_CR1)</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206223222420.png" alt="image-20240206223222420"></p><ul><li><p><strong>位 15 OVER8：过采样模式 (Oversampling mode)</strong>（F1系列没有这一位）</p><p>​    0：16 倍过采样;  1：8 倍过采样</p></li><li><p><strong>位 13 UE：USART 使能 (USART enable) </strong></p><p>​    0：禁止 USART 预分频器和输出 1：使能 USART</p><p>​    该位清零后，USART 预分频器和输出将停止，并会结束当前字节传输以降低功耗。</p><p>​    此位由软  件置 1 和清零。 </p></li><li><p><strong>位 12 M：字长 (Word length)</strong>。该位决定了字长。该位由软件置 1 或清零</p><p>​    0：8 数据位； 1：9 数据位</p><p>​    <em>注意：在数据传输（发送和接收）期间不得更改 M 位</em></p></li><li><p><strong>位 10 PCE：奇偶校验控制使能 (Parity control enable)</strong></p><p>​    0：禁止奇偶校验控制；1：使能奇偶校验控制</p></li><li><p><strong>位 9 PS：奇偶校验选择 (Parity selection)</strong></p><p>​    0：偶校验； 1：奇校验</p></li><li><p><strong>位 8 PEIE：奇偶校验错误中断使能 (PE interrupt enable)</strong></p><p>​    0：禁止中断； 1：当 USART_SR 寄存器中 PE=1 时，生成 USART 中断</p></li><li><p><strong>位 7 TXEIE：发送寄存器空中断使能 (TXE interrupt enable)</strong></p><p>​    0：禁止中断； 1：当 USART_SR 寄存器中 TXE=1 时(i.e., 当 TDR 寄存器的内容已传输到移位寄存器时)，生成 USART 中断</p></li><li><p><strong>位 6 TCIE：传送完成中断使能 (Transmission complete interrupt enable)</strong></p><p>​    0：禁止中断； 1：当 USART_SR 寄存器中 TC=1 时，生成 USART 中断</p></li><li><p><strong>位 3 TE：发送器使能 (Transmitter enable)</strong></p><p>​    0：禁止发送器；1：使能发送器</p></li><li><p><strong>位 2 RE：接收器使能 (Receiver enable)</strong></p><p>​    0：禁止接收器；1：使能接收器并开始搜索起始位</p></li></ul><h3 id="控制寄存器2-USART-CR2"><a href="#控制寄存器2-USART-CR2" class="headerlink" title="控制寄存器2(USART_CR2)"></a>控制寄存器2(USART_CR2)</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206224629997.png" alt="image-20240206224629997"></p><ul><li><p><strong>位 13:12 STOP：停止位配置 (STOP bit)</strong></p><p>​    00：1 个停止位</p><p>​    01：0.5 个停止位</p><p>​    10：2 个停止位</p><p>​    11：1.5 个停止位</p><p>​    <em>注意：0.5 个停止位和 1.5 个停止位不适用于 UART4 和 UART5</em></p></li></ul><h3 id="控制寄存器3-USART-CR3"><a href="#控制寄存器3-USART-CR3" class="headerlink" title="控制寄存器3(USART_CR3)"></a>控制寄存器3(USART_CR3)</h3><p>  <img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240206225157524.png" alt="image-20240206225157524"></p><ul><li><p><strong>位 11 ONEBIT：一个采样位方法使能 (One sample bit method enable)</strong></p><p>​    0：三个采样位方法 ；1：一个采样位方法（将禁止噪声检测标志 (NF)）</p></li><li><p><strong>位 10 CTSIE：CTS 中断使能 (CTS interrupt enable)</strong></p><p>​    0：禁止中断；1：当 USART_SR 寄存器中 CTS = 1 时，生成中断</p><p>​    <em>注意：该位不适用于 UART4 和 UART5。</em></p></li><li><p><strong>位 9 CTSE： CTS 使能 (CTS enable)</strong></p><p>​    0：禁止 CTS 硬件流控制；1：使能 CTS 模式，仅当 nCTS 输入有效 （连接到 0）时才发送数据。</p></li><li><p><strong>位 8 RTSE： RTS 使能 (RTS enable)</strong></p><p>​    0：禁止 RTS 硬件流控制；1：使能 RTS 中断，仅当接收缓冲区中有空间时才会请求数据。可以接收数据时使 nRTS 输出有效 （连接到 0）。</p></li><li><p><strong>位 7 DMAT： DMA 使能发送器 (DMA enable transmitter)</strong></p><p>​    1：针对发送使能 DMA 模式 ；0：针对发送禁止 DMA 模式</p></li><li><p><strong>位 6 DMAR： DMA 使能接收器 (DMA enable receiver)</strong></p><p>​    1：针对接收使能 DMA 模式 ；0：针对接收禁止 DMA 模式</p></li></ul><h2 id="常用功能对应寄存器总表"><a href="#常用功能对应寄存器总表" class="headerlink" title="常用功能对应寄存器总表"></a>常用功能对应寄存器总表</h2><div class="table-container"><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">寄存器</th><th style="text-align:center">配置</th><th style="text-align:center">功能</th><th style="text-align:center">寄存器</th><th style="text-align:center">配置</th></tr></thead><tbody><tr><td style="text-align:center">使能USART</td><td style="text-align:center">USART_CR1 UE（位13）</td><td style="text-align:center">0：失能；1：使能</td><td style="text-align:center">设置数据字长</td><td style="text-align:center">USART_CR1  M（位12）</td><td style="text-align:center">0：8数据位；1：9数据位</td></tr><tr><td style="text-align:center">设置波特率</td><td style="text-align:center">USART_BRR [15:4]&amp;[3:0]</td><td style="text-align:center">-</td><td style="text-align:center">奇偶校验使能</td><td style="text-align:center">USART_CR1 PCE（位10）</td><td style="text-align:center">0：失能；1：使能</td></tr><tr><td style="text-align:center">奇偶校验模式选择</td><td style="text-align:center">USART_CR1 PS（位9）</td><td style="text-align:center">0：偶校验；1：奇校验</td><td style="text-align:center">发送器使能</td><td style="text-align:center">USART_CR1 TE（位3）</td><td style="text-align:center">0：失能；1：使能</td></tr><tr><td style="text-align:center">接收器使能</td><td style="text-align:center">USART_CR1 RE（位2）</td><td style="text-align:center">0：失能；1：使能</td><td style="text-align:center">设置停止位</td><td style="text-align:center">USART_CR2 STOP（位[13:12]）</td><td style="text-align:center">00：1个;  01：0.5个；<br>10：2个；  11：1.5个</td></tr><tr><td style="text-align:center">DMA 使能发送器</td><td style="text-align:center">USART_CR3 DMAT（位7）</td><td style="text-align:center">0：失能；1：使能</td><td style="text-align:center">DMA 使能接收器</td><td style="text-align:center">USART_CR3 DMAR（位6）</td><td style="text-align:center">0：失能；1：使能</td></tr></tbody></table></div><h2 id="使用UART通信的配置步骤"><a href="#使用UART通信的配置步骤" class="headerlink" title="使用UART通信的配置步骤"></a>使用UART通信的配置步骤</h2><p>设置GPIO的复用模式</p><ul><li>设置为复用-推挽模式</li><li>无上拉、下拉</li><li>设置GPIO时钟（通常设置成高速）</li><li>通过配置GPIO-&gt;AFR寄存器，将USART1复用至GPIO</li></ul><p>设置NVIC（如果要使用中断串口，则需要设置NVIC）</p><ul><li>设置中断分组(AIRCR寄存器)</li><li>设置中断优先级(IPR寄存器[7:4])</li><li>使能对应的中断(ISER)</li></ul><p>设置串口通信相关参数</p><ul><li>使能串口挂在总线的时钟</li><li>对USART-&gt;BRR寄存器写入，设置波特率</li><li>通过对USART-&gt;CR1寄存器写入设置OVER8过采样模式。</li><li>通过对USART-&gt;CR2寄存器写入，设置STOP位长度</li><li>通过对USART-&gt;CR1寄存器写入，设置奇偶校验使能和模式</li><li>如需使用中断，则使能相关中断</li><li>如需使用DMA，则使能DMA</li></ul>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式中常用串行通信</title>
      <link href="/posts/aa8bcb7e.html"/>
      <url>/posts/aa8bcb7e.html</url>
      
        <content type="html"><![CDATA[<h1 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>USART：</strong>Universal Synchronous Asynchronous Receiver Transmitter，通用同步异步收发器</p><p><strong>UART：</strong>Universal Asynchronous Receiver Transmitte，通用异步收发器</p><p>USART算是UART的哥哥，比UART多一个同步通信特性。<strong>这两个都是串行通信协议</strong>。同步通信需要双方时钟频率一致，而异步通信无需时钟频率一致，通过设置固定的波特率+识别起始位和结束位来识别数据。其数字基带调制均使用NRZ（不归零）码。</p><p><strong>UART和USART最大都只能和一个主机同时通信</strong></p><h2 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h2><p>UART通信的波特率用于描述UART每秒传输的比特的速度(因为UART采用二进制信道Baud=bps)，其单位为bps(bit per sec)，常用的波特率有9600，115200等。以9600为例，每一个bit持续的Ts就是</p><script type="math/tex; mode=display">T_s=\frac{1}{9600}\approx104.2us</script><h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><p>UART规定数据空闲时，总线为高电平。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240205002705006.png" alt="image-20240205002705006" style="zoom:67%;" /></p><p>UART的帧格式为</p><ol><li>起始位：一个低电平信号，使用由高电平(空闲)朝低电平(起始位)跳变的边沿触发来检测。</li><li>先低后高的数据位，通常为8bit，不同的UART控制器支持的bit数不同，一般可以通过寄存器配置使用几位数据位。</li><li>校验位（可有可无），它有4种校验模式<ul><li>奇校验(ODD)：每个字节传送整个过程中bit为1的个数是奇数个（使用校验位调调控）</li><li>偶校验(EVEN)：每个字节传送整个过程中bit为1的个数是偶数个（使用校验位调调控）</li><li>固定校验位(STICK)： 固定在校验位置位逻辑高(MARK)或者逻辑低(SPACE)。</li><li>无校验位（NONE）：不发送校验位，直接停止。</li></ul></li><li>停止位，保持高电平，持续1位或1.5位或2位均可。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备之间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟的机会。停止位个数越多，数据传输越稳定，但是数据传输速度也越慢。</li></ol><h2 id="串口流控（CTS-RTS）"><a href="#串口流控（CTS-RTS）" class="headerlink" title="串口流控（CTS/RTS）"></a>串口流控（CTS/RTS）</h2><h3 id="串口流控介绍"><a href="#串口流控介绍" class="headerlink" title="串口流控介绍"></a>串口流控介绍</h3><p> 在两个设备正常通信时，由于处理速度不同，就存在这样一个问题，有的快，有的慢，在某些情况下，就可能导致丢失数据的情况。举个例子，假如用于接收的UART buffer已经满了，单片机还没来得及处理buffer内的数据，此时再继续发来新的数据，数据就会丢失。因此，使用串口流控来避免这种情况。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>RTS （Require ToSend，发送请求）为输出信号，用于指示本设备是否准备好接收数据，低电平有效，低电平说明本设备准备好接收数据。</p><p>CTS （Clear ToSend，发送允许）为输入信号，用于判断是否可以向对方发送数据，低电平有效，低电平说明可以向对方发送数据。</p><p>在两设备通信时，RTS和CTS的连接如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设备1RTS -------- 设备2CTS</span></span><br><span class="line"><span class="comment">设备1CTS -------- 设备2RTS</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><strong>SPI</strong> ：Serial Peripheral Interface (串行外设接口) 一种同步全双工串行通信协议。它的通信速度比I2C和UART都要快。SPI通信内只有一个主机，可支持多个从机。连接图如下</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240208213112276.png" alt="image-20240208213112276"></p><h3 id="SS或CS选择信号线："><a href="#SS或CS选择信号线：" class="headerlink" title="SS或CS选择信号线："></a>SS或CS选择信号线：</h3><p>通过给SS信号线来选择和哪一个从机通信。通常，高电平无效，低电平有效，但是有例外，要参考从机的芯片手册。</p><h3 id="SCK时钟信号线："><a href="#SCK时钟信号线：" class="headerlink" title="SCK时钟信号线："></a>SCK时钟信号线：</h3><p>由主设备产生的同步时钟。通常，MOSI和MISO上的数据信号可以在上升或下降时钟沿被采集，详情需要参考特定的芯片手册。一般来说，会有一个CKP或CKOL（时钟极性）参数，来决定时钟闲时电平高低。还有一个CKE或CPHL（时钟相位）参数来决定是第一次跳变时采集数据还是第二次。这二者共同决定数据在时钟上沿还是下沿被采集。</p><h3 id="MOSI："><a href="#MOSI：" class="headerlink" title="MOSI："></a>MOSI：</h3><p>Master Output，Slave Input，用于主机向从机发送信号</p><h3 id="MISO"><a href="#MISO" class="headerlink" title="MISO"></a>MISO</h3><p>Master Input，Slave Output，用于从机向主机发送信号</p><h2 id="时钟极性和相位的规定"><a href="#时钟极性和相位的规定" class="headerlink" title="时钟极性和相位的规定"></a>时钟极性和相位的规定</h2><p>时钟极性CPOL决定时钟在空闲时的电平高低。规定如下</p><ul><li>CPOL= 0：空闲时SCLK为低电平</li><li>CPOL= 1：空闲时SCLK为高电平</li></ul><p>CPHA表示采样时刻，也就是时钟相位。用于指明在第几次跳变时开始第一次采样。</p><ul><li><p>CPHA= 0：第一个时钟沿</p></li><li><p>CPHA= 1：第二个时钟沿</p></li></ul><h2 id="帧格式-1"><a href="#帧格式-1" class="headerlink" title="帧格式"></a>帧格式</h2><p>SPI通信在发送数据时<strong>不包含</strong>IIC中的地址码、应答信号或是UART中的起始位、停止位、校验位。它的<strong>数据是简单的纯数据位，没有应答，没有起始，没有结束</strong>。<strong>SPI的数据位先发高位(MSB)，再发低位(LSB)</strong>。高电平表示1，低电平表示0。在一个字节传输完成后，SPI可以紧跟着直接发送下一个字节，没有应答操作。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240208234346844.png" alt="image-20240208234346844"></p>]]></content>
      
      
      <categories>
          
          <category> 各种折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字基带通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32的中断(Register)</title>
      <link href="/posts/e95d61a1.html"/>
      <url>/posts/e95d61a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h1><p>不同于普通单片机的软中断（单一入口，软件识别flag）或硬中断（不同入口）会在多个中断同时发生时挂起后发生的，STM32支持对中断的优先级进行编程，在中断中触发中断。用于管理这一优先级的系统被称为NVIC。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240202143753489.png" alt="image-20240202143753489"></p><p>NVIC：Nested vectoredinterrupt controller，嵌套向量中断控制器，属于内核 (M3/4/7)。NVIC支持256个中断(16个内核中断+240个外部中断)，内核支持256个中断优先级。ST公司把256个优先级裁切为了<strong>16个优先级</strong>（所有系列都是如此）。对于F407xx系列芯片，有10个内核中断，82个外部中断。</p><p>STM32的中断优先级又分为几类：抢占式优先级、响应式优先级、自然优先级。<strong>在STM32中，优先级设置的数值越小，其优先级越高</strong></p><ul><li>抢占式优先级：当两个中断同时发生时，优先执行抢占式优先级高的中断，可形成中断嵌套(在执行某低优先级中断中被高优先级再次中断，先执行高的再回来继续执行低的)</li><li>响应式优先级：当两个同抢占式优先级的中断同时发生时，优先响应 响应式优先级 高的中断，另一个被挂起。响应式优先级无法打断执行过程中的中断。</li><li>自然优先级：由startup文件决定，当设置的抢占优先级和响应优先级相同时，先执行自然优先级高的中断。</li></ul><h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>中断向量表用于存放各个中断服务函数的首地址，每一个地址有4 byte （32位MCU）。在sartup文件中，中断向量表被定义在__Vectors中。CPU在上电后默认运行main，但一旦有中断触发，就调用对用的Handler。下方代码就是F4系列Startup文件中定义的10个内核中断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br></pre></td></tr></table></figure><p>如上代码定义的就是中断函数的接口，也就是说，不像其他单片机那样触发中断调用的函数是interrupt()，stm32不同的中断会调用不同的函数，这些函数的名字就是如上定义的这些，而非interrupt。</p><p>在startup文件中，调用中断向量表的Handler时，会天然地决定中断判定和执行的顺序，即自然优先级。例如复位(Reset)被为-3，是自然优先级最高的中断。NMI被定义为-2，硬件失效(HardFault)定义为-1。</p><h2 id="NVIC相关寄存器"><a href="#NVIC相关寄存器" class="headerlink" title="NVIC相关寄存器"></a>NVIC相关寄存器</h2><h3 id="ISER寄存器"><a href="#ISER寄存器" class="headerlink" title="ISER寄存器"></a>ISER寄存器</h3><p>ISER：Interrupt Set Enable Registers，用于控制中断使能。Cortex内核中ISER有 ISER0～ISER7 共8个，每个32位。ISER的每一个位控制一个中断，所以每一个中断使能寄存器可以控制 32 个中断，共256个。<strong>不过，由于 STM32F407 的 可屏蔽中断只有 82 个，所以对我们来说，实际用到的 ISER 只有 3 个（ISER[0]～ISER[2]）。</strong> 不同芯片ISER寄存器对应控制的中断不同，需参考芯片手册。<strong>要对某个中断使能，只需朝ISER中对应位写入1即可</strong></p><p>因为其内存地址连续，所以可以直接定义uint_32类型数组ISER[n]来控制。</p><h3 id="ICER寄存器"><a href="#ICER寄存器" class="headerlink" title="ICER寄存器"></a>ICER寄存器</h3><p>与ISER相对， ICER(Interrupt Clear Enable Registers)，用于中断失能控制。<strong>要对某个中断失能，只需朝ICER中对应位写入1即可</strong></p><h3 id="IPR寄存器"><a href="#IPR寄存器" class="headerlink" title="IPR寄存器"></a>IPR寄存器</h3><p> Cortex-M4 内核可屏蔽中断有240个，每一个有256档优先级可以设置(需要8bit 寄存器进行配置)，因此内核规定IPR有60个，每个32bit （$60\times32bit=240\times8bit$）。在编程时，同样定义为数组来处理。<strong>由于 STM32F407 只用到了 Cortex-M4 的 82 个可屏蔽中断，故数组也只用了其中的元素 IP[0]～IP[81]。STM32F407 也并没有用到 IP 数组元素中的全部 8bit 来配置中断优先级，而是只使用了其中的高4位（对应16个优先级）</strong></p><h3 id="中断优先级的分组和AIRCR寄存器"><a href="#中断优先级的分组和AIRCR寄存器" class="headerlink" title="中断优先级的分组和AIRCR寄存器"></a>中断优先级的分组和AIRCR寄存器</h3><p>前面我们已知，STM32中中断优先级有16个，也就是需要IPR中的4个bit来表示，这16个又可以被分为抢占优先级和响应优先级。<strong>那么这4bit哪些用于控制响应优先级，哪些用于控制抢占优先级呢？这是通过设置AICRC寄存器实现的。</strong></p><p>AICRC： Application Interrupt and Reset Control Register，即应用程序中断及复位控制寄存器。该寄存器有32位，功能定义如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240203183209909.png" alt="image-20240203183209909"></p><p>可以看到，第8-10位被用于中断优先级的分组，这个分组有五种，用于控制PIR中4个bit控制抢占优先级还是响应优先级。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240202150050747.png" alt="image-20240202150050747"></p><p>bit8-10的值和对应的组别如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240203182224262.png" alt="image-20240203182224262" style="zoom: 50%;" /></p><h3 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h3><p>总的来说，要启用某一个中断，需要<strong>对NVIC进行的配置步骤如下：</strong></p><ul><li>设置中断分组(AIRCR寄存器)</li><li>设置中断优先级(IPR寄存器[7:4])</li><li>使能中断(ISER)</li></ul><hr><h1 id="外部中断-事件-控制器EXTI"><a href="#外部中断-事件-控制器EXTI" class="headerlink" title="外部中断(事件)控制器EXTI"></a>外部中断(事件)控制器EXTI</h1><p>EXTI：External Interrupt/Event Controller。EXTI线含边缘检测器，可以接受外部的中断信号，来触发中断或是事件。各系列芯片的支持的EXTI线如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240203203004878.png" alt="image-20240203203004878"></p><p><strong>每条EXTI线都可以单独配置：1.选择其触发中断或是事件，2.选择触发方式(上沿、下沿、双边沿)、3.软件触发、4.设置使能/失能、5.存储中断挂起状态</strong></p><p>对于F4系列芯片，有23个EXTI线。详情需查询对应芯片的手册。</p><p><strong>中断和事件的区别</strong></p><ul><li><p>中断：要进入NVIC，触发后由CPU调用对应的中断函数来执行中断程序</p></li><li><p>事件：不进入NVIC，本质上就是一个触发信号，是用来触发特定的外设模块或核心本身(唤醒)仅用于内部硬件自动控制。事件不需要软件参与，所以响应速度也更快。事件可作为中断的触发源。</p></li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240204162635225.png" alt="image-20240204162635225"></p><p>整个电路框图如上图所示。输入线接受外部信号，通过配置EXTI_RTSR和EXTI_FTSR来设置边沿检测电路对上沿或下沿响应。EXTI_SWIER允许我们通过程序控制就可以启动中断/事件线，也就是在某些时候让中断或事件以软件作为触发源，而非外部输入的硬件信号。后续是事件屏蔽器，用于enable和disable是否产生事件脉冲。同时EXTI_PR会存储有中断请求发生，这里就是作中断flag。当EXTI_IMR被使能时，中断信号进入NVIC，触发中断。</p><h2 id="EXTI相关寄存器"><a href="#EXTI相关寄存器" class="headerlink" title="EXTI相关寄存器"></a>EXTI相关寄存器</h2><h3 id="EXTI-IMR（中断屏蔽寄存器）"><a href="#EXTI-IMR（中断屏蔽寄存器）" class="headerlink" title="EXTI_IMR（中断屏蔽寄存器）"></a>EXTI_IMR（中断屏蔽寄存器）</h3><p>该寄存器总共有32位，但因为F4系列只有23个EXTI线，所以只有0-22位被使用。<strong>该寄存器写1位enable中断，写0为disable；复位值为全0，即所有中断disable</strong>。bit0对应EXTI0，bit1对应EXTI1，以此类推。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240204162947090.png" alt="image-20240204162947090"></p><h3 id="EXTI-EMR（事件屏蔽寄存器）"><a href="#EXTI-EMR（事件屏蔽寄存器）" class="headerlink" title="EXTI_EMR（事件屏蔽寄存器）"></a>EXTI_EMR（事件屏蔽寄存器）</h3><p>该寄存器同EXTI_IMR，复位全0，写0屏蔽，写1使能。该寄存器用于控制是否产生事件脉冲。</p><h3 id="EXTI-RTSR（上沿触发选择寄存器）"><a href="#EXTI-RTSR（上沿触发选择寄存器）" class="headerlink" title="EXTI_RTSR（上沿触发选择寄存器）"></a>EXTI_RTSR（上沿触发选择寄存器）</h3><p>该寄存器也是32位，但仅有23个bit被使用。bit0对应EXTI0，bit1对应EXTI1，以此类推。<strong>写0表示禁止上沿触发，写1表示使能上沿触发，复位值全0</strong></p><h3 id="EXTI-FTSR-下降沿触发选择寄存器"><a href="#EXTI-FTSR-下降沿触发选择寄存器" class="headerlink" title="EXTI_FTSR(下降沿触发选择寄存器)"></a>EXTI_FTSR(下降沿触发选择寄存器)</h3><p>同上沿触发寄存器。如果上沿下沿触发都被enable，那么任意边沿都可唤起中断。如果在设置极性的同时产生了中断，那么中断请求会被忽略。</p><h3 id="EXTI-PR-（挂起请求寄存器）"><a href="#EXTI-PR-（挂起请求寄存器）" class="headerlink" title="EXTI_PR （挂起请求寄存器）"></a>EXTI_PR （挂起请求寄存器）</h3><p>当在外部中断线上发生了选择的边沿事件，该位被置“1”。在此位中<strong>写入“1”可以清除它（注意这里不是写0）</strong>，在改变边沿检测的极性时，该位也会自动被清除。</p><h3 id="EXTI-SWIER（软件中断寄存器）"><a href="#EXTI-SWIER（软件中断寄存器）" class="headerlink" title="EXTI_SWIER（软件中断寄存器）"></a>EXTI_SWIER（软件中断寄存器）</h3><p>当该位为“0”时，写“1”将设置 EXTI_PR 中相应的挂起位。如果在 EXTI_IMR 和 EXTI_EMR  中允许产生该中断，则产生中断请求。通过清除 EXTI_PR（挂起寄存器） 的对应位（写入“1”），可以清除该位为“0”，即处理中断flag时自动清除该位。</p><h2 id="EXTI和IO口的映射"><a href="#EXTI和IO口的映射" class="headerlink" title="EXTI和IO口的映射"></a>EXTI和IO口的映射</h2><h3 id="AFIO（功能复用寄存器）配置-对于F1单片机"><a href="#AFIO（功能复用寄存器）配置-对于F1单片机" class="headerlink" title="AFIO（功能复用寄存器）配置(对于F1单片机)"></a>AFIO（功能复用寄存器）配置(对于F1单片机)</h3><p>对F1系列单片机，此处不做过多介绍，参考芯片手册即可。</p><h3 id="SYSCFG（系统配置寄存器）配置（对于F4-F7-H7单片机）"><a href="#SYSCFG（系统配置寄存器）配置（对于F4-F7-H7单片机）" class="headerlink" title="SYSCFG（系统配置寄存器）配置（对于F4/F7/H7单片机）"></a>SYSCFG（系统配置寄存器）配置（对于F4/F7/H7单片机）</h3><p>EXTIn线可以映射到GPIOn上，例如EXTI0这条线，就可以映射至所有端口(如PA，PB等)的GPIO0这个口,EXTI15这条线，可映射至所有端口的GPIO15。一条EXTI线同一时间仅可以和一个GPIO相连。</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240204170054912.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240204171730480.png" alt="image-20240204171730480" style="zoom:78%;" /></center></td>        </tr></table><p>在SYSCFG寄存器组中，有SYSCFG_EXTICR1~4 4组用于配置EXTI映射的寄存器，用于控制EXTI线和哪一个端口相连。，每组寄存器都是32位，但仅使用16位，使用的16位又被分为4组（每4bit一组），一组控制一条EXTI线。可映射至GPIO的EXTI线共有16条，4组SYSCFG_EXTICR寄存器，每组控制4条，刚好与16条契合。下图展示SYSCFG_EXTICR1寄存器的bit构成，2-4同理：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240204171226010.png" alt="image-20240204171226010"></p><p>4bit和端口的值对应关系如下(对于F4)：</p><div class="table-container"><table><thead><tr><th style="text-align:center">数值（Binary）</th><th style="text-align:center">对应端口</th><th style="text-align:center">数值（Binary）</th><th style="text-align:center">对应端口</th></tr></thead><tbody><tr><td style="text-align:center">0000</td><td style="text-align:center">PA</td><td style="text-align:center">0101</td><td style="text-align:center">PF</td></tr><tr><td style="text-align:center">0001</td><td style="text-align:center">PB</td><td style="text-align:center">0110</td><td style="text-align:center">PG</td></tr><tr><td style="text-align:center">0010</td><td style="text-align:center">PC</td><td style="text-align:center">0111</td><td style="text-align:center">PH</td></tr><tr><td style="text-align:center">0011</td><td style="text-align:center">PD</td><td style="text-align:center">1000</td><td style="text-align:center">PI</td></tr><tr><td style="text-align:center">0100</td><td style="text-align:center">PE</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table></div><p>设置寄存器前，需要对SYSCFG时钟进行使能(<em>HAL库提供宏：__HAL_RCC_SYSCFG_CLK_ENABLE()</em>)</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><p>要在STM32芯片上使用某一中断功能，需要遵循如下步骤配置</p><ul><li>使能GPIO时钟</li><li>设置GPIO模式（输入、是否上拉等），如果使用片上外设中断，可跳过这一步</li><li>使能SYSCFG/APIO时钟，如果使用片上外设中断，可跳过这一步</li><li>设置EXTI和GPIO的映射关系（设置APIO或STYSCFG寄存器），如果使用片上外设中断，可跳过这一步</li><li>设置边沿触发模式(RTSR,FTSR)、enbale中断(IMR/EMR)，如果使用片上外设中断，可跳过这一步</li><li>（对于其他片上外设，中断会直接进入NVIC，无需配置EXTI相关设置）</li><li>设置NVIC（包含优先级分组，优先级，使能中断，详见NVIC配置步骤）</li><li>编写中断服务函数（服务函数内需清除中断标志）</li></ul><h2 id="服务函数注意事项"><a href="#服务函数注意事项" class="headerlink" title="服务函数注意事项"></a>服务函数注意事项</h2><p>在STM32中，EXTI0-4有5个独立的中断服务函数；EXTI9-5共用一个中断服务函数；EXTI15-10共用一个中断服务函数。也就是总共有7个中断服务函数。</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅思阅读</title>
      <link href="/posts/28500.html"/>
      <url>/posts/28500.html</url>
      
        <content type="html"><![CDATA[<h1 id="分数对应表"><a href="#分数对应表" class="headerlink" title="分数对应表"></a>分数对应表</h1><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/v2-e2a43c0d7e956a2a28630da1706b6867_1440w.webp" alt="img"></p><p>通常来说，中国的学生主要靠阅读和听力拉分，小分目标6.5-7需要阅读冲8。也就是最多错4-5分的阅读题。</p><h1 id="整体题目顺序度"><a href="#整体题目顺序度" class="headerlink" title="整体题目顺序度"></a>整体题目顺序度</h1><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/v2-fae07171ce009b09a4ca9012531114d2_1440w.webp" alt="img"></p><hr><h1 id="题型介绍"><a href="#题型介绍" class="headerlink" title="题型介绍"></a>题型介绍</h1><h2 id="单词填空题"><a href="#单词填空题" class="headerlink" title="单词填空题"></a>单词填空题</h2><ul><li>难度：低</li><li>顺序/乱序：顺序</li><li>做题步骤：<ol><li>读第一个和第二个空，勾画定位词</li><li>在文中遇到定位词即做对应的空(通常密集出现)</li><li>填完第一个空之后，读第三个空，带着第二个空和第三个空的定位词做题</li><li>以此类推</li></ol></li></ul><p>单词填空题一般分为段落(原文摘要)填空和填图题。这两类题目一般要求<strong>直接从原文选择规定词数以内的单词填入(一般不超过3个词)</strong>。常考同义替换</p><h2 id="判断题-T-F-NG"><a href="#判断题-T-F-NG" class="headerlink" title="判断题(T/F/NG)"></a>判断题(T/F/NG)</h2><ul><li>难度：低</li><li>顺序/乱序：顺序</li><li>做题步骤：<ol><li>读第一个和第二个选项，勾画定位词，考点词</li><li>在文中遇到定位词即做对应的选项(通常密集出现)</li><li>填完第一个选项之后，读第三个选项，带着第二个选项和第三个选项的定位词做题</li><li>以此类推</li></ol></li></ul><p>根据标题内容是否在原文中证实或呈现选择 True, False, Not Given. 判断题注意不要带入自己的主管臆测，一定要专注于原文是否提及、是否明确阐述。</p><p>考点词：体现出题目核心思想的词，这个词决定了是T还是F，increasing/ decreasing之类的</p><p><strong>一般来说，3个选项的判断题不一定出现NG，四个选项的含有NG。</strong></p><p><strong>连续的T或F不会超过3个</strong></p><h2 id="段落中心思想题-给段落选Heading"><a href="#段落中心思想题-给段落选Heading" class="headerlink" title="段落中心思想题(给段落选Heading)"></a>段落中心思想题(给段落选Heading)</h2><ul><li><p>难度：中等</p></li><li><p>顺序/乱序：乱序</p></li><li><p>做题步骤：</p><ol><li><p>通读题干，勾定位词</p></li><li><p>找段落主旨句和核心词汇，正确答案常常是主旨句的改写</p></li><li><p>对比主旨句和选项，寻找同义替换。<strong>这里需要注意同义改写后的表述和原文不应当有信息差</strong></p></li><li><p>确定某段话的答案后，将它从选项列表中划去</p></li><li><p>读一段选一题，不确定的可以选择了但不划去</p></li></ol></li></ul><p>这类题目要求给阅读文章中的每一段选个小标题，概括这段话的段落大意、中心思想、主旨。<strong>在文段中定位时，通常看首句，第二句，末句。当定位没有出现在这里面时，重点关注段中转折</strong></p><p>如果选项中有相似的词语或有链接的句子，那注意这些要么是干扰项，要么是</p><h2 id="信息匹配（Matching）"><a href="#信息匹配（Matching）" class="headerlink" title="信息匹配（Matching）"></a>信息匹配（Matching）</h2><ul><li>难度：中等</li><li>顺序/乱序：乱序</li><li><p>做题步骤：</p><ol><li>通读题干和选项，勾定位词，一般选项内的人名、国家、地区等比较好定位</li><li>读文章时遇到定位词就做对应的题目</li></ol></li></ul><p>Matching（匹配题）是雅思阅读最常考的题型之一，每次考试都至少有一组，很多时候会达到两组甚至更多。匹配题一般要求匹配谁干了什么，什么地区怎么样了，什么国家干了什么，谁有什么观点之类的，选项一般是人名、地名或者其他名词，比较好定位。</p><p><strong>若出现NB，也不一定会要复选，但是大部分需要复选</strong></p><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul><li>难度：中等</li><li>顺序/乱序：基本顺序，局部可能乱序</li><li>做题步骤：</li><li><p>做题步骤：</p><ol><li></li><li></li></ol></li></ul><p>每个题目都是一个特殊问句，要求根据原文作出回答。</p><p><strong>所有的答案都不用大写，专有名词除外。</strong></p><p><strong>绝大部分的答案来自原文原词，极少一部分需要自己写答案。</strong> </p><p>答案涉及数字的，一般要有简单的四则运算，且涉及钱币的，在数字前一定要有货币符号，在数字后可能会有单位。题目问 how many/how much/what proportion/what is the cost 时，答案一般不会直接是原文中出现的数字，而要涉及到简单的四则运算，通常是加减法</p><h2 id="带选择的填空"><a href="#带选择的填空" class="headerlink" title="带选择的填空"></a>带选择的填空</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240125141227927.png" alt="image-20240125141227927"></p><ul><li>难度：中等</li><li>顺序/乱序：基本顺序，局部可能乱序</li><li>做题步骤：</li></ul><p>这类题可以根据名词单复数、转折关系、因果关联，来辅助做题。</p><h2 id="单项选择"><a href="#单项选择" class="headerlink" title="单项选择"></a>单项选择</h2><ul><li>难度：中等</li><li>顺序/乱序：选项内部没有顺序，题目与题目之间有顺序</li><li>做题步骤：</li></ul><h2 id="多项选择"><a href="#多项选择" class="headerlink" title="多项选择"></a>多项选择</h2><p>没有顺序但答案集中</p><hr><h1 id="做题技巧"><a href="#做题技巧" class="headerlink" title="做题技巧"></a>做题技巧</h1><ul><li>遇到例子的时候，例子通常是为了论证例子前面的观点，所以观点一般在前面，仅有少数在例子之后</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 雅思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32——HAL库</title>
      <link href="/posts/82419430.html"/>
      <url>/posts/82419430.html</url>
      
        <content type="html"><![CDATA[<h1 id="GPIO控制"><a href="#GPIO控制" class="headerlink" title="GPIO控制"></a>GPIO控制</h1><h2 id="GPIO口寄存器的封装和总线时钟"><a href="#GPIO口寄存器的封装和总线时钟" class="headerlink" title="GPIO口寄存器的封装和总线时钟"></a>GPIO口寄存器的封装和总线时钟</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GPIO_TypeDef 结构体如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> MODER;    <span class="comment">/*!&lt;模式寄存器,                Address offset: 0x00      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OTYPER;   <span class="comment">/*!&lt;输出数据类型寄存器,         Address offset: 0x04      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OSPEEDR;  <span class="comment">/*!&lt;输出速度寄存器,             Address offset: 0x08      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PUPDR;    <span class="comment">/*!&lt;上拉下拉电阻选择寄存器,      Address offset: 0x0C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> IDR;      <span class="comment">/*!&lt;输入数据寄存器,             Address offset: 0x10      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ODR;      <span class="comment">/*!&lt;输出数据寄存器,             Address offset: 0x14      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> BSRR;     <span class="comment">/*!&lt; GPIO port bit set/reset register,      Address offset: 0x18      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> LCKR;     <span class="comment">/*!&lt;设置锁寄存器,               Address offset: 0x1C      */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AFR[<span class="number">2</span>];   <span class="comment">/*!&lt;复用功能寄存器,             Address offset: 0x20-0x24 */</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"><span class="comment">//GPIO_InitTypeDef 结构体如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> Pin; <span class="comment">//引脚</span></span><br><span class="line">  <span class="type">uint32_t</span> Mode; <span class="comment">//引脚模式(推挽 or 开漏 等)</span></span><br><span class="line">  <span class="type">uint32_t</span> Pull; <span class="comment">//上拉电阻使能情况</span></span><br><span class="line">  <span class="type">uint32_t</span> Speed; <span class="comment">//引脚响应速度</span></span><br><span class="line">  <span class="type">uint32_t</span> Alternate; <span class="comment">//引脚复用情况</span></span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO所在总线(AHB1)时钟使能</span></span><br><span class="line">__HAL_RCC_GPIOx_CLK_ENABLE();  <span class="comment">/*HAL库使用宏来进行使能, GPIOx可以是任意一组GPIO,但是对于f4系列芯片而言，他们挂载的总线一致，所以都是对AHB1总线时钟进行使能*/</span></span><br><span class="line"><span class="comment">/*宏内配置如下*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAL_RCC_GPIOA_CLK_ENABLE()   do &#123; \</span></span><br><span class="line"><span class="meta">                                        __IO uint32_t tmpreg = 0x00U; \</span></span><br><span class="line"><span class="meta">                                        SET_BIT(RCC-&gt;AHB1ENR, RCC_AHB1ENR_GPIOAEN);\</span></span><br><span class="line"><span class="meta">                                        <span class="comment">/* Delay after an RCC peripheral clock enabling */</span> \</span></span><br><span class="line"><span class="meta">                                        tmpreg = READ_BIT(RCC-&gt;AHB1ENR, RCC_AHB1ENR_GPIOAEN);\</span></span><br><span class="line"><span class="meta">                                        UNUSED(tmpreg); \</span></span><br><span class="line"><span class="meta">                                          &#125; while(0U)</span></span><br></pre></td></tr></table></figure><hr><h2 id="GPIO的初始化"><a href="#GPIO的初始化" class="headerlink" title="GPIO的初始化"></a>GPIO的初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_Init</span><span class="params">(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)</span></span><br></pre></td></tr></table></figure><p>其中GPIOx可以直接传入GPIOA, GPIOB等等，这些已经被预编译成了以引脚初始寄存器位置开始的GPIO_TypeDef 类型的结构体，上面一节有介绍。GPIO_InitTypeDef用于控制引脚的各个功能和状态配置。</p><p>GPIO_InitTypeDef成员的值定义如下：</p><h3 id="Pin"><a href="#Pin" class="headerlink" title="Pin:"></a>Pin:</h3><p>Pin控制要对那一个引脚操控， 可传GPIO_PIN_x，x可以为0-15，ALL，MASK三种。</p><ul><li><p>GPIO_PIN_0 如果将x设置为0-15，则传入的是GPIO的寄存器位置（例如，GPIO3对应的寄存器地址0B0000,0100）。多个引脚时，可以用或运算同时使能，如GPIO_PIN_0 | GPIO_PIN_1。</p></li><li><p>GPIO_PIN_ALL 对应的是0xFFFF，也就是将16个PIN全部操作</p></li><li><p><em>GPIO_PIN_MASK是给断言机制判断传入参数是否合法使用的，<strong>不作为用户调用参数传入</strong></em>。断言机制代码如下：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_GPIO_PIN(__PIN__)        ((((__PIN__) &amp; GPIO_PIN_MASK) != (uint32_t)0x00) &amp;&amp;\</span></span><br><span class="line"><span class="meta">                                     (((__PIN__) &amp; ~GPIO_PIN_MASK) == (uint32_t)0x00))</span></span><br></pre></td></tr></table></figure><p>  这样IS_GPIO_PIN 宏定义就会在输入非GPIO合法值时返回0，触发断言机制，程序报错并定位。</p><h3 id="Mode："><a href="#Mode：" class="headerlink" title="Mode："></a>Mode：</h3><p>Mode控制GPIO的输入、输出模式，有如下选择：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_INPUT                <span class="comment">//浮动输入：上拉</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_OUTPUT_PP            <span class="comment">//推挽输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_OUTPUT_OD            <span class="comment">//开漏输出</span></span></span><br><span class="line"><span class="comment">//复用PP/OD输出模式，与PP/OD出模式很是相似。只是输出的高低电平的来源不同，由ODR寄存器控制，而是用片内外设模块的复用功能输出来决定的。</span></span><br><span class="line"><span class="comment">//复用开漏输出功能有：（TX1,MOSI,MISO.SCK.SS）</span></span><br><span class="line"><span class="comment">//复用推挽输出功能有：（I2C的SCL,SDA）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_AF_PP                 <span class="comment">//复用推挽输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_AF_OD                 <span class="comment">//复用开漏输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_ANALOG                <span class="comment">//此时GPIO处于analog模式。可作ADC转换通道,可做比较器、DAC等模拟外设的复用通道</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_RISING             <span class="comment">//具有上升沿触发检测的外部中断模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_FALLING            <span class="comment">//具有下降沿触发检测的外部中断模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_RISING_FALLING     <span class="comment">//上升沿和下降沿均触发的外部中断模式</span></span></span><br><span class="line"><span class="comment">//下面几个对应的是&quot;事件&quot;,RISING,FALLING等含义同中断.在这里事件可以唤醒休眠状态(WFE)的MCU,但是不会产生&quot;中断事件&quot;,也就是说不会执行中断处理函数,也就说不需要清除外设中断挂起位或 NVIC. 使用GPIO&quot;事件&quot;来启动AD转换也是可以的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_RISING                   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_FALLING                  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_RISING_FALLING            </span></span><br></pre></td></tr></table></figure><h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull:"></a>Pull:</h3><p>PULL控制上拉、下拉电阻使能情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_NOPULL        ((uint32_t)0x00000000)   <span class="comment">//上拉下拉都不使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_PULLUP        ((uint32_t)0x00000001)   <span class="comment">//使能上拉电阻</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_PULLDOWN      ((uint32_t)0x00000002)   <span class="comment">//使能下拉电阻</span></span></span><br></pre></td></tr></table></figure><h3 id="Speed"><a href="#Speed" class="headerlink" title="Speed"></a>Speed</h3><p>控制GPIO时钟的速度，对应也就是GPIO的响应速度.ST公司给了四种不同的相对速度(相对MCU极限速度而言)可供选择。<strong>对于不同的MCU，这里define的值是不一样的，对应的频率也是不一样的，需要参考芯片手册。对于F4系列，其定义如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_SPEED_FREQ_LOW        <span class="comment">//2 MHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_SPEED_FREQ_MEDIUM     <span class="comment">//12.5 MHz to 50 MHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_SPEED_FREQ_HIGH       <span class="comment">//25 MHz to 100 MHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_SPEED_FREQ_VERY_HIGH  <span class="comment">//50 MHz to 200 MHz</span></span></span><br></pre></td></tr></table></figure><h3 id="Alternate"><a href="#Alternate" class="headerlink" title="Alternate"></a>Alternate</h3><p>控制引脚的复用情况，不同的MCU引脚可复用功能不同，需要参看<em>stm32f4xx_hal_gpio_ex.h</em> 头文件内的定义。例如F407系列，AF8引脚就可以配置成GPIO_AF8_UART4、GPIO_AF8_UART5、GPIO_AF8_USART6三种。详情需要参考不同芯片的手册。</p><hr><h2 id="GPIO的去初始化"><a href="#GPIO的去初始化" class="headerlink" title="GPIO的去初始化"></a>GPIO的去初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_DeInit</span><span class="params">(GPIO_TypeDef  *GPIOx, <span class="type">uint32_t</span> GPIO_Pin)</span></span><br></pre></td></tr></table></figure><p>这个函数用于将已初始化的GPIO恢复至默认值</p><ul><li>GPIOx 同init。</li><li>GPIO_Pin传入要初始化第几个即可，多个Pin使用或运算合并，同Init。</li></ul><hr><h2 id="读取引脚电平"><a href="#读取引脚电平" class="headerlink" title="读取引脚电平"></a>读取引脚电平</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_PinState <span class="title function_">HAL_GPIO_ReadPin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span></span><br></pre></td></tr></table></figure><p>用于读取GPIO的电平，读取的是IDR寄存器内对应的值。其返回值类型为GPIO_PinState，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GPIO_PIN_RESET = <span class="number">0</span>,</span><br><span class="line">  GPIO_PIN_SET</span><br><span class="line">&#125;GPIO_PinState;</span><br></pre></td></tr></table></figure><p>也就是RESET=0，SET=1。</p><hr><h2 id="写引脚电平"><a href="#写引脚电平" class="headerlink" title="写引脚电平"></a>写引脚电平</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_WritePin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, GPIO_PinState PinState)</span></span><br></pre></td></tr></table></figure><p>用于写入GPIO某一引脚的电平。GPIOx, GPIO_Pin同上，PinState有 GPIO_PIN_RESET 和  GPIO_PIN_SET 两种</p><hr><h2 id="反转引脚电平"><a href="#反转引脚电平" class="headerlink" title="反转引脚电平"></a>反转引脚电平</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_TogglePin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span></span><br></pre></td></tr></table></figure><p>这个函数的作用是讲某个引脚输出的值反转</p><p>这个函数的实现原理是使用BSRR寄存器，如果直接操作ODR寄存器，有被中断等(IRQ)打断的风险，而通过BSRR和BRR去改变管脚状态是不会被中断打断的，即不需要关闭中断。</p><p>BSRR的<strong>低 16bits 是set操作</strong>，而<strong>高16bits是 reset 操作</strong>。这个函数的实现原理如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOx-&gt;BSRR = ((odr &amp; GPIO_Pin) &lt;&lt; GPIO_NUMBER) | (~odr &amp; GPIO_Pin);</span><br><span class="line"><span class="comment">//GPIO_NUMBER 在F4中被定义为16，因为一组GPIO有16Pin</span></span><br></pre></td></tr></table></figure><p>这个语句首先将要操作PIN的ODR值放进Reset里面，然后再将这个值取反放进Set里面，如果此时这个Pin是1，那么对应寄存器的Reset就会是1，Set是0，反之亦然。这样就达到了对某一个PIN反相的效果。</p><hr><h2 id="锁定端口电平"><a href="#锁定端口电平" class="headerlink" title="锁定端口电平"></a>锁定端口电平</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_GPIO_LockPin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span></span><br></pre></td></tr></table></figure><p>这个函数通过对LCKR寄存器进行配置，对某一个引脚输出的值进行锁定，一般用得比较少。其返回值是锁定是否成功，成功返回HAL_OK (0)，失败返回HAL_ERROR (1)</p><hr><h2 id="GPIO触发的中断处理函数"><a href="#GPIO触发的中断处理函数" class="headerlink" title="GPIO触发的中断处理函数"></a>GPIO触发的中断处理函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* EXTI line interrupt detected */</span></span><br><span class="line">  <span class="keyword">if</span>(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</span><br><span class="line">    HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;UNUSED(GPIO_Pin);&#125;</span><br></pre></td></tr></table></figure><p>这个函数在中断入口的位置被自动调用。函数首先会清除中断Flag，然后调用HAL_GPIO_EXTI_Callback函数，这个回调函数就是中断要干什么。在HAL库内，有一个HAL_GPIO_EXTI_Callback已经被定义，但是使用__weak修饰，且函数只是返回一个void值，这里的意思是当用户自己定义这个中断处理函数时HAL库内这个会被disable，这个函数存在在这个只是为了防止gcc报错，<strong>且用户不可直接修改HAL库内这个callback</strong>，需要自己重新定义一个新的。</p><p><strong>也就是说，我们需要自定义一个void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) 的函数，来写入中断操作的内容。</strong></p><hr><h1 id="NVIC、EXTI和中断"><a href="#NVIC、EXTI和中断" class="headerlink" title="NVIC、EXTI和中断"></a>NVIC、EXTI和中断</h1><p>代码在stm32f4xx_hal_cortex.c中</p><h2 id="设置中断分组-NVIC"><a href="#设置中断分组-NVIC" class="headerlink" title="设置中断分组(NVIC)"></a>设置中断分组(NVIC)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_NVIC_SetPriorityGrouping</span><span class="params">(<span class="type">uint32_t</span> PriorityGroup)</span></span><br></pre></td></tr></table></figure><p>其中参数如下：</p><ul><li>NVIC_PRIORITYGROUP_0</li><li>NVIC_PRIORITYGROUP_1</li><li>NVIC_PRIORITYGROUP_2</li><li>NVIC_PRIORITYGROUP_3</li><li>NVIC_PRIORITYGROUP_4</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240202150050747.png" alt="image-20240202150050747"></p><h2 id="设置中断优先级-NVIC"><a href="#设置中断优先级-NVIC" class="headerlink" title="设置中断优先级(NVIC)"></a>设置中断优先级(NVIC)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_NVIC_SetPriority</span><span class="params">(IRQn_Type IRQn, <span class="type">uint32_t</span> PreemptPriority, <span class="type">uint32_t</span> SubPriority)</span></span><br></pre></td></tr></table></figure><p>其中IRQn表示要设置的中断，PreemptPriority表示抢占优先级，SubPriority表示响应优先级</p><h3 id="IRQn-中断号"><a href="#IRQn-中断号" class="headerlink" title="IRQn(中断号)"></a>IRQn(中断号)</h3><p>中断号用于指明控制哪一个中断，代码定义和对应中断如下：</p><p>它存储的是偏移地址，即相对于外部中断第一个中断寄存器WWDG_IRQn(0x0000,0040)地址的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/******  Cortex-M4 Processor Exceptions Numbers ****************************************************************/</span></span><br><span class="line">  NonMaskableInt_IRQn         = <span class="number">-14</span>,    <span class="comment">/*!&lt; 2 Non Maskable Interrupt                                          */</span></span><br><span class="line">  MemoryManagement_IRQn       = <span class="number">-12</span>,    <span class="comment">/*!&lt; 4 Cortex-M4 Memory Management Interrupt                           */</span></span><br><span class="line">  BusFault_IRQn               = <span class="number">-11</span>,    <span class="comment">/*!&lt; 5 Cortex-M4 Bus Fault Interrupt                                   */</span></span><br><span class="line">  UsageFault_IRQn             = <span class="number">-10</span>,    <span class="comment">/*!&lt; 6 Cortex-M4 Usage Fault Interrupt                                 */</span></span><br><span class="line">  SVCall_IRQn                 = <span class="number">-5</span>,     <span class="comment">/*!&lt; 11 Cortex-M4 SV Call Interrupt                                    */</span></span><br><span class="line">  DebugMonitor_IRQn           = <span class="number">-4</span>,     <span class="comment">/*!&lt; 12 Cortex-M4 Debug Monitor Interrupt                              */</span></span><br><span class="line">  PendSV_IRQn                 = <span class="number">-2</span>,     <span class="comment">/*!&lt; 14 Cortex-M4 Pend SV Interrupt                                    */</span></span><br><span class="line">  SysTick_IRQn                = <span class="number">-1</span>,     <span class="comment">/*!&lt; 15 Cortex-M4 System Tick Interrupt                                */</span></span><br><span class="line">  <span class="comment">/******  STM32 specific Interrupt Numbers **********************************************************************/</span></span><br><span class="line">  WWDG_IRQn                   = <span class="number">0</span>,      <span class="comment">/*!&lt; Window WatchDog Interrupt                                         */</span></span><br><span class="line">  PVD_IRQn                    = <span class="number">1</span>,      <span class="comment">/*!&lt; PVD through EXTI Line detection Interrupt                         */</span></span><br><span class="line">  TAMP_STAMP_IRQn             = <span class="number">2</span>,      <span class="comment">/*!&lt; Tamper and TimeStamp interrupts through the EXTI line             */</span></span><br><span class="line">  RTC_WKUP_IRQn               = <span class="number">3</span>,      <span class="comment">/*!&lt; RTC Wakeup interrupt through the EXTI line                        */</span></span><br><span class="line">  FLASH_IRQn                  = <span class="number">4</span>,      <span class="comment">/*!&lt; FLASH global Interrupt                                            */</span></span><br><span class="line">  RCC_IRQn                    = <span class="number">5</span>,      <span class="comment">/*!&lt; RCC global Interrupt                                              */</span></span><br><span class="line">  EXTI0_IRQn                  = <span class="number">6</span>,      <span class="comment">/*!&lt; EXTI Line0 Interrupt                                              */</span></span><br><span class="line">  EXTI1_IRQn                  = <span class="number">7</span>,      <span class="comment">/*!&lt; EXTI Line1 Interrupt                                              */</span></span><br><span class="line">  EXTI2_IRQn                  = <span class="number">8</span>,      <span class="comment">/*!&lt; EXTI Line2 Interrupt                                              */</span></span><br><span class="line">  EXTI3_IRQn                  = <span class="number">9</span>,      <span class="comment">/*!&lt; EXTI Line3 Interrupt                                              */</span></span><br><span class="line">  EXTI4_IRQn                  = <span class="number">10</span>,     <span class="comment">/*!&lt; EXTI Line4 Interrupt                                              */</span></span><br><span class="line">  DMA1_Stream0_IRQn           = <span class="number">11</span>,     <span class="comment">/*!&lt; DMA1 Stream 0 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream1_IRQn           = <span class="number">12</span>,     <span class="comment">/*!&lt; DMA1 Stream 1 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream2_IRQn           = <span class="number">13</span>,     <span class="comment">/*!&lt; DMA1 Stream 2 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream3_IRQn           = <span class="number">14</span>,     <span class="comment">/*!&lt; DMA1 Stream 3 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream4_IRQn           = <span class="number">15</span>,     <span class="comment">/*!&lt; DMA1 Stream 4 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream5_IRQn           = <span class="number">16</span>,     <span class="comment">/*!&lt; DMA1 Stream 5 global Interrupt                                    */</span></span><br><span class="line">  DMA1_Stream6_IRQn           = <span class="number">17</span>,     <span class="comment">/*!&lt; DMA1 Stream 6 global Interrupt                                    */</span></span><br><span class="line">  ADC_IRQn                    = <span class="number">18</span>,     <span class="comment">/*!&lt; ADC1, ADC2 and ADC3 global Interrupts                             */</span></span><br><span class="line">  CAN1_TX_IRQn                = <span class="number">19</span>,     <span class="comment">/*!&lt; CAN1 TX Interrupt                                                 */</span></span><br><span class="line">  CAN1_RX0_IRQn               = <span class="number">20</span>,     <span class="comment">/*!&lt; CAN1 RX0 Interrupt                                                */</span></span><br><span class="line">  CAN1_RX1_IRQn               = <span class="number">21</span>,     <span class="comment">/*!&lt; CAN1 RX1 Interrupt                                                */</span></span><br><span class="line">  CAN1_SCE_IRQn               = <span class="number">22</span>,     <span class="comment">/*!&lt; CAN1 SCE Interrupt                                                */</span></span><br><span class="line">  EXTI9_5_IRQn                = <span class="number">23</span>,     <span class="comment">/*!&lt; External Line[9:5] Interrupts                                     */</span></span><br><span class="line">  TIM1_BRK_TIM9_IRQn          = <span class="number">24</span>,     <span class="comment">/*!&lt; TIM1 Break interrupt and TIM9 global interrupt                    */</span></span><br><span class="line">  TIM1_UP_TIM10_IRQn          = <span class="number">25</span>,     <span class="comment">/*!&lt; TIM1 Update Interrupt and TIM10 global interrupt                  */</span></span><br><span class="line">  TIM1_TRG_COM_TIM11_IRQn     = <span class="number">26</span>,     <span class="comment">/*!&lt; TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */</span></span><br><span class="line">  TIM1_CC_IRQn                = <span class="number">27</span>,     <span class="comment">/*!&lt; TIM1 Capture Compare Interrupt                                    */</span></span><br><span class="line">  TIM2_IRQn                   = <span class="number">28</span>,     <span class="comment">/*!&lt; TIM2 global Interrupt                                             */</span></span><br><span class="line">  TIM3_IRQn                   = <span class="number">29</span>,     <span class="comment">/*!&lt; TIM3 global Interrupt                                             */</span></span><br><span class="line">  TIM4_IRQn                   = <span class="number">30</span>,     <span class="comment">/*!&lt; TIM4 global Interrupt                                             */</span></span><br><span class="line">  I2C1_EV_IRQn                = <span class="number">31</span>,     <span class="comment">/*!&lt; I2C1 Event Interrupt                                              */</span></span><br><span class="line">  I2C1_ER_IRQn                = <span class="number">32</span>,     <span class="comment">/*!&lt; I2C1 Error Interrupt                                              */</span></span><br><span class="line">  I2C2_EV_IRQn                = <span class="number">33</span>,     <span class="comment">/*!&lt; I2C2 Event Interrupt                                              */</span></span><br><span class="line">  I2C2_ER_IRQn                = <span class="number">34</span>,     <span class="comment">/*!&lt; I2C2 Error Interrupt                                              */</span></span><br><span class="line">  SPI1_IRQn                   = <span class="number">35</span>,     <span class="comment">/*!&lt; SPI1 global Interrupt                                             */</span></span><br><span class="line">  SPI2_IRQn                   = <span class="number">36</span>,     <span class="comment">/*!&lt; SPI2 global Interrupt                                             */</span></span><br><span class="line">  USART1_IRQn                 = <span class="number">37</span>,     <span class="comment">/*!&lt; USART1 global Interrupt                                           */</span></span><br><span class="line">  USART2_IRQn                 = <span class="number">38</span>,     <span class="comment">/*!&lt; USART2 global Interrupt                                           */</span></span><br><span class="line">  USART3_IRQn                 = <span class="number">39</span>,     <span class="comment">/*!&lt; USART3 global Interrupt                                           */</span></span><br><span class="line">  EXTI15_10_IRQn              = <span class="number">40</span>,     <span class="comment">/*!&lt; External Line[15:10] Interrupts                                   */</span></span><br><span class="line">  RTC_Alarm_IRQn              = <span class="number">41</span>,     <span class="comment">/*!&lt; RTC Alarm (A and B) through EXTI Line Interrupt                   */</span></span><br><span class="line">  OTG_FS_WKUP_IRQn            = <span class="number">42</span>,     <span class="comment">/*!&lt; USB OTG FS Wakeup through EXTI line interrupt                     */</span></span><br><span class="line">  TIM8_BRK_TIM12_IRQn         = <span class="number">43</span>,     <span class="comment">/*!&lt; TIM8 Break Interrupt and TIM12 global interrupt                   */</span></span><br><span class="line">  TIM8_UP_TIM13_IRQn          = <span class="number">44</span>,     <span class="comment">/*!&lt; TIM8 Update Interrupt and TIM13 global interrupt                  */</span></span><br><span class="line">  TIM8_TRG_COM_TIM14_IRQn     = <span class="number">45</span>,     <span class="comment">/*!&lt; TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */</span></span><br><span class="line">  TIM8_CC_IRQn                = <span class="number">46</span>,     <span class="comment">/*!&lt; TIM8 Capture Compare global interrupt                             */</span></span><br><span class="line">  DMA1_Stream7_IRQn           = <span class="number">47</span>,     <span class="comment">/*!&lt; DMA1 Stream7 Interrupt                                            */</span></span><br><span class="line">  FSMC_IRQn                   = <span class="number">48</span>,     <span class="comment">/*!&lt; FSMC global Interrupt                                             */</span></span><br><span class="line">  SDIO_IRQn                   = <span class="number">49</span>,     <span class="comment">/*!&lt; SDIO global Interrupt                                             */</span></span><br><span class="line">  TIM5_IRQn                   = <span class="number">50</span>,     <span class="comment">/*!&lt; TIM5 global Interrupt                                             */</span></span><br><span class="line">  SPI3_IRQn                   = <span class="number">51</span>,     <span class="comment">/*!&lt; SPI3 global Interrupt                                             */</span></span><br><span class="line">  UART4_IRQn                  = <span class="number">52</span>,     <span class="comment">/*!&lt; UART4 global Interrupt                                            */</span></span><br><span class="line">  UART5_IRQn                  = <span class="number">53</span>,     <span class="comment">/*!&lt; UART5 global Interrupt                                            */</span></span><br><span class="line">  TIM6_DAC_IRQn               = <span class="number">54</span>,     <span class="comment">/*!&lt; TIM6 global and DAC1&amp;2 underrun error  interrupts                 */</span></span><br><span class="line">  TIM7_IRQn                   = <span class="number">55</span>,     <span class="comment">/*!&lt; TIM7 global interrupt                                             */</span></span><br><span class="line">  DMA2_Stream0_IRQn           = <span class="number">56</span>,     <span class="comment">/*!&lt; DMA2 Stream 0 global Interrupt                                    */</span></span><br><span class="line">  DMA2_Stream1_IRQn           = <span class="number">57</span>,     <span class="comment">/*!&lt; DMA2 Stream 1 global Interrupt                                    */</span></span><br><span class="line">  DMA2_Stream2_IRQn           = <span class="number">58</span>,     <span class="comment">/*!&lt; DMA2 Stream 2 global Interrupt                                    */</span></span><br><span class="line">  DMA2_Stream3_IRQn           = <span class="number">59</span>,     <span class="comment">/*!&lt; DMA2 Stream 3 global Interrupt                                    */</span></span><br><span class="line">  DMA2_Stream4_IRQn           = <span class="number">60</span>,     <span class="comment">/*!&lt; DMA2 Stream 4 global Interrupt                                    */</span></span><br><span class="line">  ETH_IRQn                    = <span class="number">61</span>,     <span class="comment">/*!&lt; Ethernet global Interrupt                                         */</span></span><br><span class="line">  ETH_WKUP_IRQn               = <span class="number">62</span>,     <span class="comment">/*!&lt; Ethernet Wakeup through EXTI line Interrupt                       */</span></span><br><span class="line">  CAN2_TX_IRQn                = <span class="number">63</span>,     <span class="comment">/*!&lt; CAN2 TX Interrupt                                                 */</span></span><br><span class="line">  CAN2_RX0_IRQn               = <span class="number">64</span>,     <span class="comment">/*!&lt; CAN2 RX0 Interrupt                                                */</span></span><br><span class="line">  CAN2_RX1_IRQn               = <span class="number">65</span>,     <span class="comment">/*!&lt; CAN2 RX1 Interrupt                                                */</span></span><br><span class="line">  CAN2_SCE_IRQn               = <span class="number">66</span>,     <span class="comment">/*!&lt; CAN2 SCE Interrupt                                                */</span></span><br><span class="line">  OTG_FS_IRQn                 = <span class="number">67</span>,     <span class="comment">/*!&lt; USB OTG FS global Interrupt                                       */</span></span><br><span class="line">  DMA2_Stream5_IRQn           = <span class="number">68</span>,     <span class="comment">/*!&lt; DMA2 Stream 5 global interrupt                                    */</span></span><br><span class="line">  DMA2_Stream6_IRQn           = <span class="number">69</span>,     <span class="comment">/*!&lt; DMA2 Stream 6 global int   terrupt                                    */</span></span><br><span class="line">  USART6_IRQn                 = <span class="number">71</span>,     <span class="comment">/*!&lt; USART6 global interrupt                                           */</span></span><br><span class="line">  I2C3_EV_IRQn                = <span class="number">72</span>,     <span class="comment">/*!&lt; I2C3 event interrupt                                              */</span></span><br><span class="line">  I2C3_ER_IRQn                = <span class="number">73</span>,     <span class="comment">/*!&lt; I2C3 error interrupt                                              */</span></span><br><span class="line">  OTG_HS_EP1_OUT_IRQn         = <span class="number">74</span>,     <span class="comment">/*!&lt; USB OTG HS End Point 1 Out global interrupt                       */</span></span><br><span class="line">  OTG_HS_EP1_IN_IRQn          = <span class="number">75</span>,     <span class="comment">/*!&lt; USB OTG HS End Point 1 In global interrupt                        */</span></span><br><span class="line">  OTG_HS_WKUP_IRQn            = <span class="number">76</span>,     <span class="comment">/*!&lt; USB OTG HS Wakeup through EXTI interrupt                          */</span></span><br><span class="line">  OTG_HS_IRQn                 = <span class="number">77</span>,     <span class="comment">/*!&lt; USB OTG HS global interrupt                                       */</span></span><br><span class="line">  DCMI_IRQn                   = <span class="number">78</span>,     <span class="comment">/*!&lt; DCMI global interrupt                                             */</span></span><br><span class="line">  RNG_IRQn                    = <span class="number">80</span>,     <span class="comment">/*!&lt; RNG global Interrupt                                              */</span></span><br><span class="line">  FPU_IRQn                    = <span class="number">81</span>      <span class="comment">/*!&lt; FPU global interrupt                                               */</span></span><br><span class="line">&#125; IRQn_Type;</span><br></pre></td></tr></table></figure><h3 id="PreemptPriority（抢占优先级）和SubPriority-响应优先级"><a href="#PreemptPriority（抢占优先级）和SubPriority-响应优先级" class="headerlink" title="PreemptPriority（抢占优先级）和SubPriority (响应优先级)"></a>PreemptPriority（抢占优先级）和SubPriority (响应优先级)</h3><p>可输入0-15（十进制），对应抢占优先级/响应优先级的大小，数字越小优先级越高。朝IPR寄存器内写入，优先级的输入范围随Group设置范围变化。</p><h2 id="使能-失能中断-NVIC"><a href="#使能-失能中断-NVIC" class="headerlink" title="使能/失能中断(NVIC)"></a>使能/失能中断(NVIC)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_NVIC_EnableIRQ</span><span class="params">(IRQn_Type IRQn)</span> <span class="comment">//使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_NVIC_DisableIRQ</span><span class="params">(IRQn_Type IRQn)</span> <span class="comment">//失能</span></span><br></pre></td></tr></table></figure><p>其输入参数IRQn(中断号) 同上。用于指明控制哪一个中断。</p><h2 id="配置EXTI模式和映射IO"><a href="#配置EXTI模式和映射IO" class="headerlink" title="配置EXTI模式和映射IO"></a>配置EXTI模式和映射IO</h2><p>在HAL库中，配置EXTI寄存器上沿/下沿触发，映射IO，都通过在引脚初始化时，设置GPIO_InitTypeDef.mode实现。可设置参数如下，详见GPIO章节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_RISING             <span class="comment">//具有上升沿触发检测的外部中断模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_FALLING            <span class="comment">//具有下降沿触发检测的外部中断模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_IT_RISING_FALLING     <span class="comment">//上升沿和下降沿均触发的外部中断模式</span></span></span><br><span class="line"><span class="comment">//下面几个对应的是&quot;事件&quot;,RISING,FALLING等含义同中断.在这里事件可以唤醒休眠状态(WFE)的MCU,但是不会产生&quot;中断事件&quot;,也就是说不会执行中断处理函数,也就说不需要清除外设中断挂起位或 NVIC. 使用GPIO&quot;事件&quot;来启动AD转换也是可以的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_RISING                   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_FALLING                  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GPIO_MODE_EVT_RISING_FALLING        </span></span><br></pre></td></tr></table></figure><h2 id="清除中断flag"><a href="#清除中断flag" class="headerlink" title="清除中断flag"></a>清除中断flag</h2><p>HAL库中中断flag会在调用回调函数前自动通过宏清除，宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI-&gt;PR = (__EXTI_LINE__))</span></span><br></pre></td></tr></table></figure><p>这个过程无需人为干预</p><h2 id="中断Handler"><a href="#中断Handler" class="headerlink" title="中断Handler"></a>中断Handler</h2><p>在进入中断时，我们需要编写中断执行的函数，STM32不同于大部分单片机中断函数都叫interrupt，它不同的中断会调用各自不同的函数。这些中断函数在startup文件中被定义，称之为“中断向量表”。以下是定义代码和对应的名称。<strong>在使用CubeMX初始化代码时，这些Handler会被定义在stm32fxxx_it.c文件中，可以直接在it.c文件中对中断进行编辑。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler                   ; Window WatchDog                                        </span><br><span class="line">                DCD     PVD_IRQHandler                    ; PVD through EXTI Line detection                        </span><br><span class="line">                DCD     TAMP_STAMP_IRQHandler             ; Tamper and TimeStamps through the EXTI line            </span><br><span class="line">                DCD     RTC_WKUP_IRQHandler               ; RTC Wakeup through the EXTI line                       </span><br><span class="line">                DCD     FLASH_IRQHandler                  ; FLASH                                           </span><br><span class="line">                DCD     RCC_IRQHandler                    ; RCC                                             </span><br><span class="line">                DCD     EXTI0_IRQHandler                  ; EXTI Line0                                             </span><br><span class="line">                DCD     EXTI1_IRQHandler                  ; EXTI Line1                                             </span><br><span class="line">                DCD     EXTI2_IRQHandler                  ; EXTI Line2                                             </span><br><span class="line">                DCD     EXTI3_IRQHandler                  ; EXTI Line3                                             </span><br><span class="line">                DCD     EXTI4_IRQHandler                  ; EXTI Line4                                             </span><br><span class="line">                DCD     DMA1_Stream0_IRQHandler           ; DMA1 Stream 0                                   </span><br><span class="line">                DCD     DMA1_Stream1_IRQHandler           ; DMA1 Stream 1                                   </span><br><span class="line">                DCD     DMA1_Stream2_IRQHandler           ; DMA1 Stream 2                                   </span><br><span class="line">                DCD     DMA1_Stream3_IRQHandler           ; DMA1 Stream 3                                   </span><br><span class="line">                DCD     DMA1_Stream4_IRQHandler           ; DMA1 Stream 4                                   </span><br><span class="line">                DCD     DMA1_Stream5_IRQHandler           ; DMA1 Stream 5                                   </span><br><span class="line">                DCD     DMA1_Stream6_IRQHandler           ; DMA1 Stream 6                                   </span><br><span class="line">                DCD     ADC_IRQHandler                    ; ADC1, ADC2 and ADC3s                            </span><br><span class="line">                DCD     CAN1_TX_IRQHandler                ; CAN1 TX                                                </span><br><span class="line">                DCD     CAN1_RX0_IRQHandler               ; CAN1 RX0                                               </span><br><span class="line">                DCD     CAN1_RX1_IRQHandler               ; CAN1 RX1                                               </span><br><span class="line">                DCD     CAN1_SCE_IRQHandler               ; CAN1 SCE                                               </span><br><span class="line">                DCD     EXTI9_5_IRQHandler                ; External Line[9:5]s                                    </span><br><span class="line">                DCD     TIM1_BRK_TIM9_IRQHandler          ; TIM1 Break and TIM9                   </span><br><span class="line">                DCD     TIM1_UP_TIM10_IRQHandler          ; TIM1 Update and TIM10                 </span><br><span class="line">                DCD     TIM1_TRG_COM_TIM11_IRQHandler     ; TIM1 Trigger and Commutation and TIM11</span><br><span class="line">                DCD     TIM1_CC_IRQHandler                ; TIM1 Capture Compare                                   </span><br><span class="line">                DCD     TIM2_IRQHandler                   ; TIM2                                            </span><br><span class="line">                DCD     TIM3_IRQHandler                   ; TIM3                                            </span><br><span class="line">                DCD     TIM4_IRQHandler                   ; TIM4                                            </span><br><span class="line">                DCD     I2C1_EV_IRQHandler                ; I2C1 Event                                             </span><br><span class="line">                DCD     I2C1_ER_IRQHandler                ; I2C1 Error                                             </span><br><span class="line">                DCD     I2C2_EV_IRQHandler                ; I2C2 Event                                             </span><br><span class="line">                DCD     I2C2_ER_IRQHandler                ; I2C2 Error                                               </span><br><span class="line">                DCD     SPI1_IRQHandler                   ; SPI1                                            </span><br><span class="line">                DCD     SPI2_IRQHandler                   ; SPI2                                            </span><br><span class="line">                DCD     USART1_IRQHandler                 ; USART1                                          </span><br><span class="line">                DCD     USART2_IRQHandler                 ; USART2                                          </span><br><span class="line">                DCD     USART3_IRQHandler                 ; USART3                                          </span><br><span class="line">                DCD     EXTI15_10_IRQHandler              ; External Line[15:10]s                                  </span><br><span class="line">                DCD     RTC_Alarm_IRQHandler              ; RTC Alarm (A and B) through EXTI Line                  </span><br><span class="line">                DCD     OTG_FS_WKUP_IRQHandler            ; USB OTG FS Wakeup through EXTI line                        </span><br><span class="line">                DCD     TIM8_BRK_TIM12_IRQHandler         ; TIM8 Break and TIM12                  </span><br><span class="line">                DCD     TIM8_UP_TIM13_IRQHandler          ; TIM8 Update and TIM13                 </span><br><span class="line">                DCD     TIM8_TRG_COM_TIM14_IRQHandler     ; TIM8 Trigger and Commutation and TIM14</span><br><span class="line">                DCD     TIM8_CC_IRQHandler                ; TIM8 Capture Compare                                   </span><br><span class="line">                DCD     DMA1_Stream7_IRQHandler           ; DMA1 Stream7                                           </span><br><span class="line">                DCD     FMC_IRQHandler                    ; FMC                                             </span><br><span class="line">                DCD     SDIO_IRQHandler                   ; SDIO                                            </span><br><span class="line">                DCD     TIM5_IRQHandler                   ; TIM5                                            </span><br><span class="line">                DCD     SPI3_IRQHandler                   ; SPI3                                            </span><br><span class="line">                DCD     UART4_IRQHandler                  ; UART4                                           </span><br><span class="line">                DCD     UART5_IRQHandler                  ; UART5                                           </span><br><span class="line">                DCD     TIM6_DAC_IRQHandler               ; TIM6 and DAC1&amp;2 underrun errors                   </span><br><span class="line">                DCD     TIM7_IRQHandler                   ; TIM7                   </span><br><span class="line">                DCD     DMA2_Stream0_IRQHandler           ; DMA2 Stream 0                                   </span><br><span class="line">                DCD     DMA2_Stream1_IRQHandler           ; DMA2 Stream 1                                   </span><br><span class="line">                DCD     DMA2_Stream2_IRQHandler           ; DMA2 Stream 2                                   </span><br><span class="line">                DCD     DMA2_Stream3_IRQHandler           ; DMA2 Stream 3                                   </span><br><span class="line">                DCD     DMA2_Stream4_IRQHandler           ; DMA2 Stream 4                                   </span><br><span class="line">                DCD     ETH_IRQHandler                    ; Ethernet                                        </span><br><span class="line">                DCD     ETH_WKUP_IRQHandler               ; Ethernet Wakeup through EXTI line                      </span><br><span class="line">                DCD     CAN2_TX_IRQHandler                ; CAN2 TX                                                </span><br><span class="line">                DCD     CAN2_RX0_IRQHandler               ; CAN2 RX0                                               </span><br><span class="line">                DCD     CAN2_RX1_IRQHandler               ; CAN2 RX1                                               </span><br><span class="line">                DCD     CAN2_SCE_IRQHandler               ; CAN2 SCE                                               </span><br><span class="line">                DCD     OTG_FS_IRQHandler                 ; USB OTG FS                                      </span><br><span class="line">                DCD     DMA2_Stream5_IRQHandler           ; DMA2 Stream 5                                   </span><br><span class="line">                DCD     DMA2_Stream6_IRQHandler           ; DMA2 Stream 6                                   </span><br><span class="line">                DCD     DMA2_Stream7_IRQHandler           ; DMA2 Stream 7                                   </span><br><span class="line">                DCD     USART6_IRQHandler                 ; USART6                                           </span><br><span class="line">                DCD     I2C3_EV_IRQHandler                ; I2C3 event                                             </span><br><span class="line">                DCD     I2C3_ER_IRQHandler                ; I2C3 error                                             </span><br><span class="line">                DCD     OTG_HS_EP1_OUT_IRQHandler         ; USB OTG HS End Point 1 Out                      </span><br><span class="line">                DCD     OTG_HS_EP1_IN_IRQHandler          ; USB OTG HS End Point 1 In                       </span><br><span class="line">                DCD     OTG_HS_WKUP_IRQHandler            ; USB OTG HS Wakeup through EXTI                         </span><br><span class="line">                DCD     OTG_HS_IRQHandler                 ; USB OTG HS                                      </span><br><span class="line">                DCD     DCMI_IRQHandler                   ; DCMI  </span><br><span class="line">                DCD     0                                 ; Reserved                              </span><br><span class="line">                DCD     HASH_RNG_IRQHandler               ; Hash and Rng</span><br><span class="line">                DCD     FPU_IRQHandler                    ; FPU</span><br><span class="line">                </span><br><span class="line">                                         </span><br><span class="line">__Vectors_End</span><br></pre></td></tr></table></figure><h2 id="HAL库的中断处理流程"><a href="#HAL库的中断处理流程" class="headerlink" title="HAL库的中断处理流程"></a>HAL库的中断处理流程</h2><h3 id="CubeMX-HAL工程中断初始化的流程"><a href="#CubeMX-HAL工程中断初始化的流程" class="headerlink" title="CubeMX+HAL工程中断初始化的流程"></a>CubeMX+HAL工程中断初始化的流程</h3><p>如果我们采用寄存器编程，以初始化映射至IO的EXTI中断为例，那么需要经历以下步骤：</p><ol><li>使能GPIO时钟和NVIC、EXTI总线时钟</li><li>设置GPIO模式（输入、是否上拉等）</li><li>设置EXTI和GPIO的映射关系（设置APIO或STYSCFG寄存器）</li><li>设置边沿触发模式(RTSR,FTSR)、enbale中断(IMR/EMR)</li><li>设置NVIC分组模式</li><li>设置NVIC优先级模式</li><li>使能NVIC对应中断</li></ol><p>在使用CubeMX生成的工程中，1,2,3,4都是在MX_GPIO_Init()函数内完成。如果是映射至IO的EXTI的中断，那么MX_GPIO_Init()函数内还会完成相应中断的优先级设置和使能，也就是6,7；如果是其他中断，那么在相应外设的init函数中也会完成优先级设置和使能。</p><p>鉴于NVIC的分组模式一般不会更改，因此NVIC的分组在一开始就被设置，CubeMX+HAL库生成的工程会在HAL_Init()函数中完成。</p><p>main函数中，会依次调用这三个函数来完成整个系统的初始化，其中便囊括了中断的初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_Init();<span class="comment">//完成步骤5，设置分组</span></span><br><span class="line">SystemClock_Config();</span><br><span class="line">MX_GPIO_Init();<span class="comment">//完成步骤1.2.3.4.6.7;初始化GPIO并配置和映射EXTI线，然后使能NVIC对应的中断</span></span><br></pre></td></tr></table></figure><h3 id="中断调用函数的流程"><a href="#中断调用函数的流程" class="headerlink" title="中断调用函数的流程"></a>中断调用函数的流程</h3><p>在中断被触发时，STM32首先会调用Handler，也就是下方 <em>中断Handler</em> 小节内介绍的这些。这些Handler的内容存储在stm32fxxx_it.c。Hander函数内首先调用公共中断函数，来实现清除中断标志等，然后调用回调函数执行处理的内容。这里面用户可直接编辑Handler函数的内容，来决定其调用哪些公共函数，也可自行重新定义Callback函数的内容，来编写中断处理程序。</p><p>这个流程的函数伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xxx_IRQHandler</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//public interrupt functions</span></span><br><span class="line">xxx_public_INT_Func(specific parameters);<span class="comment">//e.g. HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">xxx_public_INT_Func</span><span class="params">(parameters)</span>&#123;</span><br><span class="line">public_funcs(parameters);<span class="comment">// e.g. __HAL_GPIO_EXTI_CLEAR_IT(GOIO_Pin)</span></span><br><span class="line">Callback_func(parameters);<span class="comment">// e.g. HAL_GPIO_EXTI_Callback(GPIO_Pin)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Callback_func</span><span class="params">(parameters)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parameters == xx)&#123;</span><br><span class="line">        <span class="comment">//do sth</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameters == yy)&#123;</span><br><span class="line">        <span class="comment">//do sth</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//interrupt Processing code, written by user</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，callback函数是弱定义的，例如EXTI的回调函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br></pre></td></tr></table></figure><p><strong>因此，在HAL库中使用中断时，用户只需要自定重新定义回调函数部分，找到不同中断Handler调用的回调函数，在回调函数部分写入中断处理的代码即可。</strong>通常来说，用户只需要自己重新定义Callback fucntion，并根据传入的参数不同，使用if编写不同中断源的处理程序即可。但是再多个外设共用一个回调函数时，这些if可能需要写非常多，这样不便于管理，因此直接把处理函数写在其自己的驱动文件内，然后在xxx_IRQHandler() 内调用即可。</p><hr><h1 id="UART串口"><a href="#UART串口" class="headerlink" title="UART串口"></a>UART串口</h1><h2 id="huart句柄"><a href="#huart句柄" class="headerlink" title="huart句柄"></a>huart句柄</h2><p>这是一个调用和uart相关HAL库接口时，需要传入的参数，用于说明数据从哪个串口进来，串口的基本设置参数。这个参数被称为”handel”，也就是huart中h的来源，可以理解为握着uart1的handel，就可以控制和操作uart1的意思。其源代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">UART_HandleTypeDef</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  USART_TypeDef                 *Instance;        <span class="comment">/*!&lt; UART 控制寄存器基地址        */</span></span><br><span class="line">  UART_InitTypeDef              Init;             <span class="comment">/*!&lt; UART 串口初始化数据类型      */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>                 *pTxBuffPtr;      <span class="comment">/*!&lt; 发送buffer地址 */</span></span><br><span class="line">  <span class="type">uint16_t</span>                      TxXferSize;       <span class="comment">/*!&lt; 发送数据个数             */</span></span><br><span class="line">  __IO <span class="type">uint16_t</span>                 TxXferCount;      <span class="comment">/*!&lt; 发送数据计数器           */</span></span><br><span class="line">  <span class="type">uint8_t</span>                       *pRxBuffPtr;      <span class="comment">/*!&lt; 接收buffer地址*/</span></span><br><span class="line">  <span class="type">uint16_t</span>                      RxXferSize;       <span class="comment">/*!&lt; 接收数据个数            */</span></span><br><span class="line">  __IO <span class="type">uint16_t</span>                 RxXferCount;      <span class="comment">/*!&lt; 接收数据计数器           */</span></span><br><span class="line">  __IO HAL_UART_RxTypeTypeDef ReceptionType;      <span class="comment">/*!&lt; Type of ongoing reception          */</span></span><br><span class="line">  __IO HAL_UART_RxEventTypeTypeDef RxEventType;   <span class="comment">/*!&lt; Type of Rx Event                   */</span></span><br><span class="line">  DMA_HandleTypeDef             *hdmatx;          <span class="comment">/*!&lt; UART Tx DMA Handle parameters      */</span></span><br><span class="line">  DMA_HandleTypeDef             *hdmarx;          <span class="comment">/*!&lt; UART Rx DMA Handle parameters      */</span></span><br><span class="line">  HAL_LockTypeDef               Lock;             <span class="comment">/*!&lt; Locking object                     */</span></span><br><span class="line">  __IO HAL_UART_StateTypeDef    gState;           <span class="comment">/*!&lt; UART state information related to global Handle management</span></span><br><span class="line"><span class="comment">                                                       and also related to Tx operations.</span></span><br><span class="line"><span class="comment">                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef */</span></span><br><span class="line">  __IO HAL_UART_StateTypeDef    RxState;          <span class="comment">/*!&lt; UART state information related to Rx operations.</span></span><br><span class="line"><span class="comment">                                                       This parameter can be a value of @ref HAL_UART_StateTypeDef */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span>                 ErrorCode;        <span class="comment">/*!&lt; UART Error code                    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (USE_HAL_UART_REGISTER_CALLBACKS == 1)</span></span><br><span class="line">  <span class="type">void</span> (* TxHalfCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);        <span class="comment">/*!&lt; UART Tx Half Complete Callback        */</span></span><br><span class="line">  <span class="type">void</span> (* TxCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);            <span class="comment">/*!&lt; UART Tx Complete Callback             */</span></span><br><span class="line">  <span class="type">void</span> (* RxHalfCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);        <span class="comment">/*!&lt; UART Rx Half Complete Callback        */</span></span><br><span class="line">  <span class="type">void</span> (* RxCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);            <span class="comment">/*!&lt; UART Rx Complete Callback             */</span></span><br><span class="line">  <span class="type">void</span> (* ErrorCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);             <span class="comment">/*!&lt; UART Error Callback                   */</span></span><br><span class="line">  <span class="type">void</span> (* AbortCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);         <span class="comment">/*!&lt; UART Abort Complete Callback          */</span></span><br><span class="line">  <span class="type">void</span> (* AbortTransmitCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart); <span class="comment">/*!&lt; UART Abort Transmit Complete Callback */</span></span><br><span class="line">  <span class="type">void</span> (* AbortReceiveCpltCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);  <span class="comment">/*!&lt; UART Abort Receive Complete Callback  */</span></span><br><span class="line">  <span class="type">void</span> (* WakeupCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);            <span class="comment">/*!&lt; UART Wakeup Callback                  */</span></span><br><span class="line">  <span class="type">void</span> (* RxEventCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Pos); <span class="comment">/*!&lt; UART Reception Event Callback     */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (* MspInitCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);           <span class="comment">/*!&lt; UART Msp Init callback                */</span></span><br><span class="line">  <span class="type">void</span> (* MspDeInitCallback)(<span class="keyword">struct</span> __UART_HandleTypeDef *huart);         <span class="comment">/*!&lt; UART Msp DeInit callback              */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* USE_HAL_UART_REGISTER_CALLBACKS */</span></span></span><br><span class="line"></span><br><span class="line">&#125; UART_HandleTypeDef;</span><br></pre></td></tr></table></figure><h3 id="USART-TypeDef"><a href="#USART-TypeDef" class="headerlink" title="USART_TypeDef"></a>USART_TypeDef</h3><p>该结构体用于参数UASRT硬件的寄存器基地址，结构体定义如下：</p><p>在创建 $USART_TypeDef\ *$ 类型，以某一个串口配置寄存器开始的结构体指针后，便可以访问该串口的配置寄存器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> SR;         <span class="comment">/*!&lt; USART Status register,                   Address offset: 0x00 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> DR;         <span class="comment">/*!&lt; USART Data register,                     Address offset: 0x04 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> BRR;        <span class="comment">/*!&lt; USART Baud rate register,                Address offset: 0x08 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CR1;        <span class="comment">/*!&lt; USART Control register 1,                Address offset: 0x0C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CR2;        <span class="comment">/*!&lt; USART Control register 2,                Address offset: 0x10 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CR3;        <span class="comment">/*!&lt; USART Control register 3,                Address offset: 0x14 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> GTPR;       <span class="comment">/*!&lt; USART Guard time and prescaler register, Address offset: 0x18 */</span></span><br><span class="line">&#125; USART_TypeDef;</span><br></pre></td></tr></table></figure><p>该结构体的基地址变量，由总线基地址+偏移地址宏定义，例如F407定义的USART1和2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USART1_BASE           (APB2PERIPH_BASE + 0x1000UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART2_BASE           (APB1PERIPH_BASE + 0x4400UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART1              ((USART_TypeDef *) USART1_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART2              ((USART_TypeDef *) USART2_BASE)</span></span><br></pre></td></tr></table></figure><p>对于F4系列，有6个串口：USART1-3，UART4-5，USART6，他们都通过如上代码宏定义了基地址，因此给结构体成员Instance传入这些地址即可。</p><h3 id="UART-InitTypeDef"><a href="#UART-InitTypeDef" class="headerlink" title="UART_InitTypeDef"></a>UART_InitTypeDef</h3><p>该结构体用于存放UART通信中的一些基本参数，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> BaudRate; <span class="comment">//波特率</span></span><br><span class="line">  <span class="type">uint32_t</span> WordLength; <span class="comment">//数据长度</span></span><br><span class="line">  <span class="type">uint32_t</span> StopBits; <span class="comment">//停止位长度</span></span><br><span class="line">  <span class="type">uint32_t</span> Parity; <span class="comment">//奇偶校验配置</span></span><br><span class="line">  <span class="type">uint32_t</span> Mode;<span class="comment">// UART收发模式设置（收、发、同时收发）</span></span><br><span class="line">  <span class="type">uint32_t</span> HwFlowCtl; <span class="comment">//硬件流控制</span></span><br><span class="line">  <span class="type">uint32_t</span> OverSampling; <span class="comment">//过采样设置</span></span><br><span class="line">&#125; UART_InitTypeDef;</span><br></pre></td></tr></table></figure><ul><li><p><strong>BaudRate:</strong> 直接设置波特率数字即可</p></li><li><p><strong>WordLength:</strong> 宏定义了 UART_WORDLENGTH_8B 和 UART_WORDLENGTH_9B 两种，分别对应8bit和9bit数据位</p></li><li><p><strong>StopBits:</strong> 宏定义 UART_STOPBITS_1，UART_STOPBITS_2 两种输入，分别对应1个停止位和2个</p></li><li><strong>Parity：</strong>有 UART_PARITY_NONE，UART_PARITY_EVEN，UART_PARITY_ODD 三种，分别对应无、偶校验、奇校验</li><li><strong>Mode:</strong> 有UART_MODE_RX，UART_MODE_TX，UART_MODE_TX_RX 三种，分别对应单收、单发、同时收发三种工作模式</li><li><strong>HwFlowCtl:</strong> 有UART_HWCONTROL_NONE，UART_HWCONTROL_RTS，UART_HWCONTROL_CTS，UART_HWCONTROL_RTS_CTS四种输入，分别对应无硬件流控制，接受流控制，发送流控制，同时启用接受发送流控制。</li><li><strong>OverSampling：</strong> UART_OVERSAMPLING_16，UART_OVERSAMPLING_8两种，对应16位过采样和8位，F1系列不可配置</li></ul><h2 id="串口初始化"><a href="#串口初始化" class="headerlink" title="串口初始化"></a>串口初始化</h2><h3 id="轮询方式收发的初始化"><a href="#轮询方式收发的初始化" class="headerlink" title="轮询方式收发的初始化"></a>轮询方式收发的初始化</h3><p>使用轮询模式时，只需要先配置huart中Init结构体的参数，然后再调用HAL_UART_Init函数进行寄存器配置即可。下面是一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">huart1.Instance = USART3;</span><br><span class="line">huart1.Init.BaudRate = <span class="number">115200</span>;</span><br><span class="line">huart1.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">huart1.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">huart1.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">huart1.Init.Mode = UART_MODE_TX_RX;</span><br><span class="line">huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;</span><br><span class="line">huart1.Init.OverSampling = UART_OVERSAMPLING_16;</span><br><span class="line"><span class="keyword">if</span> (HAL_UART_Init(&amp;huart1) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">  Error_Handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HAL_UART_Init()函数中，会依次执行如下操作：</p><ul><li>若检测为轮询模式的初始化，则会调用HAL_UART_MspInit()函数对其所用的总线时钟、GPIO等关联设备进行初始化</li><li>UART_SetConfig() 函数来对控制寄存器写入</li><li>对句柄结构体中所有状态指示器写入OK的状态</li></ul><p>其中HAL_UART_MspInit()函数一个例子如下，它会对所有关联的设备进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_MspInit</span><span class="params">(UART_HandleTypeDef* uartHandle)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span>(uartHandle-&gt;Instance==USART1)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_RCC_USART1_CLK_ENABLE();</span><br><span class="line">    __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;</span><br><span class="line">    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;<span class="comment">//该GPIO复用设置为GPIO_AF7_USART1</span></span><br><span class="line">    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用CubeMX配置工程时，会生成usart.c文件来存放各项init函数，例如总初始化函数MX_USART1_UART_Init()、关联设备初始化函数HAL_UART_MspIni()，以备HAL库文件stm32fxxx_hal_uart.c调用</p><h2 id="轮询-阻塞-数据收发"><a href="#轮询-阻塞-数据收发" class="headerlink" title="轮询(阻塞)数据收发"></a>轮询(阻塞)数据收发</h2><p>在轮询数据模式下，MCU专注于发送数据或接受数据，在Timeout规定的时间内收发完成则return 成功，否则return超时。在这个期间，MCU一直除以等数据接受或者看着输出发送的状态，效率较低。</p><h3 id="轮询串口接收"><a href="#轮询串口接收" class="headerlink" title="轮询串口接收"></a>轮询串口接收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span></span><br></pre></td></tr></table></figure><p>huart句柄已在上方介绍，剩余输入参数分别是：</p><ul><li>pData：存放数据的buffer首地址</li><li>Size：接受数据的字符串长度</li><li>Timeout：轮询时长，超时则返回</li></ul><p>这个函数会返回的类型”HAL_StatusTypeDef”有如下状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  HAL_OK       = <span class="number">0x00</span>U, <span class="comment">//成功接收</span></span><br><span class="line">  HAL_ERROR    = <span class="number">0x01</span>U, <span class="comment">//出现错误</span></span><br><span class="line">  HAL_BUSY     = <span class="number">0x02</span>U, <span class="comment">//串口忙</span></span><br><span class="line">  HAL_TIMEOUT  = <span class="number">0x03</span>U  <span class="comment">//轮询超时</span></span><br><span class="line">&#125; HAL_StatusTypeDef;</span><br></pre></td></tr></table></figure><h3 id="轮询串口发送"><a href="#轮询串口发送" class="headerlink" title="轮询串口发送"></a>轮询串口发送</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">const</span> <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span></span><br></pre></td></tr></table></figure><p>其输入参数、返回参数定义均同轮询接收函数一样，这里不重复介绍。</p><h2 id="中断数据收发"><a href="#中断数据收发" class="headerlink" title="中断数据收发"></a>中断数据收发</h2><p>使用中断模式进行数据收发时，MCU进会在有数据进来的时候让CPU去处理数据。其余时候可以干其他事情。这样效率较高</p><h3 id="中断串口接收"><a href="#中断串口接收" class="headerlink" title="中断串口接收"></a>中断串口接收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span></span><br></pre></td></tr></table></figure><p>参数如下：</p><ul><li>huart：uart handle地址</li><li>pData：存放数据的buffer首地址</li><li>Size：接受数据的字符串长度</li></ul><p>这里面输入的Size参数会被赋值进handle内的RxXferSize成员内。pData会被赋值进handle内的pRxBuffPtr成员内。在USART中断函数</p><p>HAL_UART_IRQHandler()中，会首先判断有没有错误出现，如果没有错误，则调用UART_Receive_IT()函数进行接收。这两个函数都被定义在stm32xxx_hal_uart.c内。</p><p>UART_Receive_IT函数中，每接收一个数据，就会对pRxBuffPtr的指针地址进行位移，来指向下一个内存单元的地址。同时对RxXferCount自减。当RxXferCount自减至0时，会关闭USART接受相关的中断使能。这一段代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> HAL_StatusTypeDef <span class="title function_">UART_Receive_IT</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span>  *pdata8bits;</span><br><span class="line">  <span class="type">uint16_t</span> *pdata16bits;</span><br><span class="line">  <span class="keyword">if</span> (huart-&gt;RxState == HAL_UART_STATE_BUSY_RX)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((huart-&gt;Init.WordLength == UART_WORDLENGTH_9B) &amp;&amp; (huart-&gt;Init.Parity == UART_PARITY_NONE))</span><br><span class="line">    &#123;</span><br><span class="line">      pdata8bits  = <span class="literal">NULL</span>;</span><br><span class="line">      pdata16bits = (<span class="type">uint16_t</span> *) huart-&gt;pRxBuffPtr;</span><br><span class="line">      *pdata16bits = (<span class="type">uint16_t</span>)(huart-&gt;Instance-&gt;DR &amp; (<span class="type">uint16_t</span>)<span class="number">0x01FF</span>);</span><br><span class="line">      huart-&gt;pRxBuffPtr += <span class="number">2U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      pdata8bits = (<span class="type">uint8_t</span> *) huart-&gt;pRxBuffPtr;</span><br><span class="line">      pdata16bits  = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((huart-&gt;Init.WordLength == UART_WORDLENGTH_9B) || ((huart-&gt;Init.WordLength == UART_WORDLENGTH_8B) &amp;&amp; (huart-&gt;Init.Parity == UART_PARITY_NONE)))</span><br><span class="line">      &#123;</span><br><span class="line">        *pdata8bits = (<span class="type">uint8_t</span>)(huart-&gt;Instance-&gt;DR &amp; (<span class="type">uint8_t</span>)<span class="number">0x00FF</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        *pdata8bits = (<span class="type">uint8_t</span>)(huart-&gt;Instance-&gt;DR &amp; (<span class="type">uint8_t</span>)<span class="number">0x007F</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      huart-&gt;pRxBuffPtr += <span class="number">1U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (--huart-&gt;RxXferCount == <span class="number">0U</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);</span><br><span class="line">      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);</span><br><span class="line">      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);</span><br><span class="line">      huart-&gt;RxState = HAL_UART_STATE_READY;</span><br><span class="line">      huart-&gt;RxEventType = HAL_UART_RXEVENT_TC;</span><br><span class="line">      <span class="keyword">if</span> (huart-&gt;ReceptionType == HAL_UART_RECEPTION_TOIDLE)</span><br><span class="line">      &#123;</span><br><span class="line">        huart-&gt;ReceptionType = HAL_UART_RECEPTION_STANDARD;</span><br><span class="line">        ATOMIC_CLEAR_BIT(huart-&gt;Instance-&gt;CR1, USART_CR1_IDLEIE);</span><br><span class="line">        <span class="keyword">if</span> (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))</span><br><span class="line">          __HAL_UART_CLEAR_IDLEFLAG(huart);</span><br><span class="line">          <span class="comment">//...未完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因此，调用HAL_UART_Receive_IT()后便会自动使能UART接收相关串口中断，同时准备好接受。在当接受的字符&gt;=Size所指定的字符数之后，便会自动失能相关中断</strong></p><p>在UART_Receive_IT()中，如果指定的字符数已经接收完成（RxXferCount == 0），则会调用HAL_UART_RxCpltCallback()这一公共回调函数。因为HAL库的库文件需要把硬件抽象成接口，因此直接改库文件内的代码不利于移植，用户的自定义中断回到函数写在HAL_UART_RxCpltCallback()内即可。此时UART已经将接收到的字符存在了pData指定的地址内，在HAL_UART_RxCpltCallback()内对pData内的数据进行处理即可。如果处理完成还需继续接收下一个数据，则再次调用HAL_UART_Receive_IT()来启用中断准备接收。</p><p>举个例子，假设我使用的通信协议规定每8byte数据为以通信帧，一数据帧传送数据位1byte，那么就可以把Size设置为8，然后每8byte数据接收完成之后就会调用用户自定义的回调函数HAL_UART_RxCpltCallback()函数来让用户处理数据。</p><p>下面是一个例程，实现使用中断接受UART数据，然后在收到换行符时把接收的数据发回去（省去了系统初始化部分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> ch;</span><br><span class="line"><span class="type">uint8_t</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">13</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    HAL_UART_Receive_IT(&amp;huart1,&amp;ch,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>&#123;</span><br><span class="line"><span class="comment">//user code here</span></span><br><span class="line">  buffer[count] = ch; <span class="comment">//ch就是pData指向的变量地址</span></span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">if</span>(buffer[count<span class="number">-1</span>] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">    HAL_UART_Transmit(huart, buffer, count , <span class="number">100</span>);<span class="comment">//把收到的字符发回串口</span></span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  HAL_UART_Receive_IT(&amp;huart1,&amp;ch,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SPI-通信"><a href="#SPI-通信" class="headerlink" title="SPI 通信"></a>SPI 通信</h1>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1-CH2-电路实现技术</title>
      <link href="/posts/2139.html"/>
      <url>/posts/2139.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用-AND-OR-NOT门综合设计（Synthesis-Using-AND-OR-and-NOT-Gates）"><a href="#使用-AND-OR-NOT门综合设计（Synthesis-Using-AND-OR-and-NOT-Gates）" class="headerlink" title="使用 AND OR NOT门综合设计（Synthesis Using AND, OR, and NOT Gates）"></a>使用 AND OR NOT门综合设计（Synthesis Using AND, OR, and NOT Gates）</h1><ul><li><p><strong>Minterm:</strong> 选取为1的项目。 <strong>选择输入逻辑满足F=1的输入组合</strong>，通过以下步骤设计Boolean function:</p><ol><li><p>使得某一个输入满足组合时输出为1（输入进行AND运算）</p></li><li><p>当 1 中任意一个满足时（步骤1的结果们进行OR运算），输出为1</p><p>例如，对$x_1,x_2,x_3$三个输入，想要满足$x_1=1 x_2=1 x_3=1$ 和$x_1=0 x_2=1 x_3=1$ 时输出为1，首先选取使得f输出为1的组合，也就是前面提到的两个，然后进行and运算:$x_1x_2x_3$和$\overline x_1 x_2x_3$，再对and运算的结果进行OR运算$F=x_1x_2x_3+\overline x_1 x_2x_3$(<strong>对应 Sum of Product SOP</strong>)</p></li></ol></li><li><p><strong>Maxterm:</strong> 排除为0的项目。<strong>选择输入逻辑满足F=0的输入组合</strong>，通过以下步骤设计Boolean function:</p><ol><li><p>使得输入满足这个组合时输出为0（输入AND运算的结果取反，然后德摩根化开，此时$\overline {A.B}$ 就会变成$\overline A+\overline B$ ）</p></li><li><p>当所有输入情况任意一个满足为0时为0，否则为1（步骤1的结果AND运算）。</p><p>例如： $F=(A+B).(  \overline {A}  +B).(A+  \overline {B}  )$ <strong>(对应 Product of Sum POS)</strong></p></li></ol></li><li><p><strong>Cost：</strong>电路中  <strong>门的总数</strong>  加 <strong>门的输入信号的总数</strong>, 如果题目说需要同时给了未取反和取反(complement)的形式，则可以忽略not门造成的cost，否则需要计算not门的cost</p></li></ul><p><em>例: Maxterm的化简</em></p><script type="math/tex; mode=display">f=(  x_ {1}  +  x_ {2}  +  x_ {3}  )(  x_ {1}  +  \overline {x}_ {2}  +  x_ {3}  )(  x_ {1}  +  \overline {x}_ {2}  +  \overline {x}_ {3}  )  (\overline {x}_ {1}+\overline {x}_ {2}+\overline {x}_ {3})_ {(}</script><script type="math/tex; mode=display">f=((  x_ {1}  +  x_ {3}  )+  x_ {2}  )((  x_ {1}  +  x_ {3}  )+  \overline {x}_ {2}  )(  x_ {1}  +(\overline  x_ {2}  +  \overline {x}_ {3}  ))(  \overline {x}_ {1}  +(  \overline {x}_ {2}  +  \overline {x}_ {3}  ))\\</script><script type="math/tex; mode=display">f=(  x_ {1}  +  x_ {3}  )(  \overline {x}_ {2}  +  \overline {x}_ {3}  )\\</script><div class="note info simple"><p><em>把AND OR NOT门电路转化成NAND和NOR只需要用DeMorgan’s theorem 整体取反后化开即可。Multiplexer后面有更详细的涉及，此处省去。</em></p></div><hr><h1 id="晶体管开关-Transistor-Switches"><a href="#晶体管开关-Transistor-Switches" class="headerlink" title="晶体管开关 (Transistor Switches)"></a>晶体管开关 (Transistor Switches)</h1><p>晶体管有三个级：  源极(Source)  漏极(Drain)  栅极(Gate)  </p><ul><li><p><strong>NMOS:</strong>   当$V_G$是低电平的时候关断，高电平的时候导通。 </p></li><li><p><strong>PMOS:</strong>    当$V_G$是低电平的时候导通，高电平的时候截止。</p><table>   <tr>       <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240113231550895.png"/></center></td>       <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240113232443627.png"/></center></td>   </tr></table></li></ul><h2 id="NMOS-逻辑门"><a href="#NMOS-逻辑门" class="headerlink" title="NMOS 逻辑门"></a><strong>NMOS</strong> <strong>逻辑门</strong></h2><ul><li><p>利用开关的特性，通过上拉或下拉工作模式即可实现一个基于NMOS的逻辑门。此时需要一个限流电阻。因此该种方式功耗较大 </p></li><li><p>从MOS管的构成视角来看，AND和OR门其实是NAND和NOR门取反(如下图所示)，成本更高</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240113232959053.png" alt="image-20240113232959053.png (748×237) (kaysonz.top)"></p><h2 id="CMOS逻辑门-五星级的"><a href="#CMOS逻辑门-五星级的" class="headerlink" title="CMOS逻辑门 (五星级的)"></a>CMOS逻辑门 (五星级的)</h2><h3 id="CMOS逻辑门的介绍"><a href="#CMOS逻辑门的介绍" class="headerlink" title="CMOS逻辑门的介绍"></a>CMOS逻辑门的介绍</h3><p>NMOS逻辑门中通过上拉电阻实现上拉电路，这导致了功耗增加。CMOS逻辑门则优化了这个问题。</p><p>CMOS使用上拉电路和下拉电路，构成逻辑门。以NOT门为例，无论输入是低或高时，CMOS NOT门都直接被连到VCC或者GND，内部没有电流流动，理想状态下没有功率。这是CMOS是当今最流行的逻辑电路技术的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114004622139.png" alt="image-20240114004622139"></p><h3 id="使用CMOS逻辑门构建逻辑电路"><a href="#使用CMOS逻辑门构建逻辑电路" class="headerlink" title="使用CMOS逻辑门构建逻辑电路"></a>使用CMOS逻辑门构建逻辑电路</h3><p>在MOS层面，<strong>AND逻辑需要两个MOS都导通才导通，因此可以用两个MOS管串联来实现；OR逻辑只需要任意任意一个MOS导通它就导通，因此可以用两个MOS管并联来实现</strong></p><p>下图就时一个使用MOS管实现NOR逻辑的例子：</p><ul><li><p>上拉电路是电路取1的表达状态：根据真值表，只有当$x_1,x_2$都是0的时候，电路输出才是1。也就是$x_1x_2$</p></li><li><p>下拉电路是电路取0的表达状态，根据真值表，只要任意输入不为0，电路输出0。也就是$x_1+x_2$</p></li><li>根据上面的分析，AND逻辑使用串联，OR逻辑使用并联，即可得到下面这个NOR gate</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114004807165.png" alt="image-20240114004807165"></p><p><em>Example：Realise the following function using PMOS and NMOS$f=  \overline {x_ {1}}  +  \overline {x_ {2}}   \cdot   \overline {x_ {3}}  $</em> </p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114005501784.png" alt="img" style="zoom:150%;" /></p><p>如上图所示，上拉电路为$f=1$的时候，也就是$f=  \overline {x_ {1}}  +  \overline {x_ {2}}   \cdot   \overline {x_ {3}}  $</p><p>下拉电路为$f=0$的时候，也就是$  \overline f=\overline { \overline {x_ {1}}  +  \overline {x_ {2}}   \cdot   \overline {x_ {3}}  }=<br>(  x_ {1}  )  (x_ {2}+x_ {3}) $，逻辑是($x_1$) 与 ($x_2,x_3$并联的结果) 串联</p><hr><h1 id="可编程逻辑器件-Programmable-Logic-Devices-PLDs"><a href="#可编程逻辑器件-Programmable-Logic-Devices-PLDs" class="headerlink" title="可编程逻辑器件 (Programmable Logic Devices PLDs)"></a>可编程逻辑器件 (Programmable Logic Devices PLDs)</h1><h2 id="Programmable-Logic-Array-PLA"><a href="#Programmable-Logic-Array-PLA" class="headerlink" title="Programmable Logic Array (PLA)"></a><strong>Programmable Logic Array (PLA)</strong></h2><p>PLA 由AND运算后输入给OR运算，整体构成了一个SOP的形式，下图中曲线的位置代表它可编程。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011303571.png" alt="image-20240114011303571"></p><p>下图逻辑表达式如下 </p><p>$ P_ {1} $ = $ x_ {1} $ $ x_ {2} $  $ P_ {2} $ = $ x_ {1} $ $ \overline {x}_ {3} $ , $ P_ {3} $ = $ \overline {x}_ {1} $ $ \overline {x}_ {2} $ $ x_ {3} $ , $ andP_ {4} $ = $ x_ {1} $ $ x_ {3} $<br> $ f_ {1} $ = $ x_ {1} $ $ x_ {2} $ + $ x_ {1} $ $ \overline {x}_ {3} $ + $ \overline {x}_ {1} $ $ \overline {x}_ {2} $ $ x_ {3} $<br> $ f_ {2} $ = $ x_ {1} $ $ x_ {2} $ + $ \overline {x}_ {1} $ $ \overline {x_ {2}} $ $ x_ {3} $ + $ x_ {1} $ $ x_ {3} $ </p><p><strong>PLA 所需的可编程开关具有难以制造，速度慢的问题。</strong></p><h2 id="Programmable-Array-Logic-PAL"><a href="#Programmable-Array-Logic-PAL" class="headerlink" title="Programmable Array Logic (PAL)"></a><strong>Programmable Array Logic (PAL)</strong></h2><p>PAL的AND plane是可编程的，OR plane是固定的。与PLA相比，PAL提供的灵活性较小；PLA允许每个或门最多有四个乘积项，而PAL中的或门只有两个输入。但它减少了可编程开关的数量。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114010919955.png" alt="image-20240114010919955"></p><p>上图的输出为： $ f_ {1} $ = $ x_ {1} $ $ x_ {2} $ $ \overline {x}_ {3} $ + $ \overline {x}_ {1} $ $ x_ {2} $ $ x_ {3} $ ；   $ f_ {2} $ = $ \overline {x}_ {1} $ $ \overline {x}_ {2} $ + $ x_ {1} $ $ x_ {2} $ $ x_ {3} $ </p><p>因为PAL的OR的输出是不可编程的，因此flexibility较差。利用额外的宏单元来提升flexibility。宏(Macrocell) :将OR Gate的输出连接至额外的电路，如下图例子所示。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011123843.png" alt="image-20240114011123843"></p><h2 id="Complex-Programmable-Logic-Device-CPLD"><a href="#Complex-Programmable-Logic-Device-CPLD" class="headerlink" title="Complex Programmable Logic Device (CPLD)"></a><strong>Complex Programmable Logic Device (CPLD)</strong></h2><p>为了实现需要更多输入和输出的电路，可以使用多个PLA或PAL，或者可以使用更复杂类型的芯片，称为复杂可编程逻辑器件（CPLD）。CPLD的基本结构可看成由可编程逻辑阵列（LAB），可编程I/O控制模块和可编程内部连线（PIA）等三部分组成。</p><p>Example：下图是四个类似PAL的块，连接到一组互连线。每个类似PAL的块也连接到标记为I/O块。note: 一旦CPLD被编程了，那它的程序是可以断电保存的。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011242968.png" alt="image-20240114011242968"></p><h2 id="Field-programmable-gate-array-FPGA"><a href="#Field-programmable-gate-array-FPGA" class="headerlink" title="Field-programmable gate array (FPGA)"></a><strong>Field-programmable gate array (FPGA)</strong></h2><p>FPGA由可编程逻辑块（CLB/Logic Block），输入/输出模块（IOB）及可编程互连资源（PIR）等三种可编程电路和一个SRAM结构的配置存储单元组成。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011406647.png" alt="image-20240114011406647"></p><p>最常用的可编程逻辑块（Logic Block），是查表(Look Up Table LUT)</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011456609.png" alt="image-20240114011456609"></p><hr><h1 id="Custom-Chips-Standard-Cells-and-Gate-Arrays"><a href="#Custom-Chips-Standard-Cells-and-Gate-Arrays" class="headerlink" title="Custom Chips, Standard Cells, and Gate Arrays"></a><strong>Custom Chips, Standard Cells, and Gate Arrays</strong></h1><p>限制PLD中可以容纳的电路大小的关键因素是可编程开关的存在。尽管这些开关提供了用户可编程性的重要优势</p><ul><li><p><strong>它们在芯片上消耗了大量空间，从而导致成本增加。</strong></p></li><li><p><strong>它们还导致电路运行速度的降低</strong></p></li><li><p><strong>以及功耗的增加。</strong></p><p>AISC可以解决如上问题</p></li></ul><h2 id="Application-specific-integrated-circuits-AISCs"><a href="#Application-specific-integrated-circuits-AISCs" class="headerlink" title="Application-specific integrated circuits (AISCs)"></a><strong>Application-specific integrated circuits (AISCs)</strong></h2><p>专用集成电路，是指应特定用户要求和特定电子系统的需要而设计、制造的集成电路。制造商首先制造出逻辑操作的模板，后根据用户需求将模板用不同方式组合在一起。</p><p><strong>ASIC在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低等优点。</strong></p><p><strong>ASIC和FPGA相比，ASIC是专用集成电路，一旦设计完成后集成电路即固定。而FPGA是在阵列内集成大量数字电路基本门电路和存储器，开发人员可以通过烧写FPGA配置来定义电路。</strong></p><p>一个AISC的例子：这个电路中，制造商制造框起来的标准逻辑块，用户自定义连接(红线)，来实现不同输出，下图电路实现的输出就是：$f_1=  x_ {1}   x_ {2}  +  \overline {x_ {1}}  \overline {x_ {2}}   x_ {3}  +  x_ {1}   x_ {3}  $;    $ f_2=  \overline {x_ {1}}    \overline {x_ {3}}  +  \overline {x_ {1}}   \overline {x_ {2}}   x_ {3}  +  x_ {1}   x_ {3}  $</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114011657224.png" alt="image-20240114011657224"></p><hr><h1 id="传输门（Transmission-Gates）五星级"><a href="#传输门（Transmission-Gates）五星级" class="headerlink" title="传输门（Transmission Gates）五星级"></a><strong>传输门（Transmission Gates）五星级</strong></h1><p>NMOS(高开低关)传输0较好，而传输1较差。PMOS（低开高关）传输1较好而传输0较差。传输门把一个NMOS和一个PMOS组合在一起，从而实现很低的导通电阻和很高的截止电阻。因此，传输门可以直接使得原始信号x通过逻辑门，此时逻辑门输出$f=x$。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114012221074.png" alt="image-20240114012221074"></p><div class="note warning simple"><p>五星级问题：一个传输门有几个 Transistor？ ——2个; 因为是把PMOS和NMOS组合在一起</p></div><p><strong>五星级例题：使用传输门构建XOR</strong></p><p>XOR表达式：$f=\overline x_1x_2+x_1 \overline x_2$</p><p>根据真值表，当$x_1=0$时，输出$f=x_2$。当$x_1=1$时，输出$f=\overline x_2 $。根据传输门良好导通的特性，下图电路可被设计。</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114012807046.png"/></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114012819416.png"/></center></td>    </tr></table><hr><h1 id="SPLD、CPLD和FPGA的实现细节"><a href="#SPLD、CPLD和FPGA的实现细节" class="headerlink" title="SPLD、CPLD和FPGA的实现细节"></a><strong>SPLD、CPLD和FPGA的实现细节</strong></h1><h2 id="PLD"><a href="#PLD" class="headerlink" title="PLD"></a>PLD</h2><p>这是一个普通的XOR Gate，使用NMOS实现的电路</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114012954804.png" alt="image-20240114012954804"></p><p>这是可编程版本</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114013017068.png" alt="image-20240114013017068"></p><p>白色框框内部结构是EEPROM编程开关，$Ve$连接的就是EEPROM</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114013141719.png" alt="image-20240114013141719"></p><h2 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h2><p>与白色框框不同，FPGA采用SRAM编程，结构如下图所示.  <strong>SRAM 单元中的数据掉电就会丢失</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114014257973.png" alt="image-20240114014257973"></p><hr><h1 id="典型逻辑电路和它们的VHDL代码"><a href="#典型逻辑电路和它们的VHDL代码" class="headerlink" title="典型逻辑电路和它们的VHDL代码"></a>典型逻辑电路和它们的VHDL代码</h1><h2 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114013350317.png" alt="image-20240114013350317"></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--定义实体，主要定义输入输出的端口--</span></span><br><span class="line"><span class="keyword">ENTITY</span> examplel <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span> (x1,x2,x3 :<span class="keyword">IN</span> <span class="built_in">BIT</span> ; <span class="comment">--PORT后定义输入的端口和输出的端口</span></span><br><span class="line">f  : <span class="keyword">OUT</span> <span class="built_in">BIT</span> );<span class="comment">--这里定义类型为BIT，只有0和1两种状态；这里也可以定义为STD_LOGIC,会多出高阻等等状态，Dr.Wu一般只会考0和1的</span></span><br><span class="line"><span class="keyword">END</span> example1 ;</span><br><span class="line"><span class="comment">--定义某个实体对应的逻辑结构--</span></span><br><span class="line"><span class="keyword">ARCHITECTURE</span> LogicFunc <span class="keyword">OF</span> examplel <span class="keyword">IS</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">f &lt;= (x1 <span class="keyword">AND</span> x2) <span class="keyword">OR</span> (<span class="keyword">NOT</span> X2 <span class="keyword">AND</span> x3) <span class="comment">--写输入，输出端口对应的逻辑表达式</span></span><br><span class="line"><span class="keyword">END</span> LogicFunc;</span><br></pre></td></tr></table></figure><h2 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114013524391.png" alt="image-20240114013524391"></p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTITY</span> example2 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span> (xl,x2,x3,x4 :<span class="keyword">IN</span> <span class="built_in">BIT</span> ; <span class="comment">--PORT后定义输入的端口和输出的端口，这里是多路输出，有f和g两个OUT</span></span><br><span class="line">f,g : <span class="keyword">OUT</span> <span class="built_in">BIT</span>);</span><br><span class="line"><span class="keyword">END</span> example2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARCHITECTURE</span> LogicFunc <span class="keyword">OF</span> example2 <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">f &lt;=(x1 <span class="keyword">AND</span> x3) <span class="keyword">OR</span> (x2 <span class="keyword">AND</span> x4) ;<span class="comment">--分别写出输出的逻辑表达式</span></span><br><span class="line">g &lt;= (x1 <span class="keyword">OR</span> <span class="keyword">NOT</span> x3) <span class="keyword">AND</span> (<span class="keyword">NOT</span> X2 <span class="keyword">OR</span> X4)</span><br><span class="line"><span class="keyword">END</span> LogicFunc ;</span><br></pre></td></tr></table></figure><hr><center>---CHAPTER END---</center>]]></content>
      
      
      <categories>
          
          <category> 数字电路设计与可靠性工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/posts/953.html"/>
      <url>/posts/953.html</url>
      
        <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><p>以下内容中&lt;参数&gt;都表示输入参数，输入时不需要加&lt;&gt;</p><h2 id="本地仓库相关"><a href="#本地仓库相关" class="headerlink" title="本地仓库相关"></a>本地仓库相关</h2><h3 id="在某一文件夹内初始化git"><a href="#在某一文件夹内初始化git" class="headerlink" title="在某一文件夹内初始化git"></a><strong>在某一文件夹内初始化git</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="把工作区文件添加至暂存区"><a href="#把工作区文件添加至暂存区" class="headerlink" title="把工作区文件添加至暂存区"></a><strong>把工作区文件添加至暂存区</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;文件名 或 通配符&gt;</span><br><span class="line">git add -u <span class="comment">#将已跟踪的文件提交至暂存区</span></span><br></pre></td></tr></table></figure><h3 id="把暂存区文件提交至本地仓库"><a href="#把暂存区文件提交至本地仓库" class="headerlink" title="把暂存区文件提交至本地仓库"></a><strong>把暂存区文件提交至本地仓库</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;&lt;对本次提交的描述&gt;&quot;</span> <span class="comment">#从暂存区提交</span></span><br><span class="line">git commit -am <span class="string">&quot;&lt;对本次提交的描述&gt;&quot;</span> <span class="comment">#将已跟踪的文件提交至暂存区和仓库</span></span><br><span class="line">git commit --amend -m <span class="string">&quot;&lt;对上次提交的描述修改&gt;&quot;</span> <span class="comment">#修改上次提交的描述，不加-m可进入vim编辑</span></span><br></pre></td></tr></table></figure><h3 id="查看当前仓库的状态（分支、文件、文件状态）"><a href="#查看当前仓库的状态（分支、文件、文件状态）" class="headerlink" title="查看当前仓库的状态（分支、文件、文件状态）"></a><strong>查看当前仓库的状态（分支、文件、文件状态）</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a><strong>回退版本</strong></h3><p>  &lt;输入参数&gt;有：</p><ul><li>—soft  (保留工作区和暂存区仅回退版本)</li><li>—hard  （回退版本、工作区、暂存区）</li><li>—mixed   (回退功版本和暂存区，保留工作区)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;输入参数&gt;</span><br></pre></td></tr></table></figure><h3 id="查看差异"><a href="#查看差异" class="headerlink" title="查看差异"></a><strong>查看差异</strong></h3><p>  &lt;输入参数&gt;有：</p><ul><li>无： 工作区和暂存区的差异； 如果存在merge冲突，将在下面显示</li><li>HEAD：工作区和版本库的差异</li><li>— cache或—staged：暂存区和版本库的差异</li><li>&lt;版本1 id&gt; &lt;版本2 id&gt;：版本1和版本2之间的差异，这里可以用HEAD指代当前版本的id；HEAD~ 来指代上一个版本的id; HEAD~n 表示前n个版本的id；</li><li>&lt;分支名1&gt; &lt;分支名2&gt;：分支1和分支2间的差异</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;输入参数&gt;</span><br></pre></td></tr></table></figure><h3 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a><strong>查看提交记录</strong></h3><p>  &lt;参数&gt;：</p><ul><li>—oneline， 这样只会显示哈希值的前几位。</li><li>—graph —oneline —decorate -all 查看分支图形式的提交记录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> &lt;参数&gt;</span><br></pre></td></tr></table></figure><h3 id="查看暂存区文件"><a href="#查看暂存区文件" class="headerlink" title="查看暂存区文件"></a><strong>查看暂存区文件</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a><strong>删除文件</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> &lt;文件名&gt; <span class="comment">#等效于删除某一文件后git add</span></span><br><span class="line">git <span class="built_in">rm</span> &lt;文件夹&gt; -r * <span class="comment">#递归删除某个文件夹以及内部所有文件和子文件夹</span></span><br><span class="line">git <span class="built_in">rm</span> --cached &lt;文件名&gt; <span class="comment"># 从暂存区删除，但保留在工作区</span></span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul><li><strong>branch 命令</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;分支名&gt; <span class="comment">#创建一个新的分支</span></span><br><span class="line">git branch <span class="comment">#查看当前的分支状态</span></span><br><span class="line">git branch -d &lt;分支名&gt; <span class="comment">#删除已经被合并的分支</span></span><br><span class="line">git branch -D &lt;分支名&gt; <span class="comment">#强制删除未被合并的分支</span></span><br><span class="line">git branch -vv <span class="comment">#查看本地分支时候和远程分支存在映射关系</span></span><br></pre></td></tr></table></figure><ul><li><strong>switch 命令（同checkout）</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;分支名&gt; <span class="comment">#切换到某分支</span></span><br><span class="line">git switch -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>merge命令</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;分支名&gt; <span class="comment">#把输入名字的分支合并到当前分支</span></span><br><span class="line">git merge --abort <span class="comment">#终止合并</span></span><br></pre></td></tr></table></figure><p>当合并冲突出现时，需要手动修改冲突内容，并使用git add + commit进行提交来合并分支</p><ul><li><strong>rebase命令</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;分支名&gt; <span class="comment">#将&lt;分支名&gt;上由共同祖先到当前HEAD的所有提交记录，移动到当前分支的分支树上（直接变基在当前分支HEAD的顶上）</span></span><br></pre></td></tr></table></figure><h2 id="远程仓库相关"><a href="#远程仓库相关" class="headerlink" title="远程仓库相关"></a>远程仓库相关</h2><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a><strong>克隆仓库</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;仓库地址&gt;</span><br></pre></td></tr></table></figure><h3 id="设置远程仓库"><a href="#设置远程仓库" class="headerlink" title="设置远程仓库"></a>设置远程仓库</h3><p>  &lt;输入参数&gt;：</p><ul><li>add &lt;仓库别名,通常origin&gt; &lt;仓库地址&gt;: 添加远程仓库</li><li>-v :查看本地仓库对应的远程仓库的别名和地址</li><li>rm &lt;仓库别名&gt;：删除远程仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote &lt;输入参数&gt;</span><br></pre></td></tr></table></figure><p>设置远程仓库和本地仓库的分支映射关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream &lt;本地分支&gt; &lt;远程仓库名&gt;/&lt;远程分支&gt; <span class="comment">#将本地分支映射到远程主机的远程分支</span></span><br><span class="line">git branch --set-upstream &lt;本地分支&gt; &lt;远程仓库名&gt; <span class="comment">#将本地分支映射到远程主机的同名分支</span></span><br></pre></td></tr></table></figure><h3 id="拉取仓库"><a href="#拉取仓库" class="headerlink" title="拉取仓库"></a>拉取仓库</h3><p><strong>pull</strong>  </p><p>&lt;输入参数&gt;：</p><ul><li><p>&lt;远程主机名&gt; &lt;远程分支&gt;:&lt;本地分支&gt;: 将远程主机上的远程分支取回，并与本地分支合并</p></li><li><p>&lt;远程主机名&gt; &lt;远程分支&gt;: 将远程主机上的远程分支取回，并与当前的本地分支合并</p><p><strong>如果当前分支已经被设置了和远程分支的映射关系，则不需要输入参数</strong></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;输入参数&gt;</span><br></pre></td></tr></table></figure><p><strong>fetch</strong></p><p>所有使用pull命令拉取的分支都会自动和本地分支合并，fetch则是先存在本地，等待人工merge合并</p><p>&lt;输入参数&gt;：</p><ul><li>&lt;远程主机名&gt; &lt;远程分支&gt;:&lt;本地分支(一般新建tmp分支)&gt;: 将远程主机上的远程分支取回到本地工作区，不合并，需要主动$merge <tmp>$</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;输入参数&gt;</span><br></pre></td></tr></table></figure><h3 id="上传仓库"><a href="#上传仓库" class="headerlink" title="上传仓库"></a>上传仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; <span class="comment">#把本地分支推送至远程</span></span><br><span class="line"><span class="comment">#在本地分支和远程分支同名时或设置了映射关系时，可省略远程分支</span></span><br><span class="line">git push &lt;远程仓库名&gt; &lt;本地分支名&gt;</span><br><span class="line"><span class="comment">#推送当前分支时,可省略本地分支名</span></span><br><span class="line">git push &lt;远程仓库名&gt;</span><br><span class="line"><span class="comment">#在本地分支只和一个远程仓库有映射关系时，可省略远程仓库名</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">git push  &lt;远程仓库名&gt; --delete &lt;远程分支名&gt; <span class="comment">#删除远程仓库中的某一分支</span></span><br></pre></td></tr></table></figure><h1 id="git常用工作流"><a href="#git常用工作流" class="headerlink" title="git常用工作流"></a>git常用工作流</h1><h3 id="gitflow工作流模型"><a href="#gitflow工作流模型" class="headerlink" title="gitflow工作流模型"></a><strong>gitflow工作流模型</strong></h3><ul><li><p><strong>mian分支</strong>（核心分支）：项目的可靠分支，可直接部署进生产环境，不允许直接修改，只能通过merge合并</p><p>主分支的版本号命名规则：Major Version（主要功能或者重大版本更新）；Minor Version（新功能改进和更新，不会影响现有功能）；Patch Version（一些bug修复）</p></li><li><p>hotfix分支：bug的热修复分支，一般从主分支中分离出来，修复完成后合并至mian分支和各个开发分支</p></li><li><p><strong>develop分支</strong>(核心分支)：开发分支，</p></li><li><p>feature分支：功能分支，用于开发新的功能的分支，新功能在稳定后会合并进开发分支。</p></li><li><p>release分支：发布前测试和验证的分支，由开发分支分离，当预发布分支稳定后，merge到主分支和开发分支并删除release分支。当预发布分支发现问题时，直接在预发布分支内进行修改。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 各种折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sx1280芯片手册</title>
      <link href="/posts/dead6220.html"/>
      <url>/posts/dead6220.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h2><p>SX1280是一个工作在2.4GHz(ISM频段)的半双工收发器。芯片引脚定义如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Pin Number</th><th style="text-align:center">引脚名称</th><th style="text-align:center">I/O类型</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">VR_PA</td><td style="text-align:center">-</td><td style="text-align:center">功放的稳压供电</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">VDD_IN</td><td style="text-align:center">I</td><td style="text-align:center">设备稳压供电，连接到Pin12</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">NRESET</td><td style="text-align:center">I</td><td style="text-align:center">复位信号，低电平有效，内部上拉为50kΩ</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">XTA</td><td style="text-align:center">-</td><td style="text-align:center">参考振荡器或温补晶振输入</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">XTB</td><td style="text-align:center">-</td><td style="text-align:center">参考振荡器</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">BUSY</td><td style="text-align:center">O</td><td style="text-align:center">忙信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">DIO1</td><td style="text-align:center">I/O</td><td style="text-align:center">数字IO</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">DIO2</td><td style="text-align:center">I/O</td><td style="text-align:center">数字IO</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">DIO3</td><td style="text-align:center">I/O</td><td style="text-align:center">数字IO</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">VBAT_IO</td><td style="text-align:center">I</td><td style="text-align:center">数字IO供电（1.8V至3.7V）</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">DCC_FB</td><td style="text-align:center">O</td><td style="text-align:center">片内稳压输出</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">DCC_SW</td><td style="text-align:center">O</td><td style="text-align:center">DCDC开关电源输出</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">VBAT</td><td style="text-align:center">I</td><td style="text-align:center">RFIC的供电（1.8V至3.7V）</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">MISO_TX</td><td style="text-align:center">O</td><td style="text-align:center">SPI slave output_UART TX</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">MOSI_RX</td><td style="text-align:center">I</td><td style="text-align:center">SPI slave input_UART RX</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">SCK_RTSN</td><td style="text-align:center">I</td><td style="text-align:center">SPI 时钟_ UART请求发送（Request to Send）</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">NSS_CTSN</td><td style="text-align:center">I</td><td style="text-align:center">SPI 从机选择_UART 允许发发送（Clear to Send）</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">RFIO</td><td style="text-align:center">I/O</td><td style="text-align:center">射频发射/接收 IO</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">GND</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120041210550.png" alt="image-20240120041210550"></p><h2 id="SX1280的一些关键的参数"><a href="#SX1280的一些关键的参数" class="headerlink" title="SX1280的一些关键的参数"></a>SX1280的一些关键的参数</h2><ul><li>供电：1.8~3.7V</li><li>工作温度：-40~85 摄氏度</li><li>RF天线功率 ：最小输出-18dBm 最大输入12.5dBm</li><li>数字IO： 最大输入/输出电流 2.5mA</li></ul><h2 id="硬件模块结构"><a href="#硬件模块结构" class="headerlink" title="硬件模块结构"></a>硬件模块结构</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124162852697.png" alt="image-20240124162852697"></p><p>通过SPI或UART，发送对应的opcode+data的形式来控制这个模块。模块大致分为5个部分，模拟前端用于调制和发射频带信号，绿色的是数字调制部分，可产生不同调制的信号。Data Buffer用于存放接收的和待发送的数据。和 Protocol Engine用于硬件实现一些通信协议。</p><p>在供电方面，SX1280有两个独立的供电模组：DC-DC和LDO，默认情况下，仅开启LDO做为供电，但DCDC电源可在FS，RX，TX模式下启用，来承载更高的功耗。<strong>如果要想启用DCDC电源，则需要在12和14引脚之间接一个15uH的电感并将DCDC和LDO并联做为VDD。</strong>在DCDC被并入供电时，可在待机模式时切换启用和关闭DCDC供电，下方工作模式将会详细介绍。</p><h2 id="SX1280的几种工作模式"><a href="#SX1280的几种工作模式" class="headerlink" title="SX1280的几种工作模式"></a>SX1280的几种工作模式</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120013631945.png" alt="image-20240120013631945"></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240208021648925.png" alt="image-20240208021648925"></p><h3 id="STDBY（待机）模式"><a href="#STDBY（待机）模式" class="headerlink" title="STDBY（待机）模式"></a>STDBY（待机）模式</h3><p>该模式有两种时钟源，分别是13M的RC振荡器和外部晶振XOSC，可以用命令 $SetStandby(oscillatorMode)$ 来进行切换。当选用XOSC作为时钟源时，自动切换为DCDC模块供电。也可使用如下命令手动设置供电：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetRegulatorType(regulatorType); <span class="comment">//该指令仅可在STDBY_RC模式使用</span></span><br></pre></td></tr></table></figure><h3 id="Frequency-Synthesis-FS-频率合成-模式"><a href="#Frequency-Synthesis-FS-频率合成-模式" class="headerlink" title="Frequency Synthesis (FS 频率合成)模式"></a>Frequency Synthesis (FS 频率合成)模式</h3><p>在FS模式下，模拟部分的PLL会按照设置的Tx开始震荡，当震荡稳定时，BUSY引脚就会变成低电平（标明设备已准备好接受指令）</p><p>在SX1280的设计中，RX和TX的频率是不同的，RX的频率等于Tx的频率（i.e., 锁相环产生的频率）减去中间频率(Intermediate Frequency IF)，IF默认是1.3MHz。</p><h3 id="Receice（接收）模式"><a href="#Receice（接收）模式" class="headerlink" title="Receice（接收）模式"></a>Receice（接收）模式</h3><p>在接收模式下除了FS模式启用的PLL外，片上LNA，相干器，和对应的解调器（LoRa/FSK/FLRC）都会开始工作。接受模式可设置为连续接收（continuous mode）和单次接收（single mode）。在连续接收模式下，模块会保持接收模式。在单次接收模式下，模块会在一次接收完成后返回STDBY模式。</p><p>接收模式通过官方驱动的SetRx函数来设置，其输入参数periodBase是指的时钟振荡周期，periodBaseCount是指的历经多少次时钟震荡算超时。当超时时，会从Receive mode 返回至 STDBY_RC mode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetRx(periodBase, periodBaseCount); <span class="comment">//Opcode 0x83</span></span><br></pre></td></tr></table></figure><h3 id="Transmit（发送）模式"><a href="#Transmit（发送）模式" class="headerlink" title="Transmit（发送）模式"></a>Transmit（发送）模式</h3><p>发送模式会在信号放大器（PA）启动完成后，发送待发送的数据包。在发送完成后自动返回STDBY_RC模式</p><h3 id="Sleep（睡眠）模式"><a href="#Sleep（睡眠）模式" class="headerlink" title="Sleep（睡眠）模式"></a>Sleep（睡眠）模式</h3><p>睡眠模式下，只有睡眠控制器模块和可选的64KHz RC时钟工作。睡眠模式仅能从STDBY_RC模式下进入。</p><p>唤醒的方式有：</p><ul><li>NSS（Pin 19）变成低电平</li><li>RTC定时器产生计时结束事件</li></ul><p>SX1280在上电时，会自动校准其RC时钟，PLL和ADC，在校准期间BUSY信号会保持高电平，在校准完成后会进入STDBY_RC模式，并使BUSY信号变为低电平以表示准备好接收指令。</p><p>上电校准的结果会有寄存器存储，因此在休眠模式被唤醒时无需再次校准。</p><h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><p>Sx1280使用串口发送opcode的形式来控制模块，串口可使用UART或SPI，二者发送命令和支持的功能（如校验、流控）有些许差异。详细介绍如下。</p><h2 id="使用UART和模块建立连接"><a href="#使用UART和模块建立连接" class="headerlink" title="使用UART和模块建立连接"></a>使用UART和模块建立连接</h2><ul><li>波特率：该模块支持的波特率有921.6K，460.6K，115.2K，57.6K，38.4K，19.2K，9.6K。 <strong>在上电时，默认以115200工作，通过配置寄存器更改其他波特率</strong></li><li>停止位：模块支持1或2个停止位，通过寄存器配置，<strong>上电默认一个停止位</strong></li><li>仅支持8byte数据</li><li>模块支持奇偶校验、无校验</li><li>模块支持在Rx满，Tx空，奇偶校验错误或无停止位时，产生中断</li></ul><p><strong>使用UART和模块通信时，主机必须提供长度信息，模块一旦接受到所需长度的信息，就会开始处理任务，命令格式通常为：opcode+后续长度+后续参数</strong></p><p>举个例子，在UART执行写寄存器的操作时，必须发送操作码+要写的首地址+数据的长度+数据+….+数据n。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209004243157.png" alt="image-20240209004243157"></p><p>在使用UART进行读寄存器时，发送完操作码+要读的首地址+数据的长度后，主机RX线便会收到从机的数据内容。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209004849480.png" alt="image-20240209004849480"></p><p>在使用UART指令时，模块一收到opcode就会将busy线拉高，然后在接收后续长度指定的命令个数后，将BUSY线重新拉低进行命令处理。</p><h2 id="使用SPI和模块建立连接"><a href="#使用SPI和模块建立连接" class="headerlink" title="使用SPI和模块建立连接"></a>使用SPI和模块建立连接</h2><ul><li>NSS引脚变成低电平使能，高电平失能</li><li>MOSI 由主机在 SCK 下降沿时产生，并由从机在 SCK 上升沿时采样。 MISO 由 SCK 下降沿的从机产生。</li><li>通信时钟SCK最高频率为18MHz</li></ul><p><strong>使用SPI和模块通信时，无需提供命令长度，以NSS信号线被拉高来结束一次通信即可，即，命令格式为：opcode+后续参数</strong></p><p>举个例子，在SPI执行写寄存器时，只需发送操作码+要写的首地址+数据+…+数据n，相较于UART无需发送数据长度。由NSS信号被拉高来标明当前写操作结束。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209004451160.png" alt="image-20240209004451160"></p><p>在使用SPI执行读寄存器时，要发送操作码+要读的首地址+NOP（0x00），MISO线才开始传输数据。也就是说，UART内数据长度的位置需要用一个NOP来顶替，以此达到一个延时等待响应的目的。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240209004819079.png" alt="image-20240209004819079"></p><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="Data-Buffer"><a href="#Data-Buffer" class="headerlink" title="Data Buffer"></a>Data Buffer</h2><p>片上Data Buffer有256Byte，用于存放待发送数据或接收数据，其如何分配是可编程的。可使用官方提供的接口来指定TX和RX所用buffer的基地址。除睡眠模式外，任何工作模式均可访问该buffer。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240208020605152.png" alt="image-20240208020605152"></p><h3 id="接收数据对Data-Buffer的写入"><a href="#接收数据对Data-Buffer的写入" class="headerlink" title="接收数据对Data Buffer的写入"></a>接收数据对Data Buffer的写入</h3><p>接收数据时，数据由 rxBaseAddress （也就是图中蓝色区域，SetBufferBaseAddress()指向的地方）开始写入，向上生长。然后由 RxDataPointer 指向数据顶部地址。在一开始时，RxDataPointer = rxBaseAddress 。</p><h3 id="发送数据读取Data-Buffer的方式"><a href="#发送数据读取Data-Buffer的方式" class="headerlink" title="发送数据读取Data Buffer的方式"></a>发送数据读取Data Buffer的方式</h3><p>在切换到传输模式时，会先由setPacketParam() 中的 payLoadLength 参数指明待发送的数据长度，然后由数据指针 TxDataPointer 初始化为 TxBaseAddress 的地址，发送一个字节自增1，直到发送的字节等于payLoadLength为止。</p><h2 id="模拟信号收发前端"><a href="#模拟信号收发前端" class="headerlink" title="模拟信号收发前端"></a>模拟信号收发前端</h2><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><ul><li><p><strong>自动增益控制(Automatic Gain Control AGC)</strong></p><p>用于确保接收机增益被设定成最佳的值来接收信号。可以通过以下寄存器配置：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120010721928.png" alt="image-20240120010721928" style="zoom:67%;" /></p></li></ul><p>人工配置增益时，寄存器数值于增益对应关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120010828585.png" alt="image-20240120010828585"></p><ul><li><strong>低功耗模式和高感模式</strong></li></ul><p>收模式分为低功耗模式和高灵敏度模式，通过配置寄存器0x891的bit6:7来控制。设置为3(11)的时候，为灵敏度模式，设置为0(00)的时候为低功耗模式</p><h3 id="片上RC震荡器"><a href="#片上RC震荡器" class="headerlink" title="片上RC震荡器"></a>片上RC震荡器</h3><p>片上RC振荡器有64KHz和13MHz两个频率，64KHz的用于休眠模式时钟，13MHz用于SPI或UART通信</p><p>RC振荡器需要在上电或环境温度发生变化时进行校准。校准使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先配置需要校准的，选项如下:</span></span><br><span class="line"> calibParam.ADCBulkPEnable = <span class="number">1</span>;</span><br><span class="line"> calibParam.ADCBulkNEnable = <span class="number">1</span>;</span><br><span class="line"> calibParam.ADCPulseEnable = <span class="number">1</span>;</span><br><span class="line"> calibParam.PLLEnable = <span class="number">1</span>;</span><br><span class="line"> calibParam.RC13MEnable = <span class="number">1</span>;</span><br><span class="line"> calibParam.RC64KEnable = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//然后调用函数校准</span></span><br><span class="line">Radio.Calibrate(calibParam); <span class="comment">//opcode 0x89</span></span><br></pre></td></tr></table></figure><h1 id="指令操作码（OPcode）"><a href="#指令操作码（OPcode）" class="headerlink" title="指令操作码（OPcode）"></a>指令操作码（OPcode）</h1><p><em>在以下笔记中，所有NOP表示数据0x00，指令顺序中用+连接的是通过不同数据帧发送的不同byte，比如0x01+0x02是先发送0x01再发送0x02</em></p><h2 id="寄存器相关"><a href="#寄存器相关" class="headerlink" title="寄存器相关"></a>寄存器相关</h2><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">写寄存器数据</td><td style="text-align:center">0x18</td><td style="text-align:center">操作码+地址[15:8]+地址[7:0]+数据…+数据n</td><td style="text-align:center">操作码+地址[15:8]+地址[7:0]+长度+数据…+数据n</td></tr><tr><td style="text-align:center">读寄存器数据</td><td style="text-align:center">0x19</td><td style="text-align:center">操作码+地址[15:8]+地址[7:0]+NOP</td><td style="text-align:center">操作码+地址[15:8]+地址[7:0]+长度</td></tr></tbody></table></div><h2 id="数据缓冲区-Buffer-相关"><a href="#数据缓冲区-Buffer-相关" class="headerlink" title="数据缓冲区(Buffer)相关"></a>数据缓冲区(Buffer)相关</h2><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">写Buffer数据</td><td style="text-align:center">0x1A</td><td style="text-align:center">操作码+地址偏移+数据…+数据n</td><td style="text-align:center">操作码+地址偏移+长度+数据…+数据n</td></tr><tr><td style="text-align:center">读Buffer数据</td><td style="text-align:center">0x1B</td><td style="text-align:center">操作码+地址偏移+NOP</td><td style="text-align:center">操作码+地址偏移+长度</td></tr></tbody></table></div><h2 id="模式切换相关"><a href="#模式切换相关" class="headerlink" title="模式切换相关"></a>模式切换相关</h2><h3 id="睡眠模式"><a href="#睡眠模式" class="headerlink" title="睡眠模式"></a>睡眠模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetSleep</td><td style="text-align:center">0x84</td><td style="text-align:center">操作码+睡眠配置</td><td style="text-align:center">操作码+睡眠配置</td></tr></tbody></table></div><p>其中睡眠配置为1byte，但只有低二位有用，其余bit保持0。例如0x01,0x03等：</p><ul><li>第0位：如果该位被置1，那么在RAM中的部分数据会被存放进非易失存储器（称为 retention mode）。否则RAM数据被刷新。RAM主要用于存放模块初始化设置，被备份的数据如下：<ul><li>SetPacketType()</li><li>SetModulationParams()</li><li>SetRfFrequency()</li><li>SetDioIrqParams()</li><li>SetCadParams()</li></ul></li></ul><ul><li>第1位：如果该为被置1，那么Data buffer中的数据会被存放进非易失存储器。否则Data Buffer内数据被刷新。</li></ul><h3 id="待机模式"><a href="#待机模式" class="headerlink" title="待机模式"></a>待机模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetStandby</td><td style="text-align:center">0x80</td><td style="text-align:center">操作码+待机配置</td><td style="text-align:center">操作码+0x01+待机配置</td></tr></tbody></table></div><p>其中待机配置为1byte，但只有LSB有用，其余bit保持0，也就是只有0x00和0x01两种：</p><ul><li>0x00：STDBY_RC模式，使用13MHz RC振荡器做为时钟源</li><li>0x01：STDBY_XOSC模式，使用外部晶振做为时钟源</li></ul><h3 id="频率合成模式（FS-mode）"><a href="#频率合成模式（FS-mode）" class="headerlink" title="频率合成模式（FS mode）"></a>频率合成模式（FS mode）</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetFs</td><td style="text-align:center">0xC1</td><td style="text-align:center">操作码</td><td style="text-align:center">操作码</td></tr></tbody></table></div><h3 id="发送模式"><a href="#发送模式" class="headerlink" title="发送模式"></a>发送模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th></tr></thead><tbody><tr><td style="text-align:center">SetTx</td><td style="text-align:center">0x83</td></tr><tr><td style="text-align:center"><strong>SPI模式指令顺序</strong></td><td style="text-align:center"><strong>UART模式指令顺序</strong></td></tr><tr><td style="text-align:center">操作码+periodBase+periodBaseCount[15:8]+periodBaseCount[7:0]</td><td style="text-align:center">操作码+0x03(后续长度)+periodBase+periodBaseCount[15:8]+periodBaseCount[7:0]</td></tr></tbody></table></div><p><em>note：在设置为发送模式前，需要先清除IRQ status</em></p><p><strong>Single Mode Tx</strong>： 如果periodBase和PeriodBaseCount都设置为0x00，即，传输指令0x83+0x00+0x00（SPI模式下），那么模块将工作在单次发模式（Single Mode Tx）。在该模式下，不会有超时限制，会在发送一个包之后结束Tx模式。</p><p><strong>发送模式的流程</strong>： 1. 打开PLL     2. 打开PA（功率放大器）     3. PA根据SetTxParam函数设置的模式，进行上升     4. 待PA上升完成，数据开始分包传输 5.传输完成后，关闭PA，关闭PLL，收发器返回STDBY_RC模式，并产生中断“IRQ TxDone”     6.若传输超时，则中断传输，返回STDBY_RC模式，并产生中断“TIMEOUT IRQ”。</p><p><strong>periodBase参数：</strong> 这个参数影响RTC时钟一步的计时时长，表如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">periodBase</th><th style="text-align:center">Time-Out step</th></tr></thead><tbody><tr><td style="text-align:center">0x00</td><td style="text-align:center">15.625us</td></tr><tr><td style="text-align:center">0x01</td><td style="text-align:center">62.5us</td></tr><tr><td style="text-align:center">0x02</td><td style="text-align:center">1ms</td></tr><tr><td style="text-align:center">0x03</td><td style="text-align:center">4ms</td></tr></tbody></table></div><p><strong>PeriodBaseCount参数</strong>：该参数有16位，用于指明在计数多少个周期后超时。计算公式如下：</p><script type="math/tex; mode=display">Time-out\ duration = periodBase\times periodBaseCount</script><p>如果该为被设置为0x00，那么直到单个包发送完成之前，都不会退出Tx模式，无超时限制。当单个包发送完之后返回STDBY_RC模式。</p><h3 id="接收模式"><a href="#接收模式" class="headerlink" title="接收模式"></a>接收模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th></tr></thead><tbody><tr><td style="text-align:center">SetRx</td><td style="text-align:center">0x82</td></tr><tr><td style="text-align:center"><strong>SPI模式指令顺序</strong></td><td style="text-align:center"><strong>UART模式指令顺序</strong></td></tr><tr><td style="text-align:center">操作码+periodBase+periodBaseCount[15:8]+periodBaseCount[7:0]</td><td style="text-align:center">操作码+0x03(后续长度)+periodBase+PeriodBaseCount[15:8]+PeriodBaseCount[7:0]</td></tr></tbody></table></div><p><em>note：在设置为发送模式前，需要先清除IRQ status</em></p><p>接收模式的参数意义同发送模式，但它可以设置单次接收模式，连续接收模式，超时模式三种，表如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">periodBaseCount</th><th style="text-align:center">超时时间</th></tr></thead><tbody><tr><td style="text-align:center">0x0000</td><td style="text-align:center">单次接收模式，没有超时时间，但在完成一个包的接收之后返回STDBY_RC模式</td></tr><tr><td style="text-align:center">0xFFFF</td><td style="text-align:center">连续接收模式，设备一直保持接收模式，直到主机发送改变模式的命令。每次接收到数据包时，都会向主机发送已接收新的数据包的指示。</td></tr><tr><td style="text-align:center">其他</td><td style="text-align:center">超时时间=超时基周期*超时计数数量</td></tr></tbody></table></div><p><em>举个例子，保持一秒接收模式：0x82+0x03+0x00+0xFA</em></p><h2 id="特殊模式"><a href="#特殊模式" class="headerlink" title="特殊模式"></a>特殊模式</h2><h3 id="嗅探模式"><a href="#嗅探模式" class="headerlink" title="嗅探模式"></a>嗅探模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th></tr></thead><tbody><tr><td style="text-align:center">SetRxDutyCycle</td><td style="text-align:center">0x94</td></tr><tr><td style="text-align:center"><strong>SPI模式指令顺序</strong></td><td style="text-align:center"><strong>UART模式指令顺序</strong></td></tr><tr><td style="text-align:center">操作码+periodBase+periodBaseCount[15:8]+periodBaseCount[7:0]+<br>sleepPeriodBaseCount[15:8]+sleepPeriodBaseCount[7:0]</td><td style="text-align:center">操作码后面+0x05（后续长度）</td></tr></tbody></table></div><p>在嗅探模式（sniff mode）下，模块会周期性地寻找新的包。<strong>在此模式下，用于preamble必须被设置为long preamble mode。因此使用这个指令之前必须使用SetLongPreamble设置preamble模式。</strong></p><p>该模式下periodBase同Tx模式中的表。</p><p><strong>periodBaseCount</strong>：该位用于指明模块唤醒，查询新包的时间</p><p><strong>sleepPeriodBaseCount</strong>：用于指明模块休眠的时间</p><ol><li>模块会进入接收模式，寻找新的包，寻找的时间由periodBaseCount决定。</li><li>如果接收模式的窗口期内没有嗅探到preamble，模块会进入睡眠模式（设置会被保存）。睡眠时间由sleepPeriodBaseCount定义。</li><li>在睡眠时间结束后，模块会将设置重新存会RAM，并返回接收模式，重新嗅探包。</li><li>当如下事件发生时，嗅探模式会被停止：<ul><li>在Rx模式窗口期间，接受到了数据包，在接收完成后会产生”RxDone”中断，并返回STDBY_RC模式</li><li>在Rx模式窗口期间，收到了来自主机的SetStandby()命令。<em>注意：在sleep模式下无法接收命令</em></li></ul></li></ol><p><strong>如果periodBaseCount被设置为0x0000，那么又会进入单次接收模式，没有超时限制，模块会保持接收模式直到收到新的数据包，然后返回STDBY_RC模式。设置为其他数据时，periodBaseCount才能用于指定接收的窗口期长度</strong></p><h3 id="信道活动检测模式（Channel-Activity-Detection-CAD）"><a href="#信道活动检测模式（Channel-Activity-Detection-CAD）" class="headerlink" title="信道活动检测模式（Channel Activity Detection CAD）"></a>信道活动检测模式（Channel Activity Detection CAD）</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetCAD</td><td style="text-align:center">0xC5</td><td style="text-align:center">操作码</td><td style="text-align:center">操作码</td></tr></tbody></table></div><p><strong>该模式仅能在LoRa调制下使用</strong>。该模式下，模块会寻找LoRa的信号，寻找的Preamble长度由SetCadParams()操作来设置。在寻找结束后，模块会返回STDBY_RC模式。在寻找结束时，设备会产生“CadDone”中断，如果有效的信号被找到了，还会产生“CadDetected”中断</p><p><em>这个模式在需要先收后发的应用中非常实用</em></p><p>参数设置命令SetCadParams()</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetCadParams</td><td style="text-align:center">0x88</td><td style="text-align:center">操作码+cadSymbolNum</td><td style="text-align:center">操作码+0x01+cadSymbolNum</td></tr></tbody></table></div><p>其中，cadSymbolNum用于指明触发CAD的符号数（变相决定了寻找时长），定义如下</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215160705990.png" alt="image-20240215160705990"></p><p><strong><em>注意：用于CAD的符号数设置为1和2时，错误检测风险较高</em></strong></p><h2 id="基本设置相关"><a href="#基本设置相关" class="headerlink" title="基本设置相关"></a>基本设置相关</h2><h3 id="长Preamble模式"><a href="#长Preamble模式" class="headerlink" title="长Preamble模式"></a>长Preamble模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetLongPreamble</td><td style="text-align:center">0x98</td><td style="text-align:center">操作码+enable（0x01）</td><td style="text-align:center">-</td></tr></tbody></table></div><p><strong>该指令只能在LoRa模式或GFSK模式使用</strong>。这个指令对LoRa的影响是：会修改嗅探模式SetRxDutyCycle的行为，如果有preamble被侦测到，那么RX模式的时间会被拓展为 $sleepPeriod+2*RxPeriod$</p><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetAutoTx</td><td style="text-align:center">0x98</td><td style="text-align:center">操作码+time[15:8]+time[7:0]</td><td style="text-align:center">操作码+0x02+time[15:8]+time[7:0]</td></tr></tbody></table></div><p>部分通信协议要求在收到数据包后发送一个应答包，例如BLE要求在收到数据包后150us发送回应。这个命令就是用来设置自动回应用的。回应延时由time参数控制，由于从RX模式切换到TX模式需要时间，因此需要一个Offset来修正，通常$offset\approx 33us$。延时计算公式如下</p><script type="math/tex; mode=display">Tx_{Delay}=time+offset</script><p>time就是输入的time参数，该参数以毫秒为单位。time参数传递0x0001就是1us。</p><p>只要这个命令被发送了，那么每当设备进入Rx模式并收到了数据包后，就会自动切入Tx模式，在延时$Tx_{Delay}$后发送一个应答包，然后回到普通模式（例如STDBY_RC模式）。</p><p><em>note:user must issue the command SetAutoTx with 0x00 as the time argument</em></p><h3 id="传输完成后返回FS模式"><a href="#传输完成后返回FS模式" class="headerlink" title="传输完成后返回FS模式"></a>传输完成后返回FS模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetAutoFS</td><td style="text-align:center">0x9E</td><td style="text-align:center">操作码+enable（0x01）</td><td style="text-align:center">操作码+0x01+enable（0x01）</td></tr></tbody></table></div><p>默认情况下，Rx和Tx模式结束后都会返回STDBY_RC模式，如果使用了此命令，那么则是返回至FS模式。这样可以减少切换至Rx或Tx模式的时间。</p><p>enbale用于控制该功能是否启用，0x01表示使能，0x00表示失能。</p><h3 id="包格式选择"><a href="#包格式选择" class="headerlink" title="包格式选择"></a>包格式选择</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetPacketType</td><td style="text-align:center">0x8A</td><td style="text-align:center">操作码+PacketType</td><td style="text-align:center">操作码+0x01+PacketType</td></tr></tbody></table></div><p>PacketType参数用于指定调制包格式，定义如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240211172403669.png" alt="image-20240211172403669"></p><p><em>例如：选择LoRa包格式，发送指令为0x8A+0x01</em></p><h3 id="设置包参数"><a href="#设置包参数" class="headerlink" title="设置包参数"></a>设置包参数</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetPacketParams</td><td style="text-align:center">0x8C</td><td style="text-align:center">操作码+param1…param7</td><td style="text-align:center">操作码+0x07+param1…param7</td></tr></tbody></table></div><p> 对于7个parameter，其作用如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215162800145.png" alt="image-20240215162800145"></p><p>在LoRa模式下，几个参数详细定义如下</p><p><strong>PreambleLength</strong>（参数1）</p><p>改Byte由两部分组成，LORA_PBLE_LEN_MANT[3:0] 和 LORA_PBLE_LEN_EXP[7:4]。mant表示尾数，exp表示指数，MANT占低四位，EXP占高四位，它们各自的范围都在[1,15]之间（注意不可为0）。preamble的长度和这两个参数的关系如下：</p><script type="math/tex; mode=display">preamble\ length=LORA\_PBLE\_LEN\_MANT*2^{LORA\_PBLE\_LEN\_EXP}</script><p>推荐的preamble长度是12 symbols，也就是将MANT设置为6，EXP设置为1，即可得到该值。</p><p><strong>HeaderType</strong>（参数2）</p><p>Header用于指明LoRa包中是否包含Header，详见LoRa包格式章节。</p><div class="table-container"><table><thead><tr><th style="text-align:center">宏定义关键词</th><th style="text-align:center">值</th><th style="text-align:center">Header模式</th></tr></thead><tbody><tr><td style="text-align:center">EXPLICIT_HEADER</td><td style="text-align:center">0x00</td><td style="text-align:center">EXPLICIT HEADER</td></tr><tr><td style="text-align:center">IMPLICIT_HEADER</td><td style="text-align:center">0x80</td><td style="text-align:center">IMPLICIT HEADER</td></tr></tbody></table></div><p><strong>PayloadLength</strong>（参数3）</p><p>该参数值的范围在 [1,255] 之间。用于指明载荷数据的长度。</p><p><strong>CRC</strong>（参数4）</p><p>该参数用于控制CRC使能与否</p><div class="table-container"><table><thead><tr><th style="text-align:center">宏定义关键词</th><th style="text-align:center">值</th><th style="text-align:center">CRC使能情况</th></tr></thead><tbody><tr><td style="text-align:center">LORA_CRC_ENABLE</td><td style="text-align:center">0x20</td><td style="text-align:center">CRC ENABLE</td></tr><tr><td style="text-align:center">LORA_CRC_DISABLE</td><td style="text-align:center">0x00</td><td style="text-align:center">CRC DISABLE</td></tr></tbody></table></div><h3 id="设置调制参数"><a href="#设置调制参数" class="headerlink" title="设置调制参数"></a>设置调制参数</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetModulationParams</td><td style="text-align:center">0x8B</td><td style="text-align:center">操作码+param[0]+param[1]+param[2]</td><td style="text-align:center">操作码+0x03+param[0]+param[1]+param[2]</td></tr></tbody></table></div><p>该指令的param参数在不同包格式下有不同意义，此处只介绍LoRa包格式下</p><ul><li>param[0]：扩展因子SF，值，宏定义和SF间关系如下表</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">宏定义</th><th style="text-align:center">值</th><th style="text-align:center">SF</th></tr></thead><tbody><tr><td style="text-align:center">LORA_SF_5</td><td style="text-align:center">0x50</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">LORA_SF_6</td><td style="text-align:center">0x60</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">LORA_SF_7</td><td style="text-align:center">0x70</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">LORA_SF_8</td><td style="text-align:center">0x80</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">LORA_SF_9</td><td style="text-align:center">0x90</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">LORA_SF_10</td><td style="text-align:center">0xA0</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">LORA_SF_11</td><td style="text-align:center">0xB0</td><td style="text-align:center">11</td></tr><tr><td style="text-align:center">LORA_SF_12</td><td style="text-align:center">0xC0</td><td style="text-align:center">12</td></tr></tbody></table></div><ul><li>param[1]：带宽BW，值，宏定义和SF间关系如下表</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">宏定义</th><th style="text-align:center">值</th><th style="text-align:center">BW (KHz)</th></tr></thead><tbody><tr><td style="text-align:center">LORA_BW_1600</td><td style="text-align:center">0x0A</td><td style="text-align:center">1625.0</td></tr><tr><td style="text-align:center">LORA_BW_800</td><td style="text-align:center">0x18</td><td style="text-align:center">812.5</td></tr><tr><td style="text-align:center">LORA_BW_400</td><td style="text-align:center">0x26</td><td style="text-align:center">406.25</td></tr><tr><td style="text-align:center">LORA_BW_200</td><td style="text-align:center">0x34</td><td style="text-align:center">203.125</td></tr></tbody></table></div><ul><li>param[2]：前向纠错编码率CR，CR，值，宏定义和SF间关系如下表<br>|     宏定义     |  值  | 编码率 |<br>| :——————: | :—: | :——: |<br>|  LORA_CR_4_5   | 0x01 |  4/5   |<br>|  LORA_CR_4_6   | 0x02 |  4/6   |<br>|  LORA_CR_4_7   | 0x03 |  4/7   |<br>|  LORA_CR_4_8   | 0x04 |  4/8   |<br>| LORA_CR_Li_4_5 | 0x05 |  4/5<em>  |<br>| LORA_CR_Li_4_6 | 0x06 |  4/6</em>  |<br>| LORA_CR_Li_4_7 | 0x07 |  4/8*  |</li></ul><p>上表中 * 代表长交织。</p><ul><li>以上参数详见 <em>LoRa基础</em> 篇</li></ul><h3 id="设置RF频率模式频率"><a href="#设置RF频率模式频率" class="headerlink" title="设置RF频率模式频率"></a>设置RF频率模式频率</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetRfFrequency</td><td style="text-align:center">0x86</td><td style="text-align:center">操作码+频率[23:16]+频率[15:8]+频率[7:0]</td><td style="text-align:center">操作码+0x03+频率[23:16]+频率[15:8]+频率[7:0]</td></tr></tbody></table></div><p>其中，频率(rfFrequency)参数与发射频率间公式如下：</p><script type="math/tex; mode=display">F_{RF}=\frac{F_{XOSC}}{2^{18}}*rfFrequency</script><p><em>例如：通过SPI发送0x86+0xB8+0x9D+0x89，即可设置rfFrequency=12098953（D），在外部晶振52MHz的情况下，$F_{RF}=2399999832Hz$，即，2.4GHz</em></p><h3 id="设置发送功率"><a href="#设置发送功率" class="headerlink" title="设置发送功率"></a>设置发送功率</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetTxParams</td><td style="text-align:center">0x8E</td><td style="text-align:center">操作码+power+rampTime</td><td style="text-align:center">操作码+0x02+power+rampTime</td></tr></tbody></table></div><p>power参数用于控制发射功率，SX1280支持的<strong>功率范围在-18~13dBm</strong>，其与power参数的关系公式如下</p><script type="math/tex; mode=display">P_{RF}=-18+power</script><p>也就是说，<strong>power参数的范围在[0,31]区间内。</strong></p><p>rampTime参数用于控制运放（PA）的上升时间，官方驱动中的宏定义、参数和时间对应表如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215142108205.png" alt="image-20240215142108205"></p><h3 id="设置数据缓冲区-buffer-基地址"><a href="#设置数据缓冲区-buffer-基地址" class="headerlink" title="设置数据缓冲区(buffer)基地址"></a>设置数据缓冲区(buffer)基地址</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetBufferBaseAddress</td><td style="text-align:center">0x8F</td><td style="text-align:center">操作码+txBaseAdress+rxBaseAdress</td><td style="text-align:center">操作码+0x02+txBaseAdress+rxBaseAdress</td></tr></tbody></table></div><p>数据缓冲区rx和tx共享256字节空间，地址从0x00到0xFF之间。详见硬件-Data buffer</p><h3 id="选择供电"><a href="#选择供电" class="headerlink" title="选择供电"></a>选择供电</h3><p>如果在DC-DC外接电感条件满足的情况下，可以使用该命令切换供电模式。</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetRegulatorMode</td><td style="text-align:center">0x96</td><td style="text-align:center">操作码+regModeParam</td><td style="text-align:center">操作码+0x01+regModeParam</td></tr></tbody></table></div><p>其中regModeParam有：</p><ul><li><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120040942451.png" alt="image-20240120040942451"></li></ul><h3 id="设置UART速率"><a href="#设置UART速率" class="headerlink" title="设置UART速率"></a>设置UART速率</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetUartSpeed</td><td style="text-align:center">0x9D</td><td style="text-align:center">不可用，仅UART能使用</td><td style="text-align:center">操作码+0x02+UartDividerRatio</td></tr></tbody></table></div><p>其中，UartDibiderRatio是一个4byte数字，它与波特率的关系是：</p><script type="math/tex; mode=display">UartDibiderRatio=(Baud\ Rate\times2^{20})/f_{CLK}</script><p>其典型值如下：</p><p><img src="C:\Users\17997\AppData\Roaming\Typora\typora-user-images\image-20240415151802336.png" alt="image-20240415151802336"></p><h3 id="设置测距角色"><a href="#设置测距角色" class="headerlink" title="设置测距角色"></a>设置测距角色</h3><p>该命令用于测距的主从角色设置</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetRangingRole</td><td style="text-align:center">0xA3</td><td style="text-align:center">操作码+Role</td><td style="text-align:center">操作码+0x01+Role</td></tr></tbody></table></div><p>其中Role：</p><ul><li>0x00：从机（slave）</li><li>0x01：主机（master）</li></ul><h3 id="是否启用高级测距-AdvancedRanging"><a href="#是否启用高级测距-AdvancedRanging" class="headerlink" title="是否启用高级测距(AdvancedRanging)"></a>是否启用高级测距(AdvancedRanging)</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetAdvancedRanging</td><td style="text-align:center">0x9A</td><td style="text-align:center">操作码+Enable</td><td style="text-align:center">操作码+0x01+Enable</td></tr></tbody></table></div><p>其中，0x00表示disable，0x01表示enable。</p><h2 id="获取设备工作状态"><a href="#获取设备工作状态" class="headerlink" title="获取设备工作状态"></a>获取设备工作状态</h2><h3 id="获取设备状态"><a href="#获取设备状态" class="headerlink" title="获取设备状态"></a>获取设备状态</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">GetStatus</td><td style="text-align:center">0xC0</td><td style="text-align:center">操作码</td><td style="text-align:center">操作码</td></tr></tbody></table></div><p>该命令用于检索收发器的状态，任意模式（STDBY，RX，TX）都可以执行该命令。模块会在收到该操作码后返回1byte的设备状态码，状态码定义如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240216151615876.png" alt="image-20240216151615876"></p><h3 id="获取当前包格式"><a href="#获取当前包格式" class="headerlink" title="获取当前包格式"></a>获取当前包格式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">GetPacketType</td><td style="text-align:center">0x03</td><td style="text-align:center">操作码+NOP+NOP</td><td style="text-align:center">操作码+0x01</td></tr></tbody></table></div><p>模块会在SPI命令的第二个NOP时，向主机发送当前包格式数据。UART通信下，在0x01发送完之后的空隙位返回包格式。</p><p>包格式如下</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240211172403669.png" alt="image-20240211172403669"></p><h3 id="获取Rx缓冲区状态"><a href="#获取Rx缓冲区状态" class="headerlink" title="获取Rx缓冲区状态"></a>获取Rx缓冲区状态</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">GetRxBufferStatus</td><td style="text-align:center">0x17</td><td style="text-align:center">操作码+NOP+NOP+NOP</td><td style="text-align:center">操作码+0x02</td></tr></tbody></table></div><p>该命令会先后返回最后收到的数据包的长度（rxPayloadLength）和Rx缓冲区的基地址（rxStartBufferPointer）。在发送操作码后，SPI命令间隔一个NOP后开始接收，先接收rxPayloadLength，再接收rxStartBufferPointer。UART命令在发送0x02后开始接收。</p><p><em>注意：当采用LoRa包格式，且设置为Implicit Header（Fixed-length）模式的时候，rxPayloadLength参数会始终返回0x00。因为在这个模式中不存在Header，因此无法提取Payload长度。在这种模式下，要得知Payload长度，直接通过寄存器操作命令，读取预先设置的寄存器即可。</em></p><h3 id="获取当前包状态"><a href="#获取当前包状态" class="headerlink" title="获取当前包状态"></a>获取当前包状态</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">GetPacketStatus</td><td style="text-align:center">0x1D</td><td style="text-align:center">操作码+NOP+NOP+NOP+NOP+NOP+NOP(6个 NOP)</td><td style="text-align:center">操作码+0x05</td></tr></tbody></table></div><p>使用此命令可以检索有关上次接收的数据包的信息，命令会在SPI模式的第一个NOP后，UART模式的长度码后，开始返回信息。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215164517698.png" alt="image-20240215164517698"></p><p>信息总共有5位。不同包格式返回的信息意义不同，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215164255603.png" alt="image-20240215164255603"></p><p>对于LoRa包模式下，参数意义如下</p><ul><li>rssiSync：:Received Signal Strength Indicator，信号强度。一旦检测到同步地址，就会锁存rssiSync值，根据rssiSync可算出真实信号功率：$P=-(rssiSync)/2(dBm)$</li><li>snrPkt：信噪比，该值由最后一个数据包估计得出。实际SNR和该值换算关系是$SNR=snrPkt/4 (dB)$。如果SNR&lt;=0，那么RSSI值需要修正为：$RSSI_\{packet, real\} = RSSI_\{packet,measured\} – SNR_\{measured\}$</li></ul><h3 id="获取当前瞬时-RSSI-值"><a href="#获取当前瞬时-RSSI-值" class="headerlink" title="获取当前瞬时 RSSI 值"></a>获取当前瞬时 RSSI 值</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">Getressiinst</td><td style="text-align:center">0x1F</td><td style="text-align:center">操作码+NOP+NOP</td><td style="text-align:center">操作码+0x01</td></tr></tbody></table></div><p>该指令会在SPI模式第二个NOP，UART指令发送完0x01后，返回参数rssiInst参数（8位），用于指明当前包的RSSI强度，参数值与强度对应关系如下：</p><script type="math/tex; mode=display">Signal Power=(-rssiInst)/2(dBm)</script><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>SX1280有16个中断源，每一个都可以单独启用或是屏蔽，每一个也都可以被映射至DIO1,DIO2,DIO3。中断寄存器和中断源如下表：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215170132747.png" alt="image-20240215170132747"></p><h3 id="设置DIO和中断映射、中断使能"><a href="#设置DIO和中断映射、中断使能" class="headerlink" title="设置DIO和中断映射、中断使能"></a>设置DIO和中断映射、中断使能</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th></tr></thead><tbody><tr><td style="text-align:center">SetDioIrqParams</td><td style="text-align:center">0x8D</td></tr></tbody></table></div><p>SPI指令顺序：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215170643786.png" alt="image-20240215170643786"></p><p>UART指令顺序</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240215170703777.png" alt="image-20240215170703777"></p><p><strong>irqMask参数</strong></p><p>​    该参数用于使能中断，1表示使能，0表示失能。参考上方中断寄存器和中断源表，其左边的bit对应的就是该参数。例如，要使能TxDone中断，就需要把irqMask的bit0设置为1，此时，产生中断时，IRQ Register中对应的 TxDone 才会被置1。</p><p><strong>dioMask参数</strong></p><p>​    该参数用于标明链接哪些中断到DIO引脚上。例如，如果想要TxDone中断产生时，DIO1引脚也被置1，就需要置位irqMask bit0 来使能中断，然后置位dio1Mask bit0 来链接该中断至DIO1。任意中断都可被映射至所有DIO，对于某一个DIO，当映射至该脚位的所有中断标志都为0的时候，IO输出0，否则输出1（或运算的逻辑）。</p><h3 id="获取中断状态"><a href="#获取中断状态" class="headerlink" title="获取中断状态"></a>获取中断状态</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">GetIrqStatus</td><td style="text-align:center">0x15</td><td style="text-align:center">操作码+NOP+NOP+NOP</td><td style="text-align:center">操作码+0x02</td></tr></tbody></table></div><p>该指令会在SPI模式第二个NOP，UART指令发送完0x02后，先后返回irqStatus[15:8]和irqStatus[7:0]。这是16位IRQ寄存器中的值的状态，对应本小节中最开始的寄存器表。</p><h3 id="清除中断标志"><a href="#清除中断标志" class="headerlink" title="清除中断标志"></a>清除中断标志</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">ClearIrqStatus</td><td style="text-align:center">0x97</td><td style="text-align:center">操作码+IRQMASK[15:8]+IRQMASK[7:0]</td><td style="text-align:center">操作码+0x02+IRQMASK[15:8]+IRQMASK[7:0]</td></tr></tbody></table></div><p>将需要清除的中断在对应的IRQMASK位中置1，即可清除中断。例如，如果IRQMASK的位0置1，则IRQ寄存器中的位0处的IRQ标志清0。</p><h2 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h2><h3 id="发送连续波"><a href="#发送连续波" class="headerlink" title="发送连续波"></a>发送连续波</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetTxContinuousWave</td><td style="text-align:center">0xD1</td><td style="text-align:center">操作码</td><td style="text-align:center">操作码</td></tr></tbody></table></div><p>该命令会使模块以设置的频率和功率发送连续的波。直到主机发送切换模式的命令之前，设备都会保持在发送连续波的模式中。这个命令对除了FLRC之外的所有包格式都适用。</p><h3 id="发送连续Preamble"><a href="#发送连续Preamble" class="headerlink" title="发送连续Preamble"></a>发送连续Preamble</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">操作码</th><th style="text-align:center">SPI模式指令顺序</th><th style="text-align:center">UART模式指令顺序</th></tr></thead><tbody><tr><td style="text-align:center">SetTxContinuousPreamble</td><td style="text-align:center">0xD2</td><td style="text-align:center">操作码</td><td style="text-align:center">操作码</td></tr></tbody></table></div><p>在GFSK包格式下，这个命令会使得天线发送交变的”0”和“1”。在LoRa模式下，这个命令会发送“0” （也就是LoRa的Preamble）。在主机发送更改模式的命令之前都会保持发送。</p><h1 id="驱动LoRa的步骤"><a href="#驱动LoRa的步骤" class="headerlink" title="驱动LoRa的步骤"></a>驱动LoRa的步骤</h1><h2 id="初始化设备"><a href="#初始化设备" class="headerlink" title="初始化设备"></a>初始化设备</h2><ol><li>SX1280在上电复位时，会默认进入STDBY_RC模式，如果不处于该模式，必须使用 <code>SetStandby</code> 附加 0x00 参数，使其切换至STDBY_RC模式；UART指令为0x80+0x01+0x00；</li><li>使用 <code>SetPacketType</code>附加LoRa包格式的参数（0x01），选择为LoRa数据包格式；UART指令顺序为0x8A+0x01+0x01；</li><li>设置RF的频率，通常设置为2.4G即可，其他值可参照操作码中 SetRfFrequency 章节；UART指令为：0x86+0x03+0xB8+0x9D+0x89，SPI下命令组合为：0x86+0xB8+0x9D+0x89</li><li>通过 <code>SetBufferBaseAddress</code> 指定数据buffer内rx和tx的基地址通过 <code>SetModulationParams</code> 设置LoRa的SF，BW 和 CR</li><li>通过 <code>SetPacketParams</code> 选择LoRa需要使用的Preamble长度（推荐12个符号），Header类型，数据长度，CRC类型，是否反转IQ</li><li>通过 <code>SetTxParam</code> 设置发信输出功率和ramp time</li><li>通过 <code>SetDioIrqParams</code> 使能和映射相应中断</li></ol><h2 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h2><ol><li>通过 <code>WriteBuffer(offset, *数据)</code> <em>(官方驱动API)</em> 将数据写入 Data Buffer，offset 的值通常设为 txBaseAddress 即可</li><li>通过 <code>SetTx</code>发送数据，直到 TxDone 或是 RxTxTimeout 中断产生，代表发送结束</li><li>清除中断</li></ol><h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><ol><li>通过 SetRx 将设备置于接收模式，等待 RxDone 或 RxTxTimeout</li><li>通过 ClrIrqStatus 清除中断</li><li>通过 GetRxBufferStatus 取得 PayloadLengthRx 和 rxStartBufferPointer</li><li>使用 ReadBuffer(offset, PayloadLengthRx) 来读取接受的buffer数据，其中offset = rxStartBufferPointer</li></ol><h2 id="测距"><a href="#测距" class="headerlink" title="测距"></a>测距</h2><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>在测距中，LoRa模块通过地址码来寻找测距对象。因此测距从机需要设置一个自己的地址码。通过<code>WriteRegister</code>函数（操作码0x18），对以下地址进行写入，来设置做为从机的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240415142233755.png" alt="image-20240415142233755"></p><p>同时，从机通过设置0x931寄存器的7:6位来选择使能的地址长度</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240415144759048.png" alt="image-20240415144759048"></p><p>同时，在<em>LoRa通信包和测距-测距引擎</em>一节中，提到需要对RX和TX消耗的时间进行补偿，以及对特定SF，BW，RF下的延迟进行补偿。这个补偿写入在下列寄存器内</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240415145736387.png" alt="image-20240415145736387"></p><h3 id="驱动步骤"><a href="#驱动步骤" class="headerlink" title="驱动步骤"></a>驱动步骤</h3><ol><li><p>首先确保设备在STDBY_RC模式</p></li><li><p>使用<code>SetPacketType</code>，将模块包格式设置为<code>PACKET_TYPE_RANGING</code>(0x02)</p></li><li><p>使用<code>SetModulationParams</code>讲主机与从机设置在同样的SF、BW和CR下。<strong>注意：测距不允许使用SF11和SF12，且带宽只能是406.25KHz / 812.5KHz / 1625KHz</strong></p></li><li><p>在如下寄存器地址中写入要测距的从机的地址<br> <img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240415144842613.png" alt="image-20240415144842613"></p></li><li><p>主机使能中断：<code>RangingMasterRestltValid</code>和<code>RangingMasterResultTimeout</code></p></li><li><p>从机使能中断：<code>RangingSlaveResponseDone</code>和<code>RangingSlaveRequestDiscarded</code></p></li><li><p>调用<code>SetRangingRole</code>，分别配置主机和从机的测距角色</p></li><li><p>从机使用<code>SetRx</code>切换直接收模式，主机使用<code>SetTx</code>发送测距包</p></li><li><p><strong>测距的调制解调器会自动设置主从机在收发过程中Tx和Rx的切换</strong></p></li><li><p>测距结果仅能从主机读取，当主机生成<code>IRQ RangingMasterResultValid</code>时，在下列寄存器中读出结果</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240415153404796.png" alt="image-20240415153404796"></p></li><li><p>最后一次测距的RSSI结果存储在0x964寄存器内，8位寄存器。换算dBm步骤参见opcode一章中瞬时 RSSI 值小节。</p></li></ol><h3 id="结果滤波"><a href="#结果滤波" class="headerlink" title="结果滤波"></a>结果滤波</h3><p>SX1280模块提供一个基于RSSI过滤器，它会筛选掉RSSI小于阈值的测距结果，并将剩余结果取平均值输出。</p><ol><li>首先需要选择使用多少个测距结果做为样本。这需要配置寄存器 Ranging Filter Window Size （0x91E），该寄存器有8位，值限制位8-255，分别对应选择8-255个样本。</li><li>设置样本阈值，小于该阈值的样本将被丢弃。这需要配置寄存器RangingFilterRssiThresholdOffset(0x953)。该寄存器内默认值为0x24。</li><li>剩余的结果将求平均值后写入结果寄存器</li></ol><p>该滤波器可以在任何时候进行重置，通过将寄存器Reset Ranging Filter(0x923)写1即可。</p><h3 id="结果解算"><a href="#结果解算" class="headerlink" title="结果解算"></a>结果解算</h3><p>在读取结果寄存器时，需要配置RangingResMUX（0x924）寄存器的(5:4)bit，来选择寄存器输出原始结果还是RSSI滤波后结果。</p><ul><li>00：原始结果</li><li>01：滤波结果</li></ul><p>此2bit复位值是0x3,也就是读取之前必须写入一次，使之成为上面两个参数二选一。</p><p>读出的值可由如下公式换算成m</p><script type="math/tex; mode=display">Distance(m)=Result*150/(2^{12}*BW)</script><p>读取代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FREEZE_RANGING_RESULT 0x97F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RANGING_RESULT_MUX 0x0924</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RANGING_RESULT_23_16 0x961</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RANGING_RESULT_15_8 0x962</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RANGING_RESULT_7_0 0x963</span></span><br><span class="line">SetStandby(STDBY_XOSC);<span class="comment">//第一步：切换为外部时钟</span></span><br><span class="line">WriteRegister(<span class="number">0x97F</span>,ReadRegister(<span class="number">0x97F</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);<span class="comment">//使能LoRa存储模块时钟,通过对0x97F第二位写1。</span></span><br><span class="line">WriteRegister(<span class="number">0x0924</span>,(ReadRegister(<span class="number">0x0924</span>)&amp;<span class="number">0xCF</span>|((resultType)&amp;<span class="number">0x03</span>)&lt;&lt;<span class="number">4</span>));<span class="comment">//将0x0924内的值与1100,1111与。</span></span><br><span class="line"><span class="comment">//相当于将bit5 bit4设置为00,再将resultType变量内定义的值填入。设置读取的值类型。</span></span><br><span class="line">valLsb=((ReadRegister(<span class="number">0x0961</span>)&lt;&lt;<span class="number">16</span>)|(ReadRegister(<span class="number">0x0962</span>)&lt;&lt;<span class="number">8</span>|(ReadRegister(<span class="number">0x0963</span>)));<span class="comment">//读取Ranging Result</span></span><br><span class="line">SetStandby(STDBY_RC);</span><br></pre></td></tr></table></figure><h1 id="LoRa通信包和测距"><a href="#LoRa通信包和测距" class="headerlink" title="LoRa通信包和测距"></a>LoRa通信包和测距</h1><p><strong>在使用LoRa通信时，扩频因子（SF）和带宽（BW）必须在链路的发送侧和接收侧预已知，因为不同的扩频因子彼此正交</strong></p><p>使用LoRa调制解调时，灵敏度和速率如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120042818216.png" alt="image-20240120042818216"></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240120042827446.png" alt="image-20240120042827446"></p><h2 id="LoRa-通信包格式"><a href="#LoRa-通信包格式" class="headerlink" title="LoRa 通信包格式"></a>LoRa 通信包格式</h2><p>LoRa调制有两种包格式，无论是哪种格式，preamble都是必须的。preamble用于接受信号的时钟同步，其基础长度为4.25个symbol （LoRa自动添加），冗余长度可在[8, 61444.25] 个符号编程。因此preamble的符号长度为[12.25, 61444.25]范围内。在<em>LoRa基础</em>一章中，已经介绍LoRa的包长度为$2^{SF}$，也就是下面两图的总symbol数是$2^{SF}$个。</p><p>两种格式如下：</p><ul><li><p>Explicit Header Mode（default）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240123175952581.png" alt="image-20240123175952581"></p><p>Explicit格式如图所示，相比于Implicit Header Mode，它多一个8个symbol长的header，其包含三部分：</p><ul><li>有效码字(payload) 长度</li><li>前向纠错码编码率</li><li>16bit-CRC是否使能</li></ul></li><li><p>Implicit Header Mode</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240123175412975.png" alt="image-20240123175412975"></p></li></ul><p>如果有效码字(payload)长度、前向纠错编码率、CRC使能状态已知，则可以省去header。此时有效码字(payload)长度、前向纠错编码率、CRC使能状态必须在通信链路双方进行手动预配置。</p><h2 id="LoRa测距包格式"><a href="#LoRa测距包格式" class="headerlink" title="LoRa测距包格式"></a>LoRa测距包格式</h2><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124010130578.png" alt="image-20240124010130578"></p><p>测距的包格式如上，其包含一个指定的测距Header，包含了测距指令+测距ID+2bit的CRC。Rangging symbols内包含测距同步信息和时钟同步信息。<strong>LoRa规定测距时SF的范围是[5, 10]，带宽BW范围是[400KHz, 1.6MHz].</strong></p><p>主机视角测距过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124010545561.png" alt="image-20240124010545561"></p><p>从机视角测距过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124010621166.png" alt="image-20240124010621166"></p><h2 id="测距引擎"><a href="#测距引擎" class="headerlink" title="测距引擎"></a>测距引擎</h2><h3 id="测距误差的来源"><a href="#测距误差的来源" class="headerlink" title="测距误差的来源"></a>测距误差的来源</h3><ul><li><p>主、从设备的时钟频率不一致</p></li><li><p>数字和模拟调制模块对信号产生了延迟，这种延迟需要手动补偿</p></li><li><p>多径效应</p></li></ul><p>针对以上误差，官方建议以交换主从设备，测好几遍来进行补偿。一个测两遍的补偿例子如下：</p><script type="math/tex; mode=display">  T_{Master-Slave}=2T_{ToF}-T_{ERROR}</script><script type="math/tex; mode=display">  T_{Slave-Master}=2T_{ToF}-T_{ERROR}</script><script type="math/tex; mode=display">  T_{RTToF}=\frac{T_{Master-Slave}+T_{Slave-Master}}{2}</script><p>官方给出了交换测距次数和测距误差的关系图( SF9 1600 kHz 条件下)</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124020804572.png" alt="image-20240124020804572" style="zoom:67%;" /></p><h3 id="距离分辨率"><a href="#距离分辨率" class="headerlink" title="距离分辨率"></a>距离分辨率</h3><p>LoRa的最小距离分辨率由如下公式计算得到：</p><script type="math/tex; mode=display">D_{LSB}=\frac{c}{2^{12}BW}</script><p>其中c是光速，BW是设置的带宽(与SF有关)</p><p>2倍测量距离（也就是飞行时间换算出的距离）和$D_{LSB}$可以由如下公式转换：</p><script type="math/tex; mode=display">D_{RTToF}=RangingRsult*D_{LSB}</script><h3 id="RxTx造成DELAY的补偿"><a href="#RxTx造成DELAY的补偿" class="headerlink" title="RxTx造成DELAY的补偿"></a>RxTx造成DELAY的补偿</h3><p>在初始测试时，需要在一段已知距离为D的空间内进行测距，来确定<strong>距离补偿误差</strong>。补偿误差可由如下公式计算：</p><script type="math/tex; mode=display">D_{uncalibrated}=((RangingResult * DLSB)/2)</script><script type="math/tex; mode=display">D_{calibration} = (D_{uncalibrated} - D) / 2</script><p>补偿时间可由如下公式进一步算得：</p><script type="math/tex; mode=display">Calibration = D_{calibration} / D_{LSB}</script><p>SEMTECH公司给出了一部分已知的Delay补偿值：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124014924763.png" alt="image-20240124014924763"></p><p><strong>在LoRa中，TxRx延迟的补偿是自动的，补偿值（Calibration）必须被写入RxTxDelay寄存器</strong></p><h3 id="时钟误差产生的测距误差的补偿"><a href="#时钟误差产生的测距误差的补偿" class="headerlink" title="时钟误差产生的测距误差的补偿"></a>时钟误差产生的测距误差的补偿</h3><p>LoRa在收发信号时，有一个频率误差指示器，由于射频信号的频率是参考各自的晶振频率产生的，因此可以使用LoRa频率误差指示器（FEI）对主设备和从设备之间的频率误差进行简单的频率误差测量，以准确评估定时误差和等效距离误差。其中官方给出的距离误差如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124015930104.png" alt="image-20240124015930104"></p><p>官方给出的BW和SF对测距精度的影响如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124020345728.png" alt="image-20240124020345728" style="zoom: 80%;" /></p><p>官方宣称在视线内，它具有和激光测距同等的精度。下图红色表示激光测距仪的误差范围。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124020611211.png" alt="image-20240124020611211" style="zoom: 67%;" /></p><h3 id="测距参数设计准则"><a href="#测距参数设计准则" class="headerlink" title="测距参数设计准则"></a>测距参数设计准则</h3><p>LoRa测距，SF和BW会影响广播时间(直接影响功耗)和测距距离，其关系图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124021355928.png" alt="image-20240124021355928"></p><p>可以看到SF影响测距距离，BW影响广播时间。当这俩个参数都最大时，测距可有最高精度。</p><h3 id="超短距离-lt-18-5m-的补偿"><a href="#超短距离-lt-18-5m-的补偿" class="headerlink" title="超短距离(&lt;18.5m)的补偿"></a>超短距离(&lt;18.5m)的补偿</h3><p>在小于18.5m时，LoRa测距会非常不精确，STMTECH给出了以下补偿公式：</p><script type="math/tex; mode=display">displayDistance = EXP( ( measuredDistance +2.4917 ) / 7.2262 ))</script><p>补偿效果图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124021812831.png" alt="image-20240124021812831"></p><h3 id="测距的计算："><a href="#测距的计算：" class="headerlink" title="测距的计算："></a>测距的计算：</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124022454968.png" alt="image-20240124022454968"></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124022730601.png" alt="image-20240124022730601"></p><p><strong>一个例子</strong>：配置测距参数如下，得到如下测距结果：</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124022121668.png"></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240124022331367.png"></center></td>    </tr></table>]]></content>
      
      
      <categories>
          
          <category> LoRa定位开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LoRa基础</title>
      <link href="/posts/4f0d2e64.html"/>
      <url>/posts/4f0d2e64.html</url>
      
        <content type="html"><![CDATA[<h1 id="LoRa的调制与扩频"><a href="#LoRa的调制与扩频" class="headerlink" title="LoRa的调制与扩频"></a>LoRa的调制与扩频</h1><p>由通信原理的知识知，在一个载波中，基带信息可以被承载在幅度、相位、和频率上。以2FSK调制为例，它使用两个不同频率的载波来分别表示不同的”0” 和 “1”。但是Chirp调制本身就进行了”扫频”, 那么如何来通过频率进行载波呢？由<em>扩频通信简介</em>一节中Chirp扩频知，Chirp频率是有个范围的，始于$f_0$，上下被$f_H,f_L$限制。<strong>LoRa将基带信息承载在这个$f_0$上面</strong>，也就是说，LoRa调制后Symbol的频率-时间图如下<strong>（LoRa采用线性Chirp）</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240117191531057.png" alt="image-20240117191531057"></p><p>信号在时域上振幅-时间图如下(这张图里面是down-chirp, 和上面那张up-chirp的图不是对应的关系)：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240117202641043.png" alt="image-20240117202641043"></p><p>论文[1]中作者把它称为：频移啁啾调制 Frequency Shift Chirp Modulation (FSCM) 大部分文章都是这么叫的，也有另外一些地方直接把这个称为PSK调制</p><h2 id="起始频率-f-0-的确定"><a href="#起始频率-f-0-的确定" class="headerlink" title="起始频率$f_0$的确定"></a>起始频率$f_0$的确定</h2><p><strong>LoRa的扩频因子SF不光决定了频率的展扩倍数，还决定了信道进制M</strong>(例如，8FSK的M=8，一个symbol包含$log_28=3$个bit)。M和SF的关系是：</p><script type="math/tex; mode=display">log_2M=SF</script><p>MFSK里，M为几就有几个不同的频率；对应地，LoRa里M为几就有几个不同的$f_0$。$M=2^{SF}$,也就是说，一个Chirp symbol 可以调进去SF个二进制位,共有$2^{SF}$种不同的$f_0$，我们把这一簇二级制数据记为一个向量<strong>w</strong>。举个例子，如果SF=4，那么一个Chirp symbol就有4个Bit，<strong>w</strong>就为</p><script type="math/tex; mode=display">w=[x,x,x,x]</script><p>其中x代表这一位可以是0也可以是1。那么第n个chirp symbol 承载的信息 $s(nT_s)$ 就可以用如下公式算得：</p><script type="math/tex; mode=display">s(nT_s)=\sum_{h=0}^{SF-1}w(nT_s)_h\cdot2^h</script><p><em>注意这个$w(nT_s)$是一个整体，下标h才代表取这个向量里面的第几个，这个$T_s$是符号持续时间，$nT_s$只是指这是第几个符号之后</em>。</p><p><strong>论文就是喜欢用弯弯绕绕的表达，这玩意其实就是把二进制序列换算成十进制了！</strong>，更详细地说，LoRa在调制的时候把二进制序列换算成了范围在$[0,2^{SF}-1]$的十进制，然后作为频率的偏移量调进载波里面。$s(nT_s)=\{0,1,2,3,4….,2^{SF}-1\}$</p><h2 id="调入载波"><a href="#调入载波" class="headerlink" title="调入载波"></a>调入载波</h2><p>现在，我们要把这个十进制数用成一个起始频率来表示。LoRa的码元持续时间$T_s$被规定成$T_s=\frac{2^{SF}}{Bandwidth}$，把这个$T_s$ 以B为采样频率离散化一下:</p><script type="math/tex; mode=display">T=\frac{1}{B}, T_s=2^{SF}\cdot T</script><p>同时再来个离散化的时间轴$k=0,1,2…2^{SF}-1$</p><p>那么频率相较于$f_L$的偏移量就可以通过$(s(nT_s)+k)\ mod\ 2^{SF}$算出来，这里巧妙的利用取余计算实现了频率顶到$f_H$又返回$f_L$的操作。整体的调后信号就可以被表示为：</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}e^{j2\pi[(s(nT_s)+k)mod2^{SF}]\frac{k}{2^{SF}}}</script><h2 id="LoRa的规定："><a href="#LoRa的规定：" class="headerlink" title="LoRa的规定："></a>LoRa的规定：</h2><ul><li><p>扩频因子： LoRa规定SF必须在[7,12]之内</p></li><li><p>码元持续时间：规定$T_s=\frac{2^{SF}}{Bandwidth}$</p><p>通过码元持续时间可以计算符号速率$R_s=\frac{BW}{2^{SF}}$</p></li><li><p>LoRa支持冗余纠错，SEMTECH定义了一个$Rate Code=\frac{4}{4+CR}$,其中CR={1,2,3,4}</p><p>在rate code已知时，bit传输速率使用这个公式计算：</p><script type="math/tex; mode=display">R_b=SF*\frac{Rate Code}{\frac{2^{SF}}{BW}}</script></li></ul><h1 id="LoRa的解调"><a href="#LoRa的解调" class="headerlink" title="LoRa的解调"></a>LoRa的解调</h1><p>我们已知，LoRa调后的信号长这样：</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}e^{j2\pi[(s(nT_s)+k)mod2^{SF}]\frac{k}{2^{SF}}}</script><p>这个信号可以看做是一个chirp信号被移动了一下初始相位，我们可以把它补偿回来以此来分离出chirp信号</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}e^{j2\pi[(s(nT_s)+k)mod2^{SF}+k-k]\frac{k}{2^{SF}}}</script><p>这里$+k-k$并不影响函数结果，但是我们却可以分离出一个$+k$出来</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}(e^{j2\pi \frac{k^2}{2^{SF}}})e^{j2\pi[(s(nT_s)+k)mod2^{SF}-k]\frac{k}{2^{SF}}}</script><p>在$(s(nT_s)+k)mod2^{SF}-k$中，这个取模运算是为了处理$(s(nT_s)+k)$超过了$f_H$的情况而使用的。但是这里整个时间尺度被-k之后，控制频率的分量将永远在$s(nT_s)$的范围内，不会超过$2^{SF}$,因此无需再取模计算。去掉mod画简后式子如下：</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}(e^{j2\pi \frac{k^2}{2^{SF}}})e^{j2\pi[(s(nT_s)]\frac{k}{2^{SF}}}</script><p>此时，基础chirp信号被分离出来了。在这个例子中这里这是一个up chirp信号。只需要将现在的接收信号乘上它自己的基础chirp信号的共轭$e^{-j2\pi \frac{k^2}{2^{SF}}}$，就可以把这个chirp信号消除掉。up chirp的共轭恰好为down chirp, down chirp的共轭为up chirp。消除后信号为：</p><script type="math/tex; mode=display">c(nT_s+kT)=\frac{1}{\sqrt{2^{SF}}}e^{j2\pi[(s(nT_s)]\frac{k}{2^{SF}}}</script><p>此时接收信号的频率只与我们调入的信息$s(nT_s)$相关了，对这个函数进行FFT，然后寻找FFT结果的峰值位置，即可解调出$s(nT_s)$内包含的信息。</p><p>因此，LoRa的解调只需要将收到的信号与其基础chirp信号的共轭相干，就可以分离出调入了信息的信号。</p><div class="note warning simple"><p>LoRa的调制和解调详细过程是SEMTECH闭源的，<strong>但是可以确定的是SF确实直接对应一个symbol能调几个bit，以及LoRa采用初始频率的shift去调制</strong>。其他的细节仅摘自论文，里面有很多只能看个大概的地方，就比如那个论文[1]里提及讲Ts离散化的时候，间隔时间T=1/B，这是不符合奈奎斯特采样定律的。看个大概就好……</p></div><h1 id="LoRa的时钟同步"><a href="#LoRa的时钟同步" class="headerlink" title="LoRa的时钟同步"></a>LoRa的时钟同步</h1><p>LoRa的时钟同步原理官方并未披露，现有的各种文章各执一词，但是大体都是前面有一段Preamble发送标准的up-chirp信号来进行同步。下图是对LoRa的信号进行捕获得到的。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240118000915052.png" alt="image-20240118000915052"></p><h1 id="emmmm"><a href="#emmmm" class="headerlink" title="emmmm"></a>emmmm</h1><p>研究了几十个小时，啃了十来篇文章，LoRa有太多东西是SEMTECH闭源的了，每个文章都是点逆向工程又讲得不明不白的。下面[3]这个youtube视频算是所有不明不白的文章的一个核心思想吧，但是每篇文章细节是有差异的。</p><p>搞了这么多，只想说好奇心害死猫，这玩意只能别人告诉你怎么用你就怎么用就行了╮(╯﹏╰）╭</p><p>所以说，有些东西没人搞，那必然是有没人搞的理由吧哎……活该干不过NB-IOT</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li>[1] L. Vangelista, “Frequency Shift Chirp Modulation: The LoRa Modulation,” in IEEE Signal Processing Letters, vol. 24, no. 12, pp. 1818-1821, Dec. 2017, doi: 10.1109/LSP.2017.2762960.</li><li>[2]  <a href="http://wiki.lahoud.fr/lib/exe/fetch.php?media=an1200.22.pdf">AN1200_22_Semtech_LoRa_Basics_v2_STD (lahoud.fr)</a></li><li>[3] <a href="https://www.youtube.com/watch?v=jHWepP1ZWTk">How LoRa Modulation really works - long range communication using chirps - YouTube</a></li><li>[4] H. Mroue, A. Nasser, B. Parrein, S. Hamrioui, E. Mona-Cruz and G. Rouyer, “Analytical and Simulation study for LoRa Modulation,” 2018 25th International Conference on Telecommunications (ICT), Saint-Malo, France, 2018, pp. 655-659, doi: 10.1109/ICT.2018.8464879.</li><li>[5] <a href="https://cea.hal.science/cea-02280910v2/document">Low Complexity LoRa Frame Synchronization for Ultra-Low Power Software-Defined Radios (hal.science)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LoRa定位开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -频带通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩频通信简介</title>
      <link href="/posts/65315.html"/>
      <url>/posts/65315.html</url>
      
        <content type="html"><![CDATA[<div class="note warning simple"><p>本篇文章涉及通信原理知识，需要掌握一定通信原理基础，了解基带调制，频带调制，相干解调，码元(符号)传输速率，Power Spectrum Density 等</p></div><p><strong>有三种基本的扩频方式：</strong></p><ul><li>跳频扩频(Frequency-hopping speread spectrum)</li><li>直接序列扩频(Direct-sequence spread spectrum)</li><li>啁啾扩频/线性调频扩频(Chirp Spread Spectrum)</li></ul><h1 id="跳频技术-FHSS"><a href="#跳频技术-FHSS" class="headerlink" title="跳频技术(FHSS)"></a>跳频技术(FHSS)</h1><p>传统的无线通信系统，发射机和接收机工作在单次通信过程中，载频一般是保持不变；例如通信频率是900MHz, 那么通信将一直使用这个频率进行。</p><p>跳频（Frequency Hopping)系统则在单次通信中，载频在多个频率上跳变。如901MHz, 902MHz etc.</p><h2 id="跳频系统的调制与解调"><a href="#跳频系统的调制与解调" class="headerlink" title="跳频系统的调制与解调"></a>跳频系统的调制与解调</h2><p>跳频的调制发生在频带调制之前。如下图所示，原始数据D(t)经过信息调制器后变成基带信号；同时产生一个伪随机序列来控制载波信号按照一定的规律跳变。接收端需要使用产生本振信号(local oscillator)进行相干，产生一个中频信号，中频信号再进行检波/解调。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114232032360.png" alt="image-20240114232032360"></p><p>伪随机序列控制下的载波频率如下图所示，在不同频段间跳跃，这个图被称为跳频图案，通信双方可根据实时参数及密钥推算得到当前跳频图案</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114233026923.png" alt="image-20240114233026923" style="zoom:50%;" /></p><p>对于产生跳频，有如下要求：</p><ul><li>(同一跳频图案具有良好的自相关性(类似冲激函数)</li><li>不同跳频图案具有良好的互相关性(相关值趋近于0</li><li>跳频图案具有良好的随机性，足够大的线性复杂度(抗截获和抗破译)</li><li>周期长和图案多(减小系统中各用户间的频点碰撞概率</li></ul><p>跳频可以分为快跳频和慢跳频：</p><ul><li><p><strong>快跳频</strong>：跳频周期小于符号周期(是Ts的约数)，一个符号传输需要多个频率</p></li><li><p><strong>慢跳频</strong>：跳频周期大于符号周期(是Ts的倍数)，一个频率传输多个符号</p></li></ul><p><strong>跳频通信可以带来很强的抗干扰能力的原因：</strong></p><ul><li>在同一时刻，干扰信号频率只有与跳频信号所在<strong>频率相同</strong>，且干扰信号能量足够大时，才能造成严重的影响</li><li>由于跳频图案具有<strong>伪随机性，其周期可长达数十年甚至更长</strong>，跳变的频率可达成千上万个，因此可以有效地躲避干扰。因此除非破译跳频图案，否则仅在某一频率或<strong>某几个频率上长时间施放干扰是无济于事的</strong>。而在整个频段长时间施放干扰难度很大</li></ul><h2 id="多址通信"><a href="#多址通信" class="headerlink" title="多址通信"></a>多址通信</h2><p> 多址技术是指把处于不同地点的多个用户接入一个公共传输媒质，实现各用户之间通信的技术。</p><p>例如，常见的多址技术有频分多址（<a href="https://baike.baidu.com/item/FDMA?fromModule=lemma_inlink">FDMA</a>）、时分多址（<a href="https://baike.baidu.com/item/TDMA?fromModule=lemma_inlink">TDMA</a>）、码分多址（<a href="https://baike.baidu.com/item/CDMA?fromModule=lemma_inlink">CDMA</a>）。</p><ul><li>FDMA：不同用户使用不同的频率</li><li>TDMA：不同用户发送时刻不同，以不同时隙实现通信</li><li>CDMA：以不同的代码序列来实现通信，码分多址的基本思想是靠不同的地址码来区分的地址。每个配有不同的地址码，用户所发射的载波既受基带数字信号调制，又受地址码调制。</li></ul><p><strong>跳频技术可以实现跳频多址：</strong>不同的用户使用不同的跳频图案，这样可以实现共享频段资源进行通信。下图就是不同用户以不同图案通信时的跳频图案。跳频有一定几率碰撞(两个发射器使用了同一个频率)，就是下图绿色的点点。通过对伪随机码进行设计，可以把跳频碰撞的概率控制得很小。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114234609263.png" alt="image-20240114234609263" style="zoom:80%;" /></p><hr><h1 id="直接序列扩频-（DSSS）"><a href="#直接序列扩频-（DSSS）" class="headerlink" title="直接序列扩频 （DSSS）"></a>直接序列扩频 （DSSS）</h1><h2 id="DSSS信号的调制与解调"><a href="#DSSS信号的调制与解调" class="headerlink" title="DSSS信号的调制与解调"></a>DSSS信号的调制与解调</h2><p>直接序列扩频使用扩频码(又称扩频序列、PN序列)，直接对基带信号进行频域扩宽。如下图就是一个对Bipolar NRZ信号扩频调制的例子。绿色的是频率更高的扩频码，由扩频序列产生器产生。讲基带信号与扩频码相乘，即可得到扩频信号。解调时，在本振信号相干得到中频信号后，再使用同样的扩频信号相干（这个过程称为解扩），即可恢复基带信号。</p><p><table>    <tr>        <td><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114235653121.png"></td>        <td><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114235840911.png"></td>    </tr></table><br>扩频的时域、频域对应图像如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240117192815452.png" alt="image-20240117192815452"></p><p>一个完整的扩频、解扩过程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240115000300778.png" alt="image-20240115000300778"></p><h2 id="扩频增益-扩频因子-Spreading-Factor"><a href="#扩频增益-扩频因子-Spreading-Factor" class="headerlink" title="扩频增益/扩频因子  Spreading Factor"></a>扩频增益/扩频因子  Spreading Factor</h2><p>下列定义式中，Rc为直扩码速率；Rb为信息码速率。T是其对应单的持续时间（$T=1/f$）。</p><script type="math/tex; mode=display">G=10lg(\frac{扩频后的信号频率}{原始信号频率})=10lg(\frac{R_C}{R_b})=10lg(\frac{T_b}{T_C})</script><p><strong>G就是扩频增益。Rc/Rb即为扩频因子也称扩频码长度、带宽扩展因子</strong></p><p>例如，原始信号频率为1MHz，扩频后为128MHz，则扩频因子$SF=128$ <em>(<strong>部分地方直接认为扩频因子就是增益G</strong>，其实就是是否取对数的区别)</em></p><p>一般来说，扩频序列越长，扩频倍数越大，扩频增益越大</p><h2 id="直扩信号优点和及其原理"><a href="#直扩信号优点和及其原理" class="headerlink" title="直扩信号优点和及其原理"></a>直扩信号优点和及其原理</h2><h3 id="直扩通信抗窄带干扰的原理"><a href="#直扩通信抗窄带干扰的原理" class="headerlink" title="直扩通信抗窄带干扰的原理"></a>直扩通信抗窄带干扰的原理</h3><ul><li><p>一个原始的窄带信号，在经历扩频序列扩频之后，其能量不变(频域面积不变)，而频域展宽。</p></li><li><p>在传输时叠加了窄带噪声信号（例如来自其他通信系统的通信信号）</p></li><li>解调时再次用扩频码相干，延展频域扩频信号的恢复成窄带信号，而对叠加的窄带噪声信号，则是进行了一个扩频的过程。</li><li>在经历Bandpass filter的时候，噪声信号大部分功率可被滤除掉</li></ul><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/1705249284302.jpg" alt="1705249284302" style="zoom:50%;" /></p><h3 id="直扩通信抗多径效应的原理"><a href="#直扩通信抗多径效应的原理" class="headerlink" title="直扩通信抗多径效应的原理"></a>直扩通信抗多径效应的原理</h3><p>受多径效应影响，接受到的信号由多个不同时延和相位的原始信号构成（来自不同传输路径）</p><ul><li>在单一解扩支路的情况下，通过调整解扩码的同步，可以只解扩振幅最强的一路信号，其他路径的信号在通过滤波器时就会被滤除</li><li>在多个解扩支路的情况下，接收端解扩码分别和来自不同路径的信号对齐，将其解扩分离。最后再将解扩出的多路信号相位时延对齐后叠加，恢复原始信号。</li></ul><h3 id="直扩信号抗劫获的原理"><a href="#直扩信号抗劫获的原理" class="headerlink" title="直扩信号抗劫获的原理"></a>直扩信号抗劫获的原理</h3><p>直扩信号频带很宽，功率谱密度很低。如果在接收机输入端，直扩信号的功率谱密度低于或与接收机热噪声功率谱密度相当，则接收机一般发现不了直扩信号(隐藏在噪声中)。</p><h3 id="直扩信号的保密性"><a href="#直扩信号的保密性" class="headerlink" title="直扩信号的保密性"></a>直扩信号的保密性</h3><p>接收端只有采用与发射端相同且同步的扩频序列，才能实现对直扩信号的解扩，恢复出发送信号而扩频序列具有随机特性，破译难度大直接序列扩频技术首先应用于军事通信</p><h2 id="直接序列扩频下的码分多址"><a href="#直接序列扩频下的码分多址" class="headerlink" title="直接序列扩频下的码分多址"></a>直接序列扩频下的码分多址</h2><p>不同用户采用不同的扩频序列，<strong>而这个扩频序列恰好就充当了码分多址里面地址码的作用。对某一个用户来说，他的接收机只能解扩对应扩频序列的信号，而其他用户的信号因为扩频序列不同，无法解扩，类似噪声。</strong>所以虽然看起来直扩通信每个用户看似占用频率很宽，但由于是共享不是独享，所以频谱利用率也很高的</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240115004032089.png" alt="image-20240115004032089"></p><h2 id="扩频序列（扩频码）"><a href="#扩频序列（扩频码）" class="headerlink" title="扩频序列（扩频码）"></a>扩频序列（扩频码）</h2><p>由前面介绍的直扩信号可以看出，我们希望扩频序列：</p><ul><li>近似于随机信号有良好的自相关特性（可有效提取自身信号），很小的互相关特性（不同扩频序列间干扰小）</li><li>有尽可能多的码(序列个数，就是不重复的码长度)<br>下面是常见的扩频序列</li></ul><h3 id="m序列"><a href="#m序列" class="headerlink" title="m序列"></a>m序列</h3><p>m序列又称<strong>最长线性反馈移位寄存器序列</strong>，它是由<strong>多级移位寄存器</strong>通过线性反馈(就是下图这些摩尔加的抽头)产生的最长的码序列</p><p><strong>对于n级的移位寄存器发生器所能产生的最大长度的码序列为$2^n -1$位</strong>（没有全0状态，因为一旦去了全0状态就无法游动到其他状态）</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240115005914227.png" alt="image-20240115005914227"></p><p><strong>不同初始状态的移位寄存器，只会产生不同相位的扩频序列，无法产生不同的扩频序列；不同的扩频序列需要通过改变抽头结构来产生。</strong>而且并不是所有抽头组合都能产生m序列，只有特殊的组合才可以。</p><p><strong>m序列有良好的自相关性，较小的互相关性的优点</strong></p><p>对于n位的m序列，它能产生的序列个数可由如下公式计算：(其中$\Phi$是欧拉数)</p><script type="math/tex; mode=display">\frac{\Phi(2^n-1)}{n}</script><p>计算可以发现，5级移位寄存器产生的$2^5 -1=31$位长度的m序列，只有6个。</p><p>因此，<strong>m序列具有数量较少的缺点</strong></p><center><strong>总结：m序列，优点：有良好的自相关性，较小的互相关性；缺点：m序列具有数量较少的缺点</strong></center><h3 id="M序列"><a href="#M序列" class="headerlink" title="M序列"></a>M序列</h3><p>m序列又称<strong>最长非线性反馈移位寄存器序列</strong>。M序列在m序列的基础上，加入了全0状态检测器，使其离开全0状态。</p><p>对于n个移位寄存器，可以产生$2^n$位的M序列</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240115011351277.png" alt="image-20240115011351277"></p><p>n级M序列的个数可以用如下公式来计算</p><script type="math/tex; mode=display">2^{2^{n-1}-n}</script><p>在同为5级的时候，M序列可以产生2048个。<strong>因此M序列序列数量远大于m序列，但M序列的自相关性和互相关性又不如m序列</strong></p><h3 id="Gold序列"><a href="#Gold序列" class="headerlink" title="Gold序列"></a>Gold序列</h3><p>Gold序列将两个m序列作为优选对，把两个m序列的输出结果进行摩尔加。</p><p><strong>它具有良好的自相关性，不明显的互相关性，构造简单</strong>因此获得广泛应用</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240115011757069.png" alt="image-20240115011757069"></p><hr><h1 id="啁啾扩频-线性调频扩频-CSS"><a href="#啁啾扩频-线性调频扩频-CSS" class="headerlink" title="啁啾扩频/线性调频扩频(CSS)"></a>啁啾扩频/线性调频扩频(CSS)</h1><h2 id="啁啾-zh-overline-ou-ji-overline-u"><a href="#啁啾-zh-overline-ou-ji-overline-u" class="headerlink" title="啁啾($zh\overline ou ji\overline u$)"></a>啁啾($zh\overline ou ji\overline u$)</h2><p>啁啾是频率随时间增加（up-chirp）或减少（down-chirp）的信号，其基本定义式如下：</p><script type="math/tex; mode=display">x(t)=sin(\phi(t))</script><p>可以看到啁啾使用相位的移动来控制震荡频率，其相位是一个与 $t$ 有关的函数。在这个表达式下，瞬时角频率 $\omega$ 也就成了$\phi$ 的变化速率，即对$\phi(t)$求导。</p><script type="math/tex; mode=display">\omega(t)=\frac{d\phi(t)}{dt}</script><p>再根据 $\omega$ 和 $f$ 的关系，可以写出频率表达式：</p><script type="math/tex; mode=display">f(t)=\frac{\omega(t)}{2\pi}</script><p>类似于“角加速度”的概念，定义一个瞬时角啁啾系数(instantaneous angular chirpyness) $\gamma(t)$，单位：$rad/s^2$</p><script type="math/tex; mode=display">\gamma(t)=\frac{d^2\phi(t)}{dt}=\frac{d\omega(t)}{dt}</script><p>instantaneous angular chirpyness 定义的是瞬时角频率的变化率，将角频率转化为频率，就得到的 instantaneous ordinary chirpyness $c(t)$ (定义为瞬时频率的变化率)</p><script type="math/tex; mode=display">c(t)=\frac{\gamma(t)}{2\pi}=\frac{df(t)}{2\pi}</script><h3 id="线性啁啾"><a href="#线性啁啾" class="headerlink" title="线性啁啾"></a>线性啁啾</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240116114246398.png" alt="image-20240116114246398"></p><p>线性啁啾是指的瞬时频率$f(t)$随时间呈线性变化，下式中c是啁啾率(chirp rate)，是一个常数，表达式为$c=\frac{f_1-f_0}{T}=\frac{\Delta f}{\Delta t}$</p><script type="math/tex; mode=display">f(t)=ct+f_0</script><p>转化成基本定义式中的相位的表达形式:</p><script type="math/tex; mode=display">\phi(t)=\phi_0+2\pi\int_0^tf(\tau)d\tau=\phi_0+2\pi(\frac{c}{2}t^2+f_0t)</script><p>其中$\phi_0$表示初始相位</p><h3 id="指数啁啾"><a href="#指数啁啾" class="headerlink" title="指数啁啾"></a>指数啁啾</h3><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240116120520930.png" alt="image-20240116120520930"></p><p>指数啁啾的定义为：</p><script type="math/tex; mode=display">f(t)=f_0k^{\frac{t}{T}}</script><p>它具有如果$t_1$和$t_2$间时间间隔$T=t_2-t_1$是常数，$f_2(t)/f_1(t)$也是常数的性质。</p><p>相位表达式如下：</p><script type="math/tex; mode=display">\phi(t)=\phi_0+2\pi\int_0^tf(\tau)d\tau=\phi_0+2\pi f_0(\frac{k^{\frac{t}{T}}-1}{ln(k)})</script><h3 id="双曲啁啾"><a href="#双曲啁啾" class="headerlink" title="双曲啁啾"></a>双曲啁啾</h3><p>双曲啁啾定义为：</p><script type="math/tex; mode=display">f(t)=\frac{f_0f_1T}{(f_0-f_1)t+f_1T}</script><p>其相位表达式为：</p><script type="math/tex; mode=display">\phi(t)=\phi_0+2\pi\int_0^tf(\tau)d\tau=\phi_0+2\pi \frac{-f_0f_1T}{f_1-f_0}ln(1-\frac{f_1-f_0}{f_1T}t)</script><p>除此之外，还有对数啁啾，二次(^2)啁啾等，都是指的其频率的变化呈现对数、二次的关系。</p><h2 id="啁啾扩频"><a href="#啁啾扩频" class="headerlink" title="啁啾扩频"></a>啁啾扩频</h2><p>由上方啁啾信号得知，啁啾信号频率随时间变化，也就是说，在频域来看，这个信号自带“扫频/扩频” 的特性。</p><p><strong>如果说使用这个信号来作为载波，调制信号，那么这么信号的带宽也就被扩宽了。这就是啁啾扩频的原理。</strong>啁啾扩频利用了其频率在整个带宽上线性变化的正弦脉冲信号来传输信息，因此不需要任何伪随机序列。</p><p>举个例子，下图这个调制模块（802.15.4a中定义的超带宽UWB调制，Chirp-UWB）：二进制信号先转化为差分信号后进行QPSK调制，再对QPSK信号进行进行啁啾调制来扩频得到QCSK信号。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240116124709497.png" alt="image-20240116124709497"></p><p>在这个例子中，调后的一个啁啾符号（Chirp Symbol）由4个啁啾脉冲（subchirp）构成，每个啁啾脉冲又可以携带一个QPSK信号。从而一个啁啾符号可以携带4个QPSK码字。</p><p>由于不能让这个啁啾信号占用无限的带宽，所以会对这个啁啾载频规定一个频率上限$f_H$和一个频率下限$f_L$，以up-chirp为例，它由起始频率$f_0$开始，随时间攀升，如果在自身持续周期内超过了$f_H$，那它将回到$f_L$,再继续爬升如下图所示(下图横坐标为时间$t$,纵坐标为频率$f$)。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240117184131604.png" alt="image-20240117184131604"></p><hr><center> ---CHAPTER END--- </center>]]></content>
      
      
      <categories>
          
          <category> LoRa定位开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 频带通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1-CH3-数字电路的化简</title>
      <link href="/posts/25488.html"/>
      <url>/posts/25488.html</url>
      
        <content type="html"><![CDATA[<h1 id="最小化策略"><a href="#最小化策略" class="headerlink" title="最小化策略"></a>最小化策略</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>包含名词：</strong></p><ul><li><p><strong>Literal:</strong> 字符，也就是有几个输入变量</p></li><li><p><strong>Implicant:</strong> 蕴含项，输入变量的不同组合,也就是卡诺图里面的圈，一个圈就是一种蕴含项。</p></li><li><p><strong>Prime implicant:</strong> 质蕴含项就是不能与其它蕴含项合并的蕴含项, 也就是，这个卡诺图的圈无法被更大的圈包裹.</p></li><li><p><strong>Cover:</strong> cover是不同implicant的组合，就是不同卡诺图的圈组合成的完整的表达式。</p></li><li><p><strong>Cost:</strong> 电路中所有 门的数量 + 门的输入信号的数量</p></li><li><p><strong>Essential prime implicant:</strong>  若函数的一个质蕴涵项包含有不被函数的其他任何质蕴涵项所包含的最小项，则此质蕴涵项被称为必要质蕴涵项。</p></li></ul><p><em>举个例子：</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114192019432.png" alt="image-20240114192019432"  /></p><p>$\overline x_2  x_3$就是一个essential prime implicant, 因为$m_{11}$没有被其他任何质蕴涵项包含。同理还有$x_3 \overline x_4$ 和$x_2 \overline x_3 x_4$.<br>在最少的cost的布尔方程里面，必要质蕴涵项是必须被包含的。写出必要质蕴涵项之后，发现$m_7$还没有被包含到。$m_7$可以被$\overline x_1  x_3$或者$\overline x_1  x_2 x_4$包含，取其最小成本$\overline x_1 x_3$,所以这个布尔函数最小cost是：</p><script type="math/tex; mode=display">f=\overline x_2  x_3 + x_3 \overline x_4+x_2 \overline x_3 x_4+\overline x_1 x_3</script><p><strong><em>因此，寻找最小cost电路的步骤是：</em></strong></p><ol><li><strong>写出$f$的所有质蕴含项*</strong></li><li><strong><em>找到所有必要质蕴涵项</em></strong></li><li><strong><em>如果必要质蕴含项就包含了函数的所有1状态，那这就是最小cost，如果没有，则需要添加cost最小的非必要质蕴涵项来覆盖所有1状态</em></strong></li></ol><hr><h1 id="多输出电路（Multiple-Output-circuits）"><a href="#多输出电路（Multiple-Output-circuits）" class="headerlink" title="多输出电路（Multiple-Output circuits）"></a><em>多输出电路（Multiple-Output circuits）</em></h1><p>在具有多个输出的电路中，让电路共享一些逻辑门可以有效减少cost</p><p>这要求在卡诺图化简中<strong>并不一定按照质蕴涵项去画圈，而是查看更多蕴含项，寻找相同的蕴含项</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114193447675.png" alt="image-20240114193447675"></p><p>如上图就有两个蕴含项可以被共享。CAD工具将会自动执行这个共享的过程。在人工设计（考试）的时候，多输出电路也可以通过尽量圈出可以共享的圈圈来减少cost</p><hr><h1 id="多级综合（Multilevel-Synthesis）—不考"><a href="#多级综合（Multilevel-Synthesis）—不考" class="headerlink" title="多级综合（Multilevel Synthesis）—不考"></a><em>多级综合（Multilevel Synthesis）—不考</em></h1><ul><li><p><strong>Fan-in (扇入):</strong> 一个逻辑门输入的数量</p></li><li><p><strong>Fan-out(扇出):</strong> 是指该模块直接调用的下级模块的个数。也就是一个逻辑门的输出连了几个下一级门。</p></li></ul><p>通常来说，使用CMOS制造的芯片存在扇入限制。通常希望AND门扇入小于5。可以使用分配率，把一层极的计算化成多个层级。下图就是两个例子</p><table>    <tr>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114193819266.png"/></center></td>        <td><center><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114193752663.png"/></center></td>    </tr></table><hr><h1 id="立体表示法（Cubical-Representation）"><a href="#立体表示法（Cubical-Representation）" class="headerlink" title="立体表示法（Cubical Representation）"></a><em>立体表示法（Cubical Representation）</em></h1><p>卡诺图能表示的函数大小受到限制，为了处理更大的函数，需要使用立方体表示。</p><h2 id="构造立方体"><a href="#构造立方体" class="headerlink" title="构造立方体"></a>构造立方体</h2><p>有几个变量，就需要构造一个几维的立方体。立方体的顶点代表不同变量组合，立方体的边必须是含有一个x的组合，x代表0或者1。而面是含有两个x的组合。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114194225368.png" alt="image-20240114194225368"></p><p><em>以这个三维的cube为例，</em>首先标注顶点，000为顶点开始的三条边（三个变量所以三条边，x在三条边上换3个位置）需要分别为00x,0x0,x00,这三条边连接的另一个顶点将会是001,010,100（也就是x取和000相反的情况）。然后将新的顶点以同样的规则向外延伸，直至构成立方体。</p><h2 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h2><p>$f={000,010,100,101,110}$,将函数表达出来，并在顶点处标注出来。上图中的顶点围成了一个面和一条线，这个面是xx0，这条线是10x,所以这个函数可以被化简成</p><script type="math/tex; mode=display">f=\overline x_3 +x_1x_2</script><h2 id="四维立方体："><a href="#四维立方体：" class="headerlink" title="四维立方体："></a>四维立方体：</h2><p>四维立方体可以画成在一个大立方体内囊括了一个小立方体。这样每个顶点都有4条支路，可以安装上面的方法标注顶点了。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114194642317.png" alt="image-20240114194642317"></p><hr><h1 id="表格法化简（Quine-McCluskey-法）"><a href="#表格法化简（Quine-McCluskey-法）" class="headerlink" title="表格法化简（Quine-McCluskey 法）"></a><strong>表格法化简（Quine-McCluskey 法）</strong></h1><h3 id="Step1-–-计算质蕴涵项"><a href="#Step1-–-计算质蕴涵项" class="headerlink" title="Step1 – 计算质蕴涵项"></a>Step1 – 计算质蕴涵项</h3><ol><li>首先，把minterm表达式的项按只含0个“1”，只含1个“1”，只含2个“1”，…，只含n个“1”（n为变量个数）划分为不同的Group，并按“1”的数量排列（升序或降序均可）成表</li><li>准备一张新表。从含有最少数量的“1”的Group开始依次向下，将当前Group中的每一项与下一个Group的每一项比较。若两者只有一个变量不同，则将两项提取出来，并将不同的变量处用x标记，生成一个新的项。如果新的项在新表中已存在，则不执行动作；若不存在，则将这个新的项放到新表中的相应Group中。最后，在原表的两个Group中将提取的两项对应的“Subcube Covered”打上标记（打√）</li><li>在新生成的表中，重复2，直到新表中不存在只有一个变量不同的项为止</li><li><strong>所有未被打√的项，就是质蕴涵项。</strong></li></ol><p>例如：$f_{(x_1,…x_4)}=\sum m(0,4,8,10,11,12,13,15)$</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114195340907.png" alt="image-20240114195340907"></p><p>所以这个表达式的质蕴涵项就是</p><script type="math/tex; mode=display">P={10x0,101x,110x,1x11,11x1,xx00}</script><h3 id="Step2-–-找到必要质蕴含项"><a href="#Step2-–-找到必要质蕴含项" class="headerlink" title="Step2 – 找到必要质蕴含项"></a>Step2 – 找到必要质蕴含项</h3><p>把step1中找到的质蕴涵项列成表,如下图。发现0和4只有xx00表达了，所以xx00是必要质蕴涵项。把$P_6$挑出来</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114195622722.png" alt="image-20240114195622722"></p><h3 id="Step3-–-找到最小成本非必要质蕴涵项"><a href="#Step3-–-找到最小成本非必要质蕴涵项" class="headerlink" title="Step3 – 找到最小成本非必要质蕴涵项"></a>Step3 – 找到最小成本非必要质蕴涵项</h3><p>移除p6和被p6表达的0,4,8,12(被挑走了)，得到下表</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114195726090.png" alt="image-20240114195726090"></p><p>可以看到p1和p2的cost是相同的（他们都只有一个x），但是p1只能表述10, p2可以表述10，11，因此称p2支配 (dominates) p1。因此在这里选择p2。同理，可以选择p5。可以看到p4已经被p2和p5表达，因此这是不必要的。</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240114195754979.png" alt="image-20240114195754979"></p><h3 id="Step4-–-完成化简"><a href="#Step4-–-完成化简" class="headerlink" title="Step4 – 完成化简"></a>Step4 – 完成化简</h3><p>取step2的必要质蕴含项，step3选取的之蕴含项，<br>所以，化简后：$C={p_2,p_5,p_6 },f=x_1\overline x_2 x_3+x_1 x_2 x_4+\overline x_1 \overline x_3$</p><hr><center> ---CHAPTER END--- </center>]]></content>
      
      
      <categories>
          
          <category> 数字电路设计与可靠性工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅思写作</title>
      <link href="/posts/34935.html"/>
      <url>/posts/34935.html</url>
      
        <content type="html"><![CDATA[<h1 id="通用句子"><a href="#通用句子" class="headerlink" title="通用句子"></a>通用句子</h1><h2 id="太多"><a href="#太多" class="headerlink" title="太多"></a>太多</h2><ul><li>be flooded with 被淹没</li><li>be drowning in 被淹没</li></ul><h2 id="形容人"><a href="#形容人" class="headerlink" title="形容人"></a>形容人</h2><ul><li>humble adj. 谦逊的</li><li>down to earth 接地气</li><li>entrepreneur n. 企业家  /ˌɒn.trə.prəˈnɜːr/； entrepreneurial adj. 具有企业家特质的;  </li></ul><h1 id="聊生活"><a href="#聊生活" class="headerlink" title="聊生活"></a>聊生活</h1><h2 id="广告的类型"><a href="#广告的类型" class="headerlink" title="广告的类型"></a>广告的类型</h2><ul><li>promotional flyer 传单</li><li>cold calling 广告电话</li></ul><h2 id="锻炼"><a href="#锻炼" class="headerlink" title="锻炼"></a>锻炼</h2><ul><li>Intense exercise 剧烈的运动</li></ul><h1 id="聊工作，聊未来"><a href="#聊工作，聊未来" class="headerlink" title="聊工作，聊未来"></a>聊工作，聊未来</h1><ul><li>technics n.技术</li></ul><h2 id="工作职位"><a href="#工作职位" class="headerlink" title="工作职位"></a>工作职位</h2><ul><li>a man work for government 公务员</li></ul><h1 id="自然环境"><a href="#自然环境" class="headerlink" title="自然环境"></a>自然环境</h1><ul><li>an oasis of calm in the midst of urban chaos 城市中的平静绿洲   (midst /mɪdst/ 在……当中 n.)；（chaos /ˈkeɪɒs/ 混乱 n.）；</li><li>Hustle and bustle 熙熙攘攘，城市的喧嚣</li><li>provide visual appeal 提供视觉吸引力（常用于描述观赏性植物）</li><li>symphony of birdsong 鸟鸣的交响曲 （symphony /ˈsɪmfəni/ 交响曲 n.）</li><li>become one with nature 融入为自然的一员</li><li>planting flowers = gardening </li></ul>]]></content>
      
      
      <categories>
          
          <category> 雅思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅思写作</title>
      <link href="/posts/34936.html"/>
      <url>/posts/34936.html</url>
      
        <content type="html"><![CDATA[<p>[施工中..]</p><h1 id="写作评分标准"><a href="#写作评分标准" class="headerlink" title="写作评分标准"></a>写作评分标准</h1><h1 id="Task1-小作文"><a href="#Task1-小作文" class="headerlink" title="Task1 小作文"></a>Task1 小作文</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h2><p>所有类型的小作文都遵循：</p><ul><li>第一段：一句话重述题目 + overall 开启图表概括。</li><li>body段：一般2-3段，根据图表聚类分段</li></ul><p>也就是总分结构</p><p>第一段的例文：</p><p><em>The diagram shows the different stages in the life cycle of a salmon. Overall, the cycle takes almost ten years and comprises three main stages, each of which takes place in a different aquatic environment.</em></p><h2 id="适用于所有类型小作文的注意事项"><a href="#适用于所有类型小作文的注意事项" class="headerlink" title="适用于所有类型小作文的注意事项"></a>适用于所有类型小作文的注意事项</h2><h3 id="数字的写法"><a href="#数字的写法" class="headerlink" title="数字的写法"></a>数字的写法</h3><p>数字1-9最好使用英文形式，10及以上的可以用数字（有两个数字组成的）</p><h2 id="流程图小作文-（flow-chart-process-tasks）"><a href="#流程图小作文-（flow-chart-process-tasks）" class="headerlink" title="流程图小作文 （flow chart / process tasks）"></a>流程图小作文 （flow chart / process tasks）</h2><p>顾名思义，流程图小作文会给一个工业加工流程、生物生长流程、机械运作流程等等流程，要求总结流程图中的信息（summarise the information），然后写出主要的流程（selecting and reporting the main features），并在相似的的地方呈现出比较。下图是一个例子</p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240303103536846.png" alt="image-20240303103536846" style="zoom:50%;" /></p><h3 id="段落构建"><a href="#段落构建" class="headerlink" title="段落构建"></a>段落构建</h3><ul><li>首先需要根据流程图将步骤（steps）分为几个阶段（stages），然后根据处理的流程中的变化，将阶段聚类分类成几个主要的阶段（main stages）。</li></ul><p><em>举个例子，这个流程图:</em></p><p><img src="https://cdn.jsdelivr.net/gh/kaysonz/BlogPicHost/imgs/image-20240303104910497.png" alt="image-20240303104910497" style="zoom:50%;" /></p><p><em>其整体可以分为在农田里面的，和进入工厂榨汁的两个main stages, 因此聚类步骤1-2在一起，3-7在一起。这些 main stages 使用能概括这个流程的上义词（umbrella terms）来概括</em></p><ul><li><p>使用首段结构：重述题目+overview概括流程。在此处概括时，需要包含：</p><ol><li><p><strong>有多少个步骤(这个可以用总的步骤时长代替，例如三文鱼的life cycle 总时长, 如果这里的步骤太多，则使说包含多少个main stages)</strong> </p></li><li><p><strong>流程对作用物的主要改变（如果前面说的时有几个步骤，这一步可以用一句话概括，如果上面说的main stages，则这里分别陈述main stages）；</strong></p></li></ol></li></ul><p>  <em>例如，main stages写法的例子：上例的两个main stage可以写为：the growing and harvesting of sugar cane &amp; the processing of the juice to produce sugar。因此，Overview可以写为：</em></p><p>  <em>另一个例子，使用有几个步骤+一句话概括：Overall, a geothermal power plant operates by using water as a medium to convert geothermal energy into electricity（流程对作用物的主要改变 ）, and the whole process consists of five steps.（有多少个步骤）</em></p><ul><li><p>根据 main stages 分出body段 （一般为2段）：</p><p>body段需要注意句首多样性：表明每个流程的连接词尽量变换位置，不能总是在句首。常用的变换方法在下方详细介绍。</p></li></ul><h2 id="饼图-Pie-chart"><a href="#饼图-Pie-chart" class="headerlink" title="饼图 (Pie chart)"></a>饼图 (Pie chart)</h2><h3 id="段落构建-1"><a href="#段落构建-1" class="headerlink" title="段落构建"></a>段落构建</h3><ul><li>横向对比，寻找时间维度数据差异；纵向对比，寻找对象尺度数据差异；</li><li>开头段可以用breakdown：The two pie charts give a breakdown of sth., 这是Pie chart独有的特性。</li><li></li><li>Body段，两个对象的饼分开讲。分为两段，一个对象占一段。</li></ul><h2 id="常用积累"><a href="#常用积累" class="headerlink" title="常用积累"></a>常用积累</h2><h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><p><strong>数据变化</strong></p><p><em>数据爬升</em></p><ul><li>have developed into main xxx - 在xxx中爬升到主导地位 <em>e.g. Oil have developed into main sources 石油能源中占比爬升到了主导地位</em></li><li>recovered/ recovert to 数据（积极地）增长</li><li>steep climb 快速爬升</li><li>dramatic increase 快速上长</li><li>peak v. 达到峰值</li><li></li></ul><p><em>数据下降</em></p><p><em>其他变化</em></p><ul><li>be expected to do - 预计如何（发展）<em>e.g. is expected to change considerably 预期有巨大的变化</em></li><li>remainder - (n. 剩余物) 数据余下的部分 <em>e.g. Australia used coal as the electricity source (50 units) and the remiander was produced from natural gas</em></li><li>fluctuate(v.) fluctuation(n.) 波动</li><li>mirror (v. 镜像) 用于两个很相似的数据，变化趋势相同</li><li>steadily adv.稳定地</li><li>marginally adv. 小</li><li>sharply adj./adv. 快速</li></ul><p><strong>数据很大</strong></p><ul><li>noticeably large amount of sth. </li></ul><p><strong>数据很小</strong></p><h3 id="生命周期相关"><a href="#生命周期相关" class="headerlink" title="生命周期相关"></a>生命周期相关</h3><ul><li>begin life as xxx (e.g. begin life as an egg) - 以xxx开启一段生命</li><li>Once it has xxx - 一旦达到xxx(条件)</li><li>feeds on sth. - 以sth.为食物</li></ul><h3 id="能源-环保相关"><a href="#能源-环保相关" class="headerlink" title="能源/环保相关"></a>能源/环保相关</h3><ul><li>non-renewable energy</li><li>fossil fuel</li><li></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>This is in stark contrast to 与……形成鲜明对比</li><li>In contrast</li></ul><h3 id="导出特殊值-观点"><a href="#导出特殊值-观点" class="headerlink" title="导出特殊值/观点"></a>导出特殊值/观点</h3><ul><li>notably, +引出峰值/关键点</li></ul><h1 id="Task2-大作文"><a href="#Task2-大作文" class="headerlink" title="Task2 大作文"></a>Task2 大作文</h1><p>不同于小作文，大作文需要陈述自己的观点，自己的观点可以完全站A, 完全站B，也可以认为双边都要。观点表述要清晰。</p><h2 id="问题解决讨论类"><a href="#问题解决讨论类" class="headerlink" title="问题解决讨论类"></a>问题解决讨论类</h2><p>作文题目提出一个问题，讨论/评价其解决的方法。</p><h3 id="要聚焦于题目抛出的问题。"><a href="#要聚焦于题目抛出的问题。" class="headerlink" title="要聚焦于题目抛出的问题。"></a>要聚焦于题目抛出的问题。</h3><p><em>举个例子：</em></p><p><em>Some people say that the best way to improve public health is by increasing the number of sports facilities. Others, however, say that this would have little effect on public health and that other measures arerequired.<br>Discuss both these views and give your own opinion.</em></p><p><em>在这个题目中，<strong>不要被 sports 局限，需要聚焦于 public health</strong>，首先应当阐释 public health 差的<strong>原因</strong>才是重点，然后从产生这个问题的<strong>原因出发</strong>，<strong>去评价</strong> increasing the number of sports facilities 这个解决方案。最后导出自己的观点</em></p><h3 id="段落构建-2"><a href="#段落构建-2" class="headerlink" title="段落构建"></a>段落构建</h3><ul><li>开头段：重述题目</li><li>Body1 : 聚焦于题目抛出的<strong>问题</strong>，分析造成这个<strong>问题的原因</strong>(Why)。可以按照问题-影响-为什么会造成这个问题来写。</li><li>Body2 : 评估各项<strong>可能的解决方案</strong>(How)，并导出自己赞同/不赞同的原因。</li><li>结尾段：总结即可</li></ul><h2 id="常用积累-1"><a href="#常用积累-1" class="headerlink" title="常用积累"></a>常用积累</h2><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><ul><li>combination of factors - 多因素的结合</li><li>alternative - n. 替代品；</li><li>intervention n. 干预；</li><li>a combination of factors 多因素</li><li>run/(be under) the risk of sth. 承受xxx风险</li><li>be extened into xxx 被延拓至xxx</li><li>no longer 不再; no longer than 不超过；no longer exist 不再存在</li><li>sb. do have an improtant role to play in sth.  sb.在sth.中确实扮演重要的角色</li></ul><h3 id="发展，教育类"><a href="#发展，教育类" class="headerlink" title="发展，教育类"></a>发展，教育类</h3><ul><li>be taken too far - 操之过急</li><li>well-rounded - 全面发展的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 雅思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
